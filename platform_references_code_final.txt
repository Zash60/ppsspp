./.editorconfig:[libretro/**.{cpp,h}]
./.editorconfig:[SDL/SDLMain.mm]
./.github/workflows/manual_generate_ipa.yml:name: Manual Generate iOS IPA/DEB
./.github/workflows/manual_generate_ipa.yml:  ios:
./.github/workflows/manual_generate_ipa.yml:    runs-on: macos-latest
./.github/workflows/manual_generate_ipa.yml:      - name: Install iOS dependencies
./.github/workflows/manual_generate_ipa.yml:          mkdir -p build-ios/PPSSPP.app
./.github/workflows/manual_generate_ipa.yml:          echo ${GIT_VERSION#v} > build-ios/PPSSPP.app/Version.txt
./.github/workflows/manual_generate_ipa.yml:          key: ios
./.github/workflows/manual_generate_ipa.yml:          export CCACHE_SLOPPINESS=pch_defines,clang_index_store,ivfsoverlay,include_file_ctime,include_file_mtime,modules,system_headers,time_macros
./.github/workflows/manual_generate_ipa.yml:          ./b-ios.sh
./.github/workflows/manual_generate_ipa.yml:          if [ -e build-ios/PPSSPP.app ]; then
./.github/workflows/manual_generate_ipa.yml:            # Get the final files generated by b-ios.h script
./.github/workflows/manual_generate_ipa.yml:          name: iOS-IPA build
./.github/workflows/manual_generate_ipa.yml:          name: iOS-DEB build
./.github/workflows/manual_generate_uwp.yml:name: Manual Generate UWP MSIX/MSIXBundle
./.github/workflows/manual_generate_uwp.yml:  build-uwp:
./.github/workflows/manual_generate_uwp.yml:    name: Generate ${{ github.event.inputs.buildConfiguration }} ${{ github.event.inputs.buildPlatform }} UWP
./.github/workflows/manual_generate_uwp.yml:    runs-on: windows-latest
./.github/workflows/manual_generate_uwp.yml:      #  id: cache-uwp
./.github/workflows/manual_generate_uwp.yml:      #      UWP/${{ github.event.inputs.buildPlatform }}/${{ github.event.inputs.buildConfiguration }}/**
./.github/workflows/manual_generate_uwp.yml:      #    key: uwp-${{ github.event.inputs.buildConfiguration }}-${{ github.event.inputs.buildPlatform }}
./.github/workflows/manual_generate_uwp.yml:          msbuild UWP/PPSSPP_UWP.sln /m /p:TrackFileAccess=false /p:Configuration=${{ github.event.inputs.buildConfiguration }} /p:Platform=${{ github.event.inputs.buildPlatform }} /p:IncludeSymbols=${{ env.INCLUDE_SYMBOLS }} /p:AppxSymbolPackageEnabled=${{ env.INCLUDE_SYMBOLS }} /p:AppxPackageSigningEnabled=${{ github.event.inputs.signedPackage }} /p:PackageCertificateKeyFile=PPSSPP_UWP_TemporaryKey.pfx /p:AppxBundle=Never /p:UapAppxPackageBuildMode=SideloadOnly /p:AppxBundlePlatforms="${{ github.event.inputs.buildPlatform }}"
./.github/workflows/manual_generate_uwp.yml:          msbuild UWP/PPSSPP_UWP.sln /m /p:TrackFileAccess=false /p:Configuration=${{ github.event.inputs.buildConfiguration }} /p:Platform=x64 /p:IncludeSymbols=${{ env.INCLUDE_SYMBOLS }} /p:AppxSymbolPackageEnabled=${{ env.INCLUDE_SYMBOLS }} /p:AppxPackageSigningEnabled=${{ github.event.inputs.signedPackage }} /p:PackageCertificateKeyFile=PPSSPP_UWP_TemporaryKey.pfx /p:AppxBundle=Always /p:UapAppxPackageBuildMode=SideloadOnly /p:AppxBundlePlatforms="x64|ARM64|ARM"
./.github/workflows/manual_generate_uwp.yml:          #ls UWP/AppPackages/PPSSPP_UWP
./.github/workflows/manual_generate_uwp.yml:          cp -r UWP/AppPackages/PPSSPP_UWP/*.* ppsspp/
./.github/workflows/manual_generate_uwp.yml:          name: UWP-${{ github.event.inputs.buildConfiguration }}-${{ github.event.inputs.buildPlatform }} build
./.gitignore:Windows/.vs
./.gitignore:Windows/x64
./.gitignore:Windows/ARM
./.gitignore:Windows/ARM64
./.gitignore:Windows/ipch
./.gitignore:Windows/bin-release
./.gitignore:Windows/win-version.h
./.gitignore:Windows/win-version-*.tmp
./.gitignore:PPSSPPWindows64.exe.manifest
./.gitignore:PPSSPPWindows.exe.manifest
./.gitignore:PPSSPPWindowsARM64.exe.manifest
./.gitignore:PPSSPPWindowsARM.exe.manifest
./.gitignore:UWP/icph
./.gitignore:UWP/*.ipch
./.gitignore:UWP/Content/*
./.gitignore:!UWP/Content/.empty
./.gitignore:UWP/.vs
./.gitignore:# For Mac
./.gitignore:PPSSPPSDL.app
./.gitignore:# Qt Linguist files
./.gitignore:# Temp file used by jenkins windows build (TODO: remove)
./.gitignore:Windows/compileData*
./.gitignore:Windows/*.ipch
./.gitignore:Windows/imgui.ini
./.gitignore:# Libretro build
./.gitignore:libretro/obj/local
./.gitlab-ci.yml:# DESCRIPTION: GitLab CI/CD for libRetro (NOT FOR GitLab-proper)
./.gitlab-ci.yml:    CORE_ARGS: -DLIBRETRO=ON
./.gitlab-ci.yml:    MAKEFILE_PATH: libretro
./.gitlab-ci.yml:  # Windows 64bit
./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./.gitlab-ci.yml:    file: '/windows-x64-msvc19-msys2.yml'
./.gitlab-ci.yml:  # Windows 32bit
./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./.gitlab-ci.yml:    file: '/windows-i686-msvc19-msys2.yml'
./.gitlab-ci.yml:  # Linux
./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./.gitlab-ci.yml:    file: '/linux-cmake.yml'
./.gitlab-ci.yml:  # MacOS 64-bit
./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./.gitlab-ci.yml:  # MacOS arm64
./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./.gitlab-ci.yml:  # iOS
./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./.gitlab-ci.yml:    file: '/ios-cmake.yml'
./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./.gitlab-ci.yml:# Windows 64-bit
./.gitlab-ci.yml:libretro-build-windows-x64:
./.gitlab-ci.yml:    - .libretro-windows-x64-msvc19-msys2-make-default
./.gitlab-ci.yml:# Windows 32-bit
./.gitlab-ci.yml:libretro-build-windows-i686:
./.gitlab-ci.yml:    - .libretro-windows-i686-msvc19-msys2-make-default
./.gitlab-ci.yml:# Linux 64-bit
./.gitlab-ci.yml:libretro-build-linux-x64:
./.gitlab-ci.yml:    - .libretro-linux-cmake-x86_64
./.gitlab-ci.yml:# Linux 32-bit
./.gitlab-ci.yml:libretro-build-linux-i686:
./.gitlab-ci.yml:    - .libretro-linux-cmake-x86
./.gitlab-ci.yml:# MacOS 64-bit
./.gitlab-ci.yml:libretro-build-osx-x64:
./.gitlab-ci.yml:    CORE_ARGS: -DLIBRETRO=ON -DUSE_SYSTEM_LIBPNG=OFF
./.gitlab-ci.yml:    - .libretro-osx-cmake-x86_64
./.gitlab-ci.yml:# MacOS 64-bit
./.gitlab-ci.yml:libretro-build-osx-arm64:
./.gitlab-ci.yml:    - .libretro-osx-cmake-arm64
./.gitlab-ci.yml:libretro-build-android-armeabi-v7a:
./.gitlab-ci.yml:    - .libretro-android-cmake-armeabi-v7a
./.gitlab-ci.yml:libretro-build-android-arm64-v8a:
./.gitlab-ci.yml:    - .libretro-android-cmake-arm64-v8a
./.gitlab-ci.yml:libretro-build-android-x86_64:
./.gitlab-ci.yml:    - .libretro-android-cmake-x86_64
./.gitlab-ci.yml:libretro-build-android-x86:
./.gitlab-ci.yml:    - .libretro-android-cmake-x86
./.gitlab-ci.yml:# iOS arm64
./.gitlab-ci.yml:libretro-build-ios-arm64:
./.gitlab-ci.yml:    - .libretro-ios-cmake-arm64
./.gitlab-ci.yml:    CORE_ARGS: -DCMAKE_TOOLCHAIN_FILE=cmake/Toolchains/ios.cmake -DLIBRETRO=ON
./.gitlab-ci.yml:libretro-build-tvos-arm64:
./.gitlab-ci.yml:    - .libretro-tvos-cmake-arm64
./.gitlab-ci.yml:    CORE_ARGS: -DIOS_PLATFORM=TVOS -DCMAKE_TOOLCHAIN_FILE=cmake/Toolchains/ios.cmake -DLIBRETRO=ON
./.ycm_extra_conf.py:'-Wno-variadic-macros',
./CMakeLists.txt:add_compile_definitions(__STDC_CONSTANT_MACROS)
./CMakeLists.txt:		# M1 Mac
./CMakeLists.txt:				set(CMAKE_ASM_FLAGS "${CMAKE_ASM_FLAGS} -target armv7a-none-linux-android")
./CMakeLists.txt:if(NOT ANDROID AND NOT IOS)
./CMakeLists.txt:	set(LINUX ON)
./CMakeLists.txt:	add_compile_definitions(__STDC_CONSTANT_MACROS)
./CMakeLists.txt:	set(MACOSX ON)
./CMakeLists.txt:# We only support Vulkan on Unix, macOS (by MoltenVK), Android and Windows.
./CMakeLists.txt:	set(DEFAULT_USE_SYSTEM_LIBSDL2 ON)
./CMakeLists.txt:	if(IOS_APP_STORE)
./CMakeLists.txt:		message("WARNING: Gold build for iOS is deprecated")
./CMakeLists.txt:	if(NOT IOS_APP_STORE)
./CMakeLists.txt:	message("USE_IAP for iOS enabled")
./CMakeLists.txt:if(IOS_APP_STORE)
./CMakeLists.txt:	add_compile_definitions(PPSSPP_PLATFORM_IOS_APP_STORE)
./CMakeLists.txt:	message("iOS App Store build")
./CMakeLists.txt:elseif(IOS)
./CMakeLists.txt:	message("iOS sideload build")
./CMakeLists.txt:option(USING_QT_UI "Set to ON if you wish to use the Qt frontend wrapper" ${USING_QT_UI})
./CMakeLists.txt:option(LIBRETRO "Set to ON to generate the libretro target" OFF)
./CMakeLists.txt:option(USE_SYSTEM_LIBSDL2 "Dynamically link against system SDL2" ${DEFAULT_USE_SYSTEM_LIBSDL2})
./CMakeLists.txt:if(NOT ANDROID AND NOT WIN32 AND (NOT APPLE OR IOS))
./CMakeLists.txt:	find_package(SDL2)
./CMakeLists.txt:	find_package(SDL2_ttf)
./CMakeLists.txt:	# TODO: this can be removed once CI supports newer SDL2_ttf
./CMakeLists.txt:	if (NOT SDL2_ttf_FOUND)
./CMakeLists.txt:			pkg_check_modules(SDL2_ttf_PKGCONFIG IMPORTED_TARGET SDL2_ttf)
./CMakeLists.txt:		add_compile_options("$<$<COMPILE_LANGUAGE:CXX>:-Wno-class-memaccess>")
./CMakeLists.txt:	Common/Render/Text/draw_text_sdl.cpp
./CMakeLists.txt:	Common/Render/Text/draw_text_sdl.h
./CMakeLists.txt:	Common/Render/Text/draw_text_uwp.cpp
./CMakeLists.txt:	Common/Render/Text/draw_text_uwp.h
./CMakeLists.txt:if(IOS)
./CMakeLists.txt:if(NOT LIBRETRO)
./CMakeLists.txt:			elseif(IOS)
./CMakeLists.txt:				if(IOS_PLATFORM STREQUAL "TVOS")
./CMakeLists.txt:					set(PLATFORM_ARCH "ios/universal")
./CMakeLists.txt:			elseif(MACOSX)
./CMakeLists.txt:				set(PLATFORM_ARCH "macosx/universal")
./CMakeLists.txt:			elseif(LINUX)
./CMakeLists.txt:					set(PLATFORM_ARCH "linux/armv7")
./CMakeLists.txt:					set(PLATFORM_ARCH "linux/aarch64")
./CMakeLists.txt:					set(PLATFORM_ARCH "linux/arm")
./CMakeLists.txt:					set(PLATFORM_ARCH "linux/mips32")
./CMakeLists.txt:					set(PLATFORM_ARCH "linux/riscv64")
./CMakeLists.txt:					set(PLATFORM_ARCH "linux/loongarch64")
./CMakeLists.txt:					set(PLATFORM_ARCH "linux/x86_64")
./CMakeLists.txt:					set(PLATFORM_ARCH "linux/x86")
./CMakeLists.txt:					set(PLATFORM_ARCH "Windows/x86_64")
./CMakeLists.txt:					set(PLATFORM_ARCH "Windows/x86")
./CMakeLists.txt:		if(CMAKE_SYSTEM_NAME MATCHES WindowsPhone OR CMAKE_SYSTEM_NAME MATCHES WindowsStore)
./CMakeLists.txt:			target_sources(libzip PRIVATE ext/libzip/zip_random_uwp.c)
./CMakeLists.txt:if(ANDROID OR ARMV7 OR ARM64 OR ARM OR IOS)
./CMakeLists.txt:if(IOS OR MACOSX)
./CMakeLists.txt:elseif(IOS AND NOT LIBRETRO)
./CMakeLists.txt:		ios/main.mm
./CMakeLists.txt:		ios/AppDelegate.mm
./CMakeLists.txt:		ios/AppDelegate.h
./CMakeLists.txt:		ios/SceneDelegate.mm
./CMakeLists.txt:		ios/SceneDelegate.h
./CMakeLists.txt:		ios/DisplayManager.h
./CMakeLists.txt:		ios/DisplayManager.mm
./CMakeLists.txt:		ios/Controls.h
./CMakeLists.txt:		ios/Controls.mm
./CMakeLists.txt:		ios/ViewControllerCommon.h
./CMakeLists.txt:		ios/ViewControllerCommon.mm
./CMakeLists.txt:		ios/ViewController.mm
./CMakeLists.txt:		ios/ViewController.h
./CMakeLists.txt:		ios/ViewControllerMetal.mm
./CMakeLists.txt:		ios/ViewControllerMetal.h
./CMakeLists.txt:		ios/iOSCoreAudio.mm
./CMakeLists.txt:		ios/iOSCoreAudio.h
./CMakeLists.txt:		ios/IAPManager.mm
./CMakeLists.txt:		ios/IAPManager.h
./CMakeLists.txt:		ios/CameraHelper.mm
./CMakeLists.txt:		ios/CameraHelper.h
./CMakeLists.txt:		ios/LocationHelper.mm
./CMakeLists.txt:		ios/LocationHelper.h
./CMakeLists.txt:		ios/PPSSPPUIApplication.h
./CMakeLists.txt:		ios/PPSSPPUIApplication.mm
./CMakeLists.txt:		ios/SmartKeyboardMap.cpp
./CMakeLists.txt:		ios/SmartKeyboardMap.hpp
./CMakeLists.txt:		ios/iCade/iCadeReaderView.h
./CMakeLists.txt:		ios/iCade/iCadeReaderView.m
./CMakeLists.txt:		ios/iCade/iCadeState.h
./CMakeLists.txt:	set(nativeExtraLibs ${nativeExtraLibs} "-framework Foundation -framework MediaPlayer -framework AudioToolbox -framework CoreGraphics -framework CoreMotion -framework QuartzCore -framework UIKit -framework GLKit -framework OpenAL -framework AVFoundation -framework CoreLocation -framework CoreText -framework CoreVideo -framework CoreMedia -framework CoreServices -framework Metal -framework IOSurface" )
./CMakeLists.txt:	if(EXISTS "${CMAKE_IOS_SDK_ROOT}/System/Library/Frameworks/GameController.framework")
./CMakeLists.txt:	set_source_files_properties(ios/AppDelegate.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:	set_source_files_properties(ios/ViewController.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:	set_source_files_properties(ios/ViewControllerMetal.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:	set_source_files_properties(ios/iOSCoreAudio.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:	set_source_files_properties(ios/PPSSPPUIApplication.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:	set_source_files_properties(ios/iCade/iCadeReaderView.m PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:	set_source_files_properties(ios/main.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:	set_source_files_properties(ios/CameraHelper.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:	set_source_files_properties(ios/AudioEngine.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:	set_source_files_properties(ios/LocationHelper.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:	set_source_files_properties(ios/DisplayManager.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:	set_source_files_properties(ios/Controls.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:elseif(IOS AND LIBRETRO)
./CMakeLists.txt:elseif(USING_QT_UI)
./CMakeLists.txt:	find_package(Qt5 COMPONENTS OpenGL Gui Core Multimedia)
./CMakeLists.txt:		Qt/QtMain.cpp
./CMakeLists.txt:		Qt/QtMain.h
./CMakeLists.txt:		Qt/mainwindow.cpp
./CMakeLists.txt:		Qt/mainwindow.h
./CMakeLists.txt:	add_compile_definitions(USING_QT_UI)
./CMakeLists.txt:		add_compile_definitions(QT_OPENGL_ES QT_OPENGL_ES_2)
./CMakeLists.txt:	include_directories(Qt)
./CMakeLists.txt:	set(nativeExtraLibs ${nativeExtraLibs} Qt5::OpenGL Qt5::Gui Qt5::Core Qt5::Multimedia)
./CMakeLists.txt:	set(TargetBin PPSSPPQt)
./CMakeLists.txt:	# Enable SDL joystick if SDL is found
./CMakeLists.txt:	if(SDL2_FOUND)
./CMakeLists.txt:		add_compile_definitions(SDL)
./CMakeLists.txt:			SDL/SDLJoystick.h
./CMakeLists.txt:			SDL/SDLJoystick.cpp
./CMakeLists.txt:		set(nativeExtraLibs ${nativeExtraLibs} SDL2::SDL2)
./CMakeLists.txt:	# Don't care about SDL.
./CMakeLists.txt:	set(TargetBin PPSSPPWindows)
./CMakeLists.txt:elseif(LIBRETRO)
./CMakeLists.txt:		set(TargetBin PPSSPPSDL)
./CMakeLists.txt:	# Require SDL
./CMakeLists.txt:	add_compile_definitions(SDL)
./CMakeLists.txt:		SDL/SDLJoystick.h
./CMakeLists.txt:		SDL/SDLJoystick.cpp
./CMakeLists.txt:		SDL/SDLMain.cpp
./CMakeLists.txt:		SDL/SDLGLGraphicsContext.cpp
./CMakeLists.txt:			SDL/SDLVulkanGraphicsContext.cpp
./CMakeLists.txt:	if(SDL2_ttf_FOUND OR
./CMakeLists.txt:		(SDL2_ttf_PKGCONFIG_FOUND AND
./CMakeLists.txt:			SDL2_ttf_PKGCONFIG_VERSION VERSION_GREATER_EQUAL "2.0.18"))
./CMakeLists.txt:		add_compile_definitions(USE_SDL2_TTF)
./CMakeLists.txt:			add_compile_definitions(USE_SDL2_TTF_FONTCONFIG)
./CMakeLists.txt:	elseif(SDL2_ttf_PKGCONFIG_FOUND)
./CMakeLists.txt:		message(WARNING "Found SDL2_ttf <2.0.18 - this is too old, falling back to atlas")
./CMakeLists.txt:	if(SDL2_ttf_FOUND)
./CMakeLists.txt:		set(nativeExtraLibs ${nativeExtraLibs} SDL2_ttf::SDL2_ttf)
./CMakeLists.txt:	elseif(SDL2_ttf_PKGCONFIG_FOUND)
./CMakeLists.txt:		set(nativeExtraLibs ${nativeExtraLibs} PkgConfig::SDL2_ttf_PKGCONFIG)
./CMakeLists.txt:		SDL/SDLMain.h
./CMakeLists.txt:		SDL/SDLMain.mm
./CMakeLists.txt:		SDL/SDLCocoaMetalLayer.h
./CMakeLists.txt:		SDL/SDLCocoaMetalLayer.mm
./CMakeLists.txt:		SDL/CocoaBarItems.mm
./CMakeLists.txt:		SDL/CocoaBarItems.h
./CMakeLists.txt:		SDL/PPSSPPAboutViewController.m
./CMakeLists.txt:		SDL/PPSSPPAboutViewController.h
./CMakeLists.txt:		SDL/MacCameraHelper.mm
./CMakeLists.txt:		# set_source_files_properties(SDL/SDLMain.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:		set_source_files_properties(SDL/CocoaMetalLayer.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:		set_source_files_properties(SDL/CocoaBarItems.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:		set_source_files_properties(SDL/PPSSPPAboutViewController.m PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:		set_source_files_properties(SDL/MacCameraHelper.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./CMakeLists.txt:		if(USE_SYSTEM_LIBSDL2)
./CMakeLists.txt:			set(nativeExtraLibs ${nativeExtraLibs} SDL2::SDL2)
./CMakeLists.txt:			set(nativeExtraLibs ${nativeExtraLibs} ${SDL2Fwk})
./CMakeLists.txt:		set(nativeExtraLibs ${nativeExtraLibs} pthread SDL2::SDL2)
./CMakeLists.txt:		set(nativeExtraLibs ${nativeExtraLibs} SDL2::SDL2)
./CMakeLists.txt:if(NOT LIBRETRO)
./CMakeLists.txt:	if (NOT LIBRETRO)
./CMakeLists.txt:if (IOS)
./CMakeLists.txt:	Common/Render/Text/draw_text_qt.cpp
./CMakeLists.txt:	Common/Render/Text/draw_text_qt.h
./CMakeLists.txt:if(LINUX AND NOT ANDROID)
./CMakeLists.txt:if(ANDROID OR (LINUX AND ARM_DEVICE) OR (LINUX AND RISCV64) OR (LINUX AND LOONGARCH64))
./CMakeLists.txt:	Core/HLE/sceDmac.cpp
./CMakeLists.txt:	Core/HLE/sceDmac.h
./CMakeLists.txt:if(USE_DISCORD AND NOT IOS AND NOT LIBRETRO)
./CMakeLists.txt:		if (MACOSX)
./CMakeLists.txt:	set(WIN_VERSION_CMD COMMAND ${CMAKE_SOURCE_DIR}/Windows/git-version-gen.cmd PPSSPPWindows)
./CMakeLists.txt:set(WindowsFiles
./CMakeLists.txt:	Windows/WindowsAudio.cpp
./CMakeLists.txt:	Windows/WindowsAudio.h
./CMakeLists.txt:	Windows/WASAPIContext.cpp
./CMakeLists.txt:	Windows/WASAPIContext.h
./CMakeLists.txt:	Windows/Debugger/BreakpointWindow.cpp
./CMakeLists.txt:	Windows/Debugger/BreakpointWindow.h
./CMakeLists.txt:	Windows/Debugger/DumpMemoryWindow.cpp
./CMakeLists.txt:	Windows/Debugger/DumpMemoryWindow.h
./CMakeLists.txt:	Windows/Debugger/CtrlDisAsmView.cpp
./CMakeLists.txt:	Windows/Debugger/CtrlDisAsmView.h
./CMakeLists.txt:	Windows/Debugger/CtrlMemView.cpp
./CMakeLists.txt:	Windows/Debugger/CtrlMemView.h
./CMakeLists.txt:	Windows/Debugger/CtrlRegisterList.cpp
./CMakeLists.txt:	Windows/Debugger/CtrlRegisterList.h
./CMakeLists.txt:	Windows/Debugger/DebuggerShared.cpp
./CMakeLists.txt:	Windows/Debugger/DebuggerShared.h
./CMakeLists.txt:	Windows/Debugger/Debugger_Disasm.cpp
./CMakeLists.txt:	Windows/Debugger/Debugger_Disasm.h
./CMakeLists.txt:	Windows/Debugger/Debugger_MemoryDlg.cpp
./CMakeLists.txt:	Windows/Debugger/Debugger_MemoryDlg.h
./CMakeLists.txt:	Windows/Debugger/Debugger_Lists.cpp
./CMakeLists.txt:	Windows/Debugger/Debugger_Lists.h
./CMakeLists.txt:	Windows/Debugger/Debugger_VFPUDlg.cpp
./CMakeLists.txt:	Windows/Debugger/Debugger_VFPUDlg.h
./CMakeLists.txt:	Windows/Debugger/WatchItemWindow.cpp
./CMakeLists.txt:	Windows/Debugger/WatchItemWindow.h
./CMakeLists.txt:	Windows/Debugger/EditSymbolsWindow.cpp
./CMakeLists.txt:	Windows/Debugger/EditSymbolsWindow.h
./CMakeLists.txt:	Windows/GEDebugger/CtrlDisplayListView.cpp
./CMakeLists.txt:	Windows/GEDebugger/SimpleGLWindow.cpp
./CMakeLists.txt:	Windows/GEDebugger/TabState.cpp
./CMakeLists.txt:	Windows/GEDebugger/VertexPreview.cpp
./CMakeLists.txt:	Windows/GEDebugger/CtrlDisplayListView.h
./CMakeLists.txt:	Windows/GEDebugger/SimpleGLWindow.h
./CMakeLists.txt:	Windows/GEDebugger/TabState.h
./CMakeLists.txt:	Windows/GEDebugger/GEDebugger.cpp
./CMakeLists.txt:	Windows/GEDebugger/TabDisplayLists.cpp
./CMakeLists.txt:	Windows/GEDebugger/TabVertices.cpp
./CMakeLists.txt:	Windows/GEDebugger/GEDebugger.h
./CMakeLists.txt:	Windows/GEDebugger/TabDisplayLists.h
./CMakeLists.txt:	Windows/GEDebugger/TabVertices.h
./CMakeLists.txt:	Windows/BufferLock.h
./CMakeLists.txt:	Windows/CaptureDevice.cpp
./CMakeLists.txt:	Windows/CaptureDevice.h
./CMakeLists.txt:	Windows/DinputDevice.cpp
./CMakeLists.txt:	Windows/DinputDevice.h
./CMakeLists.txt:	Windows/HidInputDevice.h
./CMakeLists.txt:	Windows/HidInputDevice.cpp
./CMakeLists.txt:	Windows/EmuThread.cpp
./CMakeLists.txt:	Windows/EmuThread.h
./CMakeLists.txt:	Windows/GPU/D3D11Context.cpp
./CMakeLists.txt:	Windows/GPU/D3D11Context.h
./CMakeLists.txt:	Windows/GPU/WindowsGLContext.cpp
./CMakeLists.txt:	Windows/GPU/WindowsVulkanContext.cpp
./CMakeLists.txt:	Windows/InputBox.cpp
./CMakeLists.txt:	Windows/InputBox.h
./CMakeLists.txt:	Windows/InputDevice.cpp
./CMakeLists.txt:	Windows/InputDevice.h
./CMakeLists.txt:	Windows/W32Util/ContextMenu.h
./CMakeLists.txt:	Windows/W32Util/ContextMenu.h
./CMakeLists.txt:	Windows/W32Util/DialogManager.cpp
./CMakeLists.txt:	Windows/W32Util/DialogManager.h
./CMakeLists.txt:	Windows/W32Util/Misc.cpp
./CMakeLists.txt:	Windows/W32Util/Misc.h
./CMakeLists.txt:	Windows/W32Util/ShellUtil.cpp
./CMakeLists.txt:	Windows/W32Util/ShellUtil.h
./CMakeLists.txt:	Windows/W32Util/TabControl.cpp
./CMakeLists.txt:	Windows/W32Util/TabControl.h
./CMakeLists.txt:	Windows/W32Util/IatHook.h
./CMakeLists.txt:	Windows/W32Util/ContextMenu.h
./CMakeLists.txt:	Windows/W32Util/ContextMenu.cpp
./CMakeLists.txt:	Windows/W32Util/DarkMode.h
./CMakeLists.txt:	Windows/W32Util/DarkMode.cpp
./CMakeLists.txt:	Windows/W32Util/UAHMenuBar.h
./CMakeLists.txt:	Windows/W32Util/UAHMenuBar.cpp
./CMakeLists.txt:	Windows/MainWindow.cpp
./CMakeLists.txt:	Windows/MainWindow.h
./CMakeLists.txt:	Windows/MainWindowMenu.cpp
./CMakeLists.txt:	Windows/MainWindowMenu.h
./CMakeLists.txt:	Windows/RawInput.cpp
./CMakeLists.txt:	Windows/RawInput.h
./CMakeLists.txt:	Windows/TouchInputHandler.cpp
./CMakeLists.txt:	Windows/TouchInputHandler.h
./CMakeLists.txt:	Windows/XinputDevice.cpp
./CMakeLists.txt:	Windows/XinputDevice.h
./CMakeLists.txt:	Windows/main.cpp
./CMakeLists.txt:	Windows/main.h
./CMakeLists.txt:	Windows/ppsspp.rc
./CMakeLists.txt:	Windows/resource.h
./CMakeLists.txt:	Windows/stdafx.cpp
./CMakeLists.txt:	Windows/stdafx.h
./CMakeLists.txt:	#setup_target_project(${TargetBin} Windows)
./CMakeLists.txt:	list(APPEND NativeAppSource ${WindowsFiles})
./CMakeLists.txt:		headless/SDLHeadlessHost.cpp
./CMakeLists.txt:		headless/SDLHeadlessHost.h
./CMakeLists.txt:			headless/WindowsHeadlessHost.cpp
./CMakeLists.txt:			headless/WindowsHeadlessHost.h
./CMakeLists.txt:			Windows/GPU/D3D11Context.cpp
./CMakeLists.txt:			Windows/GPU/D3D11Context.h
./CMakeLists.txt:			Windows/GPU/WindowsGLContext.cpp
./CMakeLists.txt:			Windows/GPU/WindowsVulkanContext.cpp
./CMakeLists.txt:			Windows/W32Util/ShellUtil.cpp
./CMakeLists.txt:			Windows/W32Util/ShellUtil.h
./CMakeLists.txt:			Windows/CaptureDevice.cpp
./CMakeLists.txt:			Windows/CaptureDevice.h
./CMakeLists.txt:			Windows/W32Util/Misc.cpp
./CMakeLists.txt:			Windows/W32Util/Misc.h
./CMakeLists.txt:			Windows/CaptureDevice.cpp
./CMakeLists.txt:			Windows/CaptureDevice.h
./CMakeLists.txt:if(LIBRETRO)
./CMakeLists.txt:	add_subdirectory(libretro)
./CMakeLists.txt:		if(NOT IOS)
./CMakeLists.txt:				set(MACOSX_BUNDLE_ICON_FILE ppsspp_gold.icns)
./CMakeLists.txt:				set(MACOSX_BUNDLE_BUNDLE_NAME "PPSSPP Gold")
./CMakeLists.txt:				set(MACOSX_BUNDLE_GUI_IDENTIFIER org.ppsspp.ppssppgold)
./CMakeLists.txt:				set(MACOSX_BUNDLE_ICON_FILE ppsspp.icns)
./CMakeLists.txt:				set(MACOSX_BUNDLE_BUNDLE_NAME "PPSSPP")
./CMakeLists.txt:				set(MACOSX_BUNDLE_GUI_IDENTIFIER org.ppsspp.ppsspp)
./CMakeLists.txt:			set_source_files_properties(${ICON_PATH_ABS} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources")
./CMakeLists.txt:		if(NOT IOS)
./CMakeLists.txt:			set_source_files_properties(${BigFontAssets} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets")
./CMakeLists.txt:			set_source_files_properties(${NativeAssets} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets")
./CMakeLists.txt:			set_source_files_properties(${UIImages} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/ui_images")
./CMakeLists.txt:			set_source_files_properties(${FLASH0_FILES} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/flash0/font")
./CMakeLists.txt:			set_source_files_properties(${LANG_FILES} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/lang")
./CMakeLists.txt:			set_source_files_properties(${SHADER_FILES} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/shaders")
./CMakeLists.txt:			set_source_files_properties(${THEME_FILE} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/themes")
./CMakeLists.txt:			set_source_files_properties(${DEBUGGER_FILES} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/debugger")
./CMakeLists.txt:			set_source_files_properties(${WEB_UPLOAD_FILES} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/upload")
./CMakeLists.txt:			set_source_files_properties(${VFPU_FILES} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/vfpu")
./CMakeLists.txt:		if(IOS)
./CMakeLists.txt:			set(AssetCatalog "${CMAKE_SOURCE_DIR}/ios/assets.xcassets")
./CMakeLists.txt:			add_executable(${TargetBin} MACOSX_BUNDLE ${NativeAssets} ${BigFontAssets} ${UIImages} ${AssetCatalog} ${SHADER_FILES} ${THEME_FILE} ${DEBUGGER_FILES} ${WEB_UPLOAD_FILES} ${FLASH0_FILES} ${LANG_FILES} ${NativeAppSource} "ios/Settings.bundle" "ios/Launch Screen.storyboard")
./CMakeLists.txt:			if(NOT IOS_APP_STORE)
./CMakeLists.txt:				file(INSTALL "${CMAKE_SOURCE_DIR}/ext/vulkan/iOS/Frameworks/libMoltenVK.dylib" DESTINATION "${CMAKE_BINARY_DIR}/PPSSPP.app/Frameworks/")
./CMakeLists.txt:			add_executable(${TargetBin} MACOSX_BUNDLE ${ICON_PATH_ABS} ${NativeAssets} ${BigFontAssets} ${UIImages} ${SHADER_FILES} ${THEME_FILE} ${DEBUGGER_FILES} ${WEB_UPLOAD_FILES} ${FLASH0_FILES} ${LANG_FILES} ${NativeAppSource})
./CMakeLists.txt:			file(INSTALL "${CMAKE_SOURCE_DIR}/ext/vulkan/macOS/Frameworks/libMoltenVK.dylib" DESTINATION "${CMAKE_BINARY_DIR}/${TargetBin}.app/Contents/Frameworks/")
./CMakeLists.txt:			if(USING_QT_UI)
./CMakeLists.txt:				add_custom_command(TARGET ${TargetBin} POST_BUILD COMMAND /bin/bash "${CMAKE_SOURCE_DIR}/Qt/macbundle.sh" "${CMAKE_BINARY_DIR}/PPSSPPQt.app")
./CMakeLists.txt:			elseif(NOT USE_SYSTEM_LIBSDL2)
./CMakeLists.txt:				add_custom_command(TARGET ${TargetBin} POST_BUILD COMMAND /bin/bash "${CMAKE_SOURCE_DIR}/SDL/macbundle.sh" "${CMAKE_BINARY_DIR}/${TargetBin}.app" "${TargetBin}")
./CMakeLists.txt:if(IOS AND NOT LIBRETRO)
./CMakeLists.txt:	if(IOS_APP_STORE)
./CMakeLists.txt:	file(GLOB IOSAssets ios/assets/*.png)
./CMakeLists.txt:	list(REMOVE_ITEM IOSAssets ${CMAKE_CURRENT_SOURCE_DIR}/ios/assets/Default-568h@2x.png)
./CMakeLists.txt:	list(REMOVE_ITEM IOSAssets ${CMAKE_CURRENT_SOURCE_DIR}/ios/assets/Default-568h@3x.png)
./CMakeLists.txt:	file(INSTALL ${IOSAssets} DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/assets)
./CMakeLists.txt:	file(GLOB IOSAssets ios/assets/Default-568h@*.png)
./CMakeLists.txt:	file(INSTALL ${IOSAssets} DESTINATION ${CMAKE_CURRENT_BINARY_DIR})
./CMakeLists.txt:	if(IOS_DEBUG)
./CMakeLists.txt:	set(RSRC_XIB_FILES "Launch Screen.storyboard" ${CMAKE_CURRENT_SOURCE_DIR}/ios/assets.xcassets)
./CMakeLists.txt:		PROPERTIES MACOSX_PACKAGE_LOCATION Resources
./CMakeLists.txt:	set(MACOSX_DEPLOYMENT_TARGET ${DEPLOYMENT_TARGET})
./CMakeLists.txt:	set(BUNDLE_PLIST "${CMAKE_CURRENT_SOURCE_DIR}/ios/PPSSPP-Info.plist")
./CMakeLists.txt:	set(BUNDLE_ENTITLEMENTS "${CMAKE_CURRENT_SOURCE_DIR}/ios/App.entitlements")
./CMakeLists.txt:		if(IOS_APP_STORE)
./CMakeLists.txt:		if(IOS_APP_STORE)
./CMakeLists.txt:	if(IOS_APP_STORE)
./CMakeLists.txt:			COMMAND /bin/bash "${CMAKE_SOURCE_DIR}/ios/iosbundle.sh" \"${APP_DIR_NAME}\" "${CMAKE_CURRENT_BINARY_DIR}"
./CMakeLists.txt:			"${CMAKE_CURRENT_SOURCE_DIR}/ios/MoltenVK/MoltenVK.xcframework/ios-arm64/libMoltenVK.a"
./CMakeLists.txt:		# https://stackoverflow.com/questions/40664125/cmake-and-code-signing-in-xcode-8-for-ios-projects
./CMakeLists.txt:			RESOURCE "ios/Launch Screen.storyboard"
./CMakeLists.txt:			RESOURCE "ios/Settings.bundle"
./CMakeLists.txt:			RESOURCE "ios/assets.xcassets"
./CMakeLists.txt:			MACOSX_BUNDLE_INFO_PLIST ${BUNDLE_PLIST}
./CMakeLists.txt:			COMMAND /bin/bash "${CMAKE_SOURCE_DIR}/ios/macbundle.sh" \"${APP_DIR_NAME}\"
./CMakeLists.txt:			MACOSX_BUNDLE_INFO_PLIST ${BUNDLE_PLIST}
./CMakeLists.txt:			RESOURCE "ios/Launch Screen.storyboard"
./CMakeLists.txt:			RESOURCE "ios/Settings.bundle"
./CMakeLists.txt:			RESOURCE "ext/vulkan/iOS/Frameworks"
./CMakeLists.txt:if(MACOSX AND NOT IOS)
./CMakeLists.txt:			MACOSX_BUNDLE_INFO_PLIST "${CMAKE_CURRENT_SOURCE_DIR}/macOS/InfoGold.plist"
./CMakeLists.txt:			MACOSX_BUNDLE_INFO_PLIST "${CMAKE_CURRENT_SOURCE_DIR}/macOS/Info.plist"
./Common/ABI.cpp:// Mac OS X requires the stack to be 16-byte aligned before every call.
./Common/ABI.cpp:// Linux requires the stack to be 16-byte aligned before calls that put SSE
./Common/ABI.cpp:// Windows binaries compiled with MSVC do not have such a restriction*, but I
./Common/ABI.cpp:// expect that GCC on Windows acts the same as GCC on Linux in this respect.
./Common/ABI.cpp:// The Windows x64 ABI requires XMM6 - XMM15 to be callee saved.  10 regs.
./Common/ABI.h:// Linux 32-bit, Windows 32-bit (cdecl, System V):
./Common/ABI.h:// Windows 64-bit
./Common/ABI.h:// Linux 64-bit
./Common/ABI.h:// 32-bit bog standard cdecl, shared between linux and windows
./Common/ABI.h:// MacOSX 32-bit is same as System V with a few exceptions that we probably don't care much about.
./Common/ABI.h:#ifdef _WIN32 // 64-bit Windows - the really exotic calling convention 
./Common/ABI.h:#else  //64-bit Unix (hopefully MacOSX too) 
./Common/Arm64Emitter.cpp:#include "Common/CommonWindows.h"
./Common/Arm64Emitter.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./Common/Arm64Emitter.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./Common/Arm64Emitter.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./Common/ArmCPUDetect.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./Common/ArmCPUDetect.cpp:#if defined(CPU_FEATURES_OS_LINUX)
./Common/ArmCPUDetect.cpp:#if defined(CPU_FEATURES_OS_LINUX) || defined(CPU_FEATURES_OS_ANDROID) || defined(CPU_FEATURES_OS_WINDOWS)
./Common/ArmCPUDetect.cpp:#if PPSSPP_PLATFORM(WINDOWS) 
./Common/ArmCPUDetect.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/ArmCPUDetect.cpp:#include "Common/CommonWindows.h"
./Common/ArmCPUDetect.cpp:	LSTATUS result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0", 0, KEY_READ, &key);
./Common/ArmCPUDetect.cpp:// Only Linux platforms have /proc/cpuinfo
./Common/ArmCPUDetect.cpp:#if PPSSPP_PLATFORM(LINUX)
./Common/ArmCPUDetect.cpp:#if !PPSSPP_PLATFORM(LINUX)
./Common/ArmCPUDetect.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./Common/ArmCPUDetect.cpp:#if PPSSPP_PLATFORM(IOS)
./Common/ArmCPUDetect.cpp:#endif // PPSSPP_PLATFORM(IOS)
./Common/ArmCPUDetect.cpp:	if (sysctlbyname("machdep.cpu.brand_string", brand_string, &sz, nullptr, 0) != 0) {
./Common/ArmCPUDetect.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./Common/ArmCPUDetect.cpp:#else // !PPSSPP_PLATFORM(IOS) && !PPSSPP_PLATFORM(MAC) && !PPSSPP_PLATFORM(WINDOWS)
./Common/ArmCPUDetect.cpp:#else // PPSSPP_PLATFORM(LINUX)
./Common/ArmEmitter.cpp:#if PPSSPP_PLATFORM(IOS)
./Common/ArmEmitter.cpp:#include "CommonWindows.h"
./Common/ArmEmitter.cpp:#if PPSSPP_PLATFORM(IOS)
./Common/ArmEmitter.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./Common/ArmEmitter.h:// Everything that needs to generate machine code should inherit from this.
./Common/Battery/AppleBatteryClient.m:#if PPSSPP_PLATFORM(MAC)
./Common/Battery/AppleBatteryClient.m:#elif PPSSPP_PLATFORM(IOS)
./Common/Battery/AppleBatteryClient.m:#if TARGET_OS_IOS
./Common/Battery/AppleBatteryClient.m:    // on iOS, this needs to be true to get the battery level
./Common/Battery/AppleBatteryClient.m:#elif TARGET_OS_MAC
./Common/Battery/AppleBatteryClient.m:#if TARGET_OS_IOS
./Common/Battery/AppleBatteryClient.m:#elif TARGET_OS_MAC
./Common/BitScan.h:#if PPSSPP_PLATFORM(WINDOWS)
./Common/BitScan.h:#include "Common/CommonWindows.h"
./Common/CPUDetect.cpp:#if defined(CPU_FEATURES_OS_FREEBSD) || defined(CPU_FEATURES_OS_LINUX) || defined(CPU_FEATURES_OS_ANDROID) || defined(CPU_FEATURES_OS_MACOS) || defined(CPU_FEATURES_OS_WINDOWS)
./Common/CPUDetect.cpp:#elif PPSSPP_PLATFORM(MAC)
./Common/CPUDetect.cpp:#include "Common/CommonWindows.h"
./Common/CPUDetect.cpp:#if PPSSPP_PLATFORM(LINUX)
./Common/CPUDetect.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/CPUDetect.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/CPUDetect.cpp:#if !PPSSPP_PLATFORM(UWP)
./Common/CPUDetect.cpp:#if !PPSSPP_PLATFORM(UWP)
./Common/CPUDetect.cpp:#elif PPSSPP_PLATFORM(LINUX)
./Common/CPUDetect.cpp:#elif PPSSPP_PLATFORM(MAC)
./Common/Common.h:// DO NOT EVER INCLUDE <windows.h> directly _or indirectly_ from this file
./Common/Common.h:// Windows compatibility
./Common/Common.vcxproj:    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
./Common/Common.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./Common/Common.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./Common/Common.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./Common/Common.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./Common/Common.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./Common/Common.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./Common/Common.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./Common/Common.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./Common/Common.vcxproj:  <PropertyGroup Label="UserMacros" />
./Common/Common.vcxproj:      <SubSystem>Windows</SubSystem>
./Common/Common.vcxproj:      <SubSystem>Windows</SubSystem>
./Common/Common.vcxproj:      <SubSystem>Windows</SubSystem>
./Common/Common.vcxproj:      <SubSystem>Windows</SubSystem>
./Common/Common.vcxproj:      <SubSystem>Windows</SubSystem>
./Common/Common.vcxproj:      <SubSystem>Windows</SubSystem>
./Common/Common.vcxproj:    <ClInclude Include="Render\Text\draw_text_qt.h" />
./Common/Common.vcxproj:    <ClInclude Include="Render\Text\draw_text_sdl.h" />
./Common/Common.vcxproj:    <ClInclude Include="Render\Text\draw_text_uwp.h" />
./Common/Common.vcxproj:    <ClInclude Include="CommonWindows.h" />
./Common/Common.vcxproj:    <ClInclude Include="MachineContext.h" />
./Common/Common.vcxproj:    <ClCompile Include="Render\Text\draw_text_qt.cpp" />
./Common/Common.vcxproj:    <ClCompile Include="Render\Text\draw_text_sdl.cpp" />
./Common/Common.vcxproj:    <ClCompile Include="Render\Text\draw_text_uwp.cpp" />
./Common/Common.vcxproj.filters:    <ClInclude Include="CommonWindows.h" />
./Common/Common.vcxproj.filters:    <ClInclude Include="MachineContext.h" />
./Common/Common.vcxproj.filters:    <ClInclude Include="Render\Text\draw_text_qt.h">
./Common/Common.vcxproj.filters:    <ClInclude Include="Render\Text\draw_text_uwp.h">
./Common/Common.vcxproj.filters:    <ClInclude Include="Render\Text\draw_text_sdl.h">
./Common/Common.vcxproj.filters:    <ClCompile Include="Render\Text\draw_text_qt.cpp">
./Common/Common.vcxproj.filters:    <ClCompile Include="Render\Text\draw_text_uwp.cpp">
./Common/Common.vcxproj.filters:    <ClCompile Include="Render\Text\draw_text_sdl.cpp">
./Common/CommonFuncs.h:// 64 bit offsets for windows
./Common/CommonWindows.h:#include <Windows.h>
./Common/Crypto/md5.cpp: * 32-bit integer manipulation macros (little endian)
./Common/Crypto/md5.cpp: * MD5 HMAC context setup
./Common/Crypto/md5.cpp:void ppsspp_md5_hmac_starts( md5_context *ctx, unsigned char *key, int keylen )
./Common/Crypto/md5.cpp: * MD5 HMAC process buffer
./Common/Crypto/md5.cpp:void ppsspp_md5_hmac_update( md5_context *ctx, unsigned char *input, int ilen )
./Common/Crypto/md5.cpp: * MD5 HMAC final digest
./Common/Crypto/md5.cpp:void ppsspp_md5_hmac_finish( md5_context *ctx, unsigned char output[16] )
./Common/Crypto/md5.cpp: * output = HMAC-MD5( hmac key, input buffer )
./Common/Crypto/md5.cpp:void ppsspp_md5_hmac( unsigned char *key, int keylen, unsigned char *input, int ilen,
./Common/Crypto/md5.cpp:    ppsspp_md5_hmac_starts( &ctx, key, keylen );
./Common/Crypto/md5.cpp:    ppsspp_md5_hmac_update( &ctx, input, ilen );
./Common/Crypto/md5.cpp:    ppsspp_md5_hmac_finish( &ctx, output );
./Common/Crypto/md5.cpp:static unsigned char md5_hmac_test_key[7][26] =
./Common/Crypto/md5.cpp:static const int md5_hmac_test_keylen[7] =
./Common/Crypto/md5.cpp:static unsigned char md5_hmac_test_buf[7][74] =
./Common/Crypto/md5.cpp:static const int md5_hmac_test_buflen[7] =
./Common/Crypto/md5.cpp:static const unsigned char md5_hmac_test_sum[7][16] =
./Common/Crypto/md5.cpp:            printf( "  HMAC-MD5 test #%d: ", i + 1 );
./Common/Crypto/md5.cpp:            md5_hmac_starts( &ctx, buf, buflen );
./Common/Crypto/md5.cpp:            md5_hmac_starts( &ctx, md5_hmac_test_key[i],
./Common/Crypto/md5.cpp:                                   md5_hmac_test_keylen[i] );
./Common/Crypto/md5.cpp:        md5_hmac_update( &ctx, md5_hmac_test_buf[i],
./Common/Crypto/md5.cpp:                               md5_hmac_test_buflen[i] );
./Common/Crypto/md5.cpp:        md5_hmac_finish( &ctx, md5sum );
./Common/Crypto/md5.cpp:        if( memcmp( md5sum, md5_hmac_test_sum[i], buflen ) != 0 )
./Common/Crypto/md5.h:    unsigned char ipad[64];     /*!< HMAC: inner padding        */
./Common/Crypto/md5.h:    unsigned char opad[64];     /*!< HMAC: outer padding        */
./Common/Crypto/md5.h: * \brief          MD5 HMAC context setup
./Common/Crypto/md5.h: * \param ctx      HMAC context to be initialized
./Common/Crypto/md5.h: * \param key      HMAC secret key
./Common/Crypto/md5.h: * \param keylen   length of the HMAC key
./Common/Crypto/md5.h:void ppsspp_md5_hmac_starts( md5_context *ctx, unsigned char *key, int keylen );
./Common/Crypto/md5.h: * \brief          MD5 HMAC process buffer
./Common/Crypto/md5.h: * \param ctx      HMAC context
./Common/Crypto/md5.h:void ppsspp_md5_hmac_update( md5_context *ctx, unsigned char *input, int ilen );
./Common/Crypto/md5.h: * \brief          MD5 HMAC final digest
./Common/Crypto/md5.h: * \param ctx      HMAC context
./Common/Crypto/md5.h: * \param output   MD5 HMAC checksum result
./Common/Crypto/md5.h:void ppsspp_md5_hmac_finish( md5_context *ctx, unsigned char output[16] );
./Common/Crypto/md5.h: * \brief          Output = HMAC-MD5( hmac key, input buffer )
./Common/Crypto/md5.h: * \param key      HMAC secret key
./Common/Crypto/md5.h: * \param keylen   length of the HMAC key
./Common/Crypto/md5.h: * \param output   HMAC-MD5 result
./Common/Crypto/md5.h:void ppsspp_md5_hmac( unsigned char *key, int keylen,
./Common/Crypto/sha1.cpp: * 32-bit integer manipulation macros (big endian)
./Common/Crypto/sha1.cpp: * SHA-1 HMAC context setup
./Common/Crypto/sha1.cpp:void sha1_hmac_starts( sha1_context *ctx, unsigned char *key, int keylen )
./Common/Crypto/sha1.cpp: * SHA-1 HMAC process buffer
./Common/Crypto/sha1.cpp:void sha1_hmac_update( sha1_context *ctx, unsigned char *input, int ilen )
./Common/Crypto/sha1.cpp: * SHA-1 HMAC final digest
./Common/Crypto/sha1.cpp:void sha1_hmac_finish( sha1_context *ctx, unsigned char output[20] )
./Common/Crypto/sha1.cpp: * output = HMAC-SHA-1( hmac key, input buffer )
./Common/Crypto/sha1.cpp:void sha1_hmac( unsigned char *key, int keylen,
./Common/Crypto/sha1.cpp:    sha1_hmac_starts( &ctx, key, keylen );
./Common/Crypto/sha1.cpp:    sha1_hmac_update( &ctx, input, ilen );
./Common/Crypto/sha1.cpp:    sha1_hmac_finish( &ctx, output );
./Common/Crypto/sha1.cpp:static unsigned char sha1_hmac_test_key[7][26] =
./Common/Crypto/sha1.cpp:static const int sha1_hmac_test_keylen[7] =
./Common/Crypto/sha1.cpp:static unsigned char sha1_hmac_test_buf[7][74] =
./Common/Crypto/sha1.cpp:static const int sha1_hmac_test_buflen[7] =
./Common/Crypto/sha1.cpp:static const unsigned char sha1_hmac_test_sum[7][20] =
./Common/Crypto/sha1.cpp:            printf( "  HMAC-SHA-1 test #%d: ", i + 1 );
./Common/Crypto/sha1.cpp:            sha1_hmac_starts( &ctx, buf, buflen );
./Common/Crypto/sha1.cpp:            sha1_hmac_starts( &ctx, sha1_hmac_test_key[i],
./Common/Crypto/sha1.cpp:                                    sha1_hmac_test_keylen[i] );
./Common/Crypto/sha1.cpp:        sha1_hmac_update( &ctx, sha1_hmac_test_buf[i],
./Common/Crypto/sha1.cpp:                                sha1_hmac_test_buflen[i] );
./Common/Crypto/sha1.cpp:        sha1_hmac_finish( &ctx, sha1sum );
./Common/Crypto/sha1.cpp:        if( memcmp( sha1sum, sha1_hmac_test_sum[i], buflen ) != 0 )
./Common/Crypto/sha1.h:    unsigned char ipad[64];     /*!< HMAC: inner padding        */
./Common/Crypto/sha1.h:    unsigned char opad[64];     /*!< HMAC: outer padding        */
./Common/Crypto/sha1.h: * \brief          SHA-1 HMAC context setup
./Common/Crypto/sha1.h: * \param ctx      HMAC context to be initialized
./Common/Crypto/sha1.h: * \param key      HMAC secret key
./Common/Crypto/sha1.h: * \param keylen   length of the HMAC key
./Common/Crypto/sha1.h:void sha1_hmac_starts( sha1_context *ctx, unsigned char *key, int keylen );
./Common/Crypto/sha1.h: * \brief          SHA-1 HMAC process buffer
./Common/Crypto/sha1.h: * \param ctx      HMAC context
./Common/Crypto/sha1.h:void sha1_hmac_update( sha1_context *ctx, unsigned char *input, int ilen );
./Common/Crypto/sha1.h: * \brief          SHA-1 HMAC final digest
./Common/Crypto/sha1.h: * \param ctx      HMAC context
./Common/Crypto/sha1.h: * \param output   SHA-1 HMAC checksum result
./Common/Crypto/sha1.h:void sha1_hmac_finish( sha1_context *ctx, unsigned char output[20] );
./Common/Crypto/sha1.h: * \brief          Output = HMAC-SHA-1( hmac key, input buffer )
./Common/Crypto/sha1.h: * \param key      HMAC secret key
./Common/Crypto/sha1.h: * \param keylen   length of the HMAC key
./Common/Crypto/sha1.h: * \param output   HMAC-SHA-1 result
./Common/Crypto/sha1.h:void sha1_hmac( unsigned char *key, int keylen,
./Common/Data/Encoding/Utf8.cpp:#include <windows.h>
./Common/Data/Format/IniFile.cpp:#include <iostream>
./Common/Data/Format/ZIMLoad.cpp:	/* Check for source > 64K on 16-bit machine: */
./Common/Data/Format/ZIMSave.cpp:	/* Check for source > 64K on 16-bit machine: */
./Common/Data/Text/Parsers.cpp:bool ParseMacAddress(const std::string &str, uint8_t macAddr[6]) {
./Common/Data/Text/Parsers.cpp:	unsigned int mac[6];
./Common/Data/Text/Parsers.cpp:	if (6 != sscanf(str.c_str(), "%02x:%02x:%02x:%02x:%02x:%02x", &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5])) {
./Common/Data/Text/Parsers.cpp:		macAddr[i] = mac[i];
./Common/Data/Text/Parsers.h:bool ParseMacAddress(const std::string &str, uint8_t macAddr[6]);
./Common/ExceptionHandlerSetup.cpp:#include "Common/MachineContext.h"
./Common/ExceptionHandlerSetup.cpp:#ifdef MACHINE_CONTEXT_SUPPORTED
./Common/ExceptionHandlerSetup.cpp:// We cannot handle exceptions in UWP builds. Bleh.
./Common/ExceptionHandlerSetup.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./Common/ExceptionHandlerSetup.cpp:static void ExceptionThread(mach_port_t port) {
./Common/ExceptionHandlerSetup.cpp:	SetCurrentThreadName("Mach exception thread");
./Common/ExceptionHandlerSetup.cpp:		mach_msg_header_t Head;
./Common/ExceptionHandlerSetup.cpp:		mach_msg_type_number_t codeCnt;
./Common/ExceptionHandlerSetup.cpp:		mach_msg_type_number_t old_stateCnt;
./Common/ExceptionHandlerSetup.cpp:		mach_msg_trailer_t trailer;
./Common/ExceptionHandlerSetup.cpp:		mach_msg_header_t Head;
./Common/ExceptionHandlerSetup.cpp:		mach_msg_type_number_t new_stateCnt;
./Common/ExceptionHandlerSetup.cpp:	mach_msg_header_t* send_msg = &msg_out.Head;
./Common/ExceptionHandlerSetup.cpp:	mach_msg_size_t send_size = 0;
./Common/ExceptionHandlerSetup.cpp:	mach_msg_option_t option = MACH_RCV_MSG;
./Common/ExceptionHandlerSetup.cpp:		// a message: either a mach_exception_raise_state RPC due to
./Common/ExceptionHandlerSetup.cpp:		// thread_set_exception_ports, or MACH_NOTIFY_NO_SENDERS due to
./Common/ExceptionHandlerSetup.cpp:		// mach_port_request_notification.
./Common/ExceptionHandlerSetup.cpp:		CheckKR("mach_msg_overwrite",
./Common/ExceptionHandlerSetup.cpp:			mach_msg_overwrite(send_msg, option, send_size, sizeof(msg_in), port,
./Common/ExceptionHandlerSetup.cpp:				MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL, &msg_in.Head, 0));
./Common/ExceptionHandlerSetup.cpp:		if (msg_in.Head.msgh_id == MACH_NOTIFY_NO_SENDERS) {
./Common/ExceptionHandlerSetup.cpp:			mach_port_destroy(mach_task_self(), port);
./Common/ExceptionHandlerSetup.cpp:		msg_out.Head.msgh_bits = MACH_MSGH_BITS(MACH_MSGH_BITS_REMOTE(msg_in.Head.msgh_bits), 0);
./Common/ExceptionHandlerSetup.cpp:		msg_out.Head.msgh_local_port = MACH_PORT_NULL;
./Common/ExceptionHandlerSetup.cpp:		option |= MACH_SEND_MSG;
./Common/ExceptionHandlerSetup.cpp:	mach_port_t port;
./Common/ExceptionHandlerSetup.cpp:	CheckKR("mach_port_allocate",
./Common/ExceptionHandlerSetup.cpp:		mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port));
./Common/ExceptionHandlerSetup.cpp:	CheckKR("mach_port_insert_right",
./Common/ExceptionHandlerSetup.cpp:		mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND));
./Common/ExceptionHandlerSetup.cpp:	// Mach tries the following exception ports in order: thread, task, host.
./Common/ExceptionHandlerSetup.cpp:		thread_set_exception_ports(mach_thread_self(), EXC_MASK_BAD_ACCESS, port,
./Common/ExceptionHandlerSetup.cpp:			EXCEPTION_STATE | MACH_EXCEPTION_CODES, x86_THREAD_STATE64));
./Common/ExceptionHandlerSetup.cpp:	// ...and get rid of our copy so that MACH_NOTIFY_NO_SENDERS works.
./Common/ExceptionHandlerSetup.cpp:	CheckKR("mach_port_mod_refs",
./Common/ExceptionHandlerSetup.cpp:		mach_port_mod_refs(mach_task_self(), port, MACH_PORT_RIGHT_SEND, -1));
./Common/ExceptionHandlerSetup.cpp:	mach_port_t previous;
./Common/ExceptionHandlerSetup.cpp:	CheckKR("mach_port_request_notification",
./Common/ExceptionHandlerSetup.cpp:		mach_port_request_notification(mach_task_self(), port, MACH_NOTIFY_NO_SENDERS, 0, port,
./Common/ExceptionHandlerSetup.cpp:			MACH_MSG_TYPE_MAKE_SEND_ONCE, &previous));
./Common/ExceptionHandlerSetup.cpp:#else  // !MACHINE_CONTEXT_SUPPORTED
./Common/ExceptionHandlerSetup.cpp:#endif  // MACHINE_CONTEXT_SUPPORTED
./Common/ExceptionHandlerSetup.h:// On Windows, context is a CONTEXT object.
./Common/ExceptionHandlerSetup.h:// On Unix/Linux, context is a mcontext_t.
./Common/FakeEmitter.h:// Everything that needs to generate machine code should inherit from this.
./Common/File/AndroidStorage.cpp:#if PPSSPP_PLATFORM(ANDROID) && !defined(__LIBRETRO__)
./Common/File/AndroidStorage.h:#if PPSSPP_PLATFORM(ANDROID) && !defined(__LIBRETRO__)
./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/DirListing.cpp:#include "Common/CommonWindows.h"
./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/DirListing.cpp:#include <UWP/UWPHelpers/StorageManager.h>
./Common/File/DirListing.cpp:#if !defined(__linux__) && !defined(_WIN32) && !defined(__QNX__)
./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/DirListing.cpp:	const int windowsTickResolution = 10000000;
./Common/File/DirListing.cpp:	return (int64_t)(ticks / windowsTickResolution - secToUnixEpoch);
./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/DirListing.cpp:		std::vector<std::string> drives = File::GetWindowsDrives();
./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/DirListing.cpp:std::vector<std::string> GetWindowsDrives() {
./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/DirListing.cpp:#endif  // PPSSPP_PLATFORM(UWP)
./Common/File/DirListing.cpp:#endif  // PPSSPP_PLATFORM(WINDOWS)
./Common/File/DirListing.h:std::vector<std::string> GetWindowsDrives();
./Common/File/DiskFree.cpp:#include "Common/CommonWindows.h"
./Common/File/DiskFree.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/DiskFree.cpp:#include "UWP/UWPHelpers/StorageManager.h"
./Common/File/DiskFree.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/FileDescriptor.cpp:		// Windows XP doesn't support inet_ntop.
./Common/File/FileUtil.cpp:#include "Common/CommonWindows.h"
./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/FileUtil.cpp:#include "UWP/UWPHelpers/StorageManager.h"
./Common/File/FileUtil.cpp:#if !PPSSPP_PLATFORM(IOS)
./Common/File/FileUtil.cpp:#include <mach-o/dyld.h>
./Common/File/FileUtil.cpp:#endif  // !PPSSPP_PLATFORM(IOS)
./Common/File/FileUtil.cpp:#if !defined(__linux__) && !defined(_WIN32) && !defined(__QNX__)
./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./Common/File/FileUtil.cpp:	// FileSystem (broadFileSystemAccess) doesn't apply on _wfopen
./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/FileUtil.cpp:#elif PPSSPP_PLATFORM(IOS)
./Common/File/FileUtil.cpp:	// Make sure Windows will no longer handle critical errors, which means no annoying "No disk" dialog
./Common/File/FileUtil.cpp:#if !PPSSPP_PLATFORM(UWP)
./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/FileUtil.cpp:#if !PPSSPP_PLATFORM(UWP)
./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/File/FileUtil.cpp:#elif (defined(__APPLE__) && !PPSSPP_PLATFORM(IOS)) || defined(__linux__) || defined(KERN_PROC_PATHNAME)
./Common/File/FileUtil.cpp:#if defined(__linux__)
./Common/File/FileUtil.cpp:#elif defined(__APPLE__) && !PPSSPP_PLATFORM(IOS)
./Common/File/FileUtil.h:// Mostly to handle UTF-8 filenames better on Windows.
./Common/File/Path.cpp:#if PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./Common/File/Path.cpp:#include "UWP/UWPHelpers/StorageManager.h"
./Common/File/Path.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/Path.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/Path.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/Path.cpp:		// Windows fake-root.
./Common/File/Path.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/Path.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/Path.cpp:#if PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./Common/File/Path.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/Path.cpp:		// Windows path with drive letter
./Common/File/Path.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/Path.cpp:		return true; // Windows path with drive letter
./Common/File/Path.cpp:	// We don't support case-insensitive file systems on Windows.
./Common/File/Path.h:// Mac OSX case sensitivity defaults off, but is user configurable (when
./Common/File/Path.h:#else  // Android, Linux, BSD (and the rest?)
./Common/File/Path.h:// Windows paths are always stored with '/' slashes in a Path.
./Common/File/Path.h:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/Path.h:#if PPSSPP_PLATFORM(WINDOWS)
./Common/File/Path.h:	std::string ToCString() const;  // Flips the slashes back to Windows standard, but string still UTF-8.
./Common/File/Path.h:	// Not actually always the root of the volume, especially on systems like Mac and Linux where things are often mounted.
./Common/File/PathBrowser.h:// "/" is a special path that means the root of the file system. On Windows,
./Common/File/VFS/VFS.cpp:	bool isWindowsLocal = (isalpha(path[0]) && path[1] == ':') || startsWith(path, "\\\\") || startsWith(path, "//");
./Common/File/VFS/VFS.cpp:	bool isWindowsLocal = false;
./Common/File/VFS/VFS.cpp:	return isUnixLocal || isWindowsLocal || isContentURI;
./Common/GPU/D3D11/D3D11Loader.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/GPU/D3D11/D3D11Loader.cpp:#error This file should not be compiled for UWP.
./Common/GPU/D3D11/D3D11Loader.h:// Standard Windows includes
./Common/GPU/D3D11/D3D11Loader.h:#include "Common/CommonWindows.h"
./Common/GPU/D3D11/D3D11Loader.h:#if PPSSPP_PLATFORM(UWP)
./Common/GPU/D3D11/D3D11Loader.h:#error This file should not be compiled for UWP.
./Common/GPU/D3D11/thin3d_d3d11.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/GPU/D3D11/thin3d_d3d11.cpp:#ifndef __LIBRETRO__  // their build server uses an old SDK
./Common/GPU/D3D11/thin3d_d3d11.cpp:// https://tedwvc.wordpress.com/2014/01/01/how-to-target-xp-with-vc2012-or-vc2013-and-continue-to-use-the-windows-8-x-sdk/
./Common/GPU/D3D11/thin3d_d3d11.cpp:#ifndef __LIBRETRO__
./Common/GPU/D3D11/thin3d_d3d11.cpp:	// We no longer support Windows Phone.
./Common/GPU/D3D11/thin3d_d3d11.cpp:			// TODO: There are Windows ARM devices that could have Qualcomm here too.
./Common/GPU/D3D11/thin3d_d3d11.cpp:#ifndef __LIBRETRO__  // their build server uses an old SDK
./Common/GPU/D3D11/thin3d_d3d11.cpp:	// Safety for libretro
./Common/GPU/D3D11/thin3d_d3d11.cpp:#ifndef __LIBRETRO__  // their build server uses an old SDK
./Common/GPU/D3D11/thin3d_d3d11.cpp:	// TODO: deviceContext1 can actually discard. Useful on Windows Mobile.
./Common/GPU/OpenGL/GLCommon.h:#if PPSSPP_PLATFORM(IOS)
./Common/GPU/OpenGL/GLCommon.h:#if PPSSPP_PLATFORM(IOS)
./Common/GPU/OpenGL/GLFeatures.cpp:#if !PPSSPP_PLATFORM(IOS)
./Common/GPU/OpenGL/GLFeatures.cpp:#if defined(WIN32) && !defined(__LIBRETRO__)
./Common/GPU/OpenGL/GLFeatures.cpp:		// https://twitter.com/ID_AA_Carmack/status/387383037794603008
./Common/GPU/OpenGL/GLFeatures.cpp:		// Hm, this should be available on iOS too.
./Common/GPU/OpenGL/GLFeatures.cpp:#elif defined(USING_GLES2) && defined(__linux__)
./Common/GPU/OpenGL/GLMemory.cpp:#if !PPSSPP_PLATFORM(IOS)
./Common/GPU/OpenGL/GLQueueRunner.cpp:#if PPSSPP_PLATFORM(IOS)
./Common/GPU/OpenGL/GLQueueRunner.cpp:#elif !PPSSPP_PLATFORM(IOS)
./Common/GPU/OpenGL/GLQueueRunner.cpp:#if !PPSSPP_PLATFORM(IOS)
./Common/GPU/OpenGL/GLQueueRunner.cpp:#if PPSSPP_PLATFORM(IOS) && !defined(__LIBRETRO__)
./Common/GPU/OpenGL/GLRenderManager.cpp:	// PowerVR GX6xxx / iOS 10.3 - mapping has little improvement, explicit flush is slower.
./Common/GPU/OpenGL/GLRenderManager.h:	void StartThread();  // Currently only used on iOS, since we fully recreate the context on Android
./Common/GPU/OpenGL/gl3stub.c:#if !PPSSPP_PLATFORM(IOS)
./Common/GPU/OpenGL/gl3stub.c:#endif // PPSPP_PLATFORM(IOS)
./Common/GPU/OpenGL/gl3stub.h:#if !PPSSPP_PLATFORM(IOS)
./Common/GPU/OpenGL/gl3stub.h:#endif   // PPSSPP_PLATFORM(IOS)
./Common/GPU/OpenGL/thin3d_gl.cpp:static const unsigned short blendEqToGL[] = {
./Common/GPU/OpenGL/thin3d_gl.cpp:#elif !PPSSPP_PLATFORM(IOS)
./Common/GPU/OpenGL/thin3d_gl.cpp:#if PPSSPP_PLATFORM(IOS)
./Common/GPU/OpenGL/thin3d_gl.cpp:				// Older macOS devices seem to have problems defining uint uniforms.
./Common/GPU/OpenGL/thin3d_gl.cpp:	bs->eqCol = blendEqToGL[(int)desc.eqCol];
./Common/GPU/OpenGL/thin3d_gl.cpp:	bs->eqAlpha = blendEqToGL[(int)desc.eqAlpha];
./Common/GPU/ShaderTranslation.cpp:#if PPSSPP_PLATFORM(WINDOWS) && PPSSPP_ARCH(ARM)
./Common/GPU/ShaderTranslation.cpp:		// macOS OpenGL 4.1 implementation does not support GL_ARB_shading_language_420pack.
./Common/GPU/Vulkan/VulkanContext.cpp:#define __STDC_LIMIT_MACROS
./Common/GPU/Vulkan/VulkanContext.cpp:#include <iostream>
./Common/GPU/Vulkan/VulkanContext.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/GPU/Vulkan/VulkanContext.cpp:#if !PPSSPP_PLATFORM(UWP)
./Common/GPU/Vulkan/VulkanContext.cpp:		// Windows uses _putenv_s
./Common/GPU/Vulkan/VulkanContext.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./Common/GPU/Vulkan/VulkanContext.cpp:#if !PPSSPP_PLATFORM(MAC) && !PPSSPP_PLATFORM(IOS)
./Common/GPU/Vulkan/VulkanContext.cpp:	VkResult result = vmaCreateAllocator(&allocatorInfo, &allocator_);
./Common/GPU/Vulkan/VulkanContext.cpp:VkResult VulkanContext::InitSurface(WindowSystem winsys, void *data1, void *data2) {
./Common/GPU/Vulkan/VulkanContext.cpp:	case WINDOWSYSTEM_WIN32:
./Common/GPU/Vulkan/VulkanContext.cpp:	case WINDOWSYSTEM_ANDROID:
./Common/GPU/Vulkan/VulkanContext.cpp:	case WINDOWSYSTEM_METAL_EXT:
./Common/GPU/Vulkan/VulkanContext.cpp:	case WINDOWSYSTEM_XLIB:
./Common/GPU/Vulkan/VulkanContext.cpp:	case WINDOWSYSTEM_XCB:
./Common/GPU/Vulkan/VulkanContext.cpp:	case WINDOWSYSTEM_WAYLAND:
./Common/GPU/Vulkan/VulkanContext.cpp:	case WINDOWSYSTEM_DISPLAY:
./Common/GPU/Vulkan/VulkanContext.cpp:#if !defined(__LIBRETRO__)
./Common/GPU/Vulkan/VulkanContext.cpp:		And when not to use libretro need VkDisplaySurfaceCreateInfoKHR this extension,
./Common/GPU/Vulkan/VulkanContext.cpp:		// When using the VK_KHR_display extension and not using LIBRETRO, a complete
./Common/GPU/Vulkan/VulkanContext.cpp:#if PPSSPP_PLATFORM(IOS)
./Common/GPU/Vulkan/VulkanContext.cpp:	// Standard scheme, use the standard macros.
./Common/GPU/Vulkan/VulkanContext.h:enum WindowSystem {
./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_UNINITIALIZED,
./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_WIN32,
./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_ANDROID,
./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_METAL_EXT,
./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_XLIB,
./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_XCB,
./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_WAYLAND,
./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_DISPLAY,
./Common/GPU/Vulkan/VulkanContext.h:	VkResult InitSurface(WindowSystem winsys, void *data1, void *data2);
./Common/GPU/Vulkan/VulkanContext.h:	WindowSystem winsys_ = WINDOWSYSTEM_UNINITIALIZED;
./Common/GPU/Vulkan/VulkanFrameData.h:#if PPSSPP_PLATFORM(IOS)
./Common/GPU/Vulkan/VulkanFrameData.h:// iOS doesn't support a large number of timestamp queries natively.
./Common/GPU/Vulkan/VulkanFramebuffer.cpp:	VkResult res = vmaCreateImage(vulkan->Allocator(), &ici, &allocCreateInfo, &img.image, &img.alloc, &allocInfo);
./Common/GPU/Vulkan/VulkanImage.cpp:	VkResult res = vmaCreateImage(vulkan_->Allocator(), &image_create_info, &allocCreateInfo, &image_, &allocation_, &allocInfo);
./Common/GPU/Vulkan/VulkanImage.cpp:		ERROR_LOG(Log::G3D, "vmaCreateImage failed: %s. Destroying image.", VulkanResultToString(res));
./Common/GPU/Vulkan/VulkanLoader.cpp:#if !PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(SWITCH)
./Common/GPU/Vulkan/VulkanLoader.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./Common/GPU/Vulkan/VulkanLoader.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./Common/GPU/Vulkan/VulkanLoader.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./Common/GPU/Vulkan/VulkanLoader.cpp:	"SDL:Horizon",
./Common/GPU/Vulkan/VulkanLoader.cpp:#if PPSSPP_PLATFORM(MAC)
./Common/GPU/Vulkan/VulkanLoader.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./Common/GPU/Vulkan/VulkanLoader.cpp:#elif PPSSPP_PLATFORM(IOS)
./Common/GPU/Vulkan/VulkanLoader.cpp:#elif PPSSPP_PLATFORM(MAC)
./Common/GPU/Vulkan/VulkanLoader.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./Common/GPU/Vulkan/VulkanLoader.cpp:#elif PPSSPP_PLATFORM(UWP)
./Common/GPU/Vulkan/VulkanLoader.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./Common/GPU/Vulkan/VulkanLoader.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./Common/GPU/Vulkan/VulkanLoader.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./Common/GPU/Vulkan/VulkanLoader.cpp:#if PPSSPP_PLATFORM(IOS)
./Common/GPU/Vulkan/VulkanLoader.cpp:	// MoltenVK does no longer seem to support iOS <= 12, despite what the docs say.
./Common/GPU/Vulkan/VulkanLoader.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./Common/GPU/Vulkan/VulkanLoader.cpp:	INFO_LOG(Log::G3D, "iOS: Vulkan doesn't need loading");
./Common/GPU/Vulkan/VulkanLoader.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./Common/GPU/Vulkan/VulkanLoader.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./Common/GPU/Vulkan/VulkanLoader.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./Common/GPU/Vulkan/VulkanLoader.h:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./Common/GPU/Vulkan/VulkanLoader.h:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./Common/GPU/Vulkan/VulkanLoader.h:// Putting our own Vulkan function pointers in a namespace ensures that ppsspp_libretro.so doesn't collide with libvulkan.so.
./Common/GPU/Vulkan/VulkanLoader.h:#endif  // !PPSSPP_PLATFORM(IOS_APP_STORE)
./Common/GPU/Vulkan/VulkanMemory.cpp:	VkResult result = vmaCreateBuffer(vulkan_->Allocator(), &b, &allocCreateInfo, &block.buffer, &block.allocation, &allocInfo);
./Common/GPU/Vulkan/VulkanQueueRunner.cpp:	VkResult res = vmaCreateImage(vulkan_->Allocator(), &image_info, &allocCreateInfo, &depth_.image, &depth_.alloc, &allocInfo);
./Common/GPU/Vulkan/VulkanQueueRunner.cpp:	VkResult res = vmaCreateBuffer(vulkan_->Allocator(), &buf, &allocCreateInfo, &readback->buffer, &readback->allocation, &allocInfo);
./Common/GPU/Vulkan/VulkanRenderManager.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./Common/GPU/Vulkan/thin3d_vulkan.cpp:static const VkBlendOp blendEqToVk[] = {
./Common/GPU/Vulkan/thin3d_vulkan.cpp:		// Color write mask not masking write in certain scenarios with a depth test, see #10421.
./Common/GPU/Vulkan/thin3d_vulkan.cpp:	bs->attachments[0].colorBlendOp = blendEqToVk[(int)desc.eqCol];
./Common/GPU/Vulkan/thin3d_vulkan.cpp:	bs->attachments[0].alphaBlendOp = blendEqToVk[(int)desc.eqAlpha];
./Common/GPU/thin3d_create.h:// Separated this stuff into its own file so we don't get Windows.h included if all we want is the thin3d declarations.
./Common/GPU/thin3d_create.h:#include "Common/CommonWindows.h"
./Common/GraphicsContext.h:	virtual bool ThreadFrame(bool waitIfEmpty) { return true; }   // waitIfEmpty should normally be true, except in exit scenarios.
./Common/Log.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./Common/Log.cpp:#include "CommonWindows.h"
./Common/Log.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/Log.h:// Currently only actually shows a dialog box on Windows.
./Common/Log.h:void SetAssertDialogParent(void *handle);  // HWND on windows. Ignored on other platforms.
./Common/Log.h:// Tricky macro to get the basename, that also works if *built* on Win32.
./Common/Log.h:// Doesn't mean this macro can be used on Win32 though.
./Common/Log.h:// If we're a debug build, _dbg_assert_ is active. Not otherwise, even on Windows.
./Common/Log.h:// Just INFO_LOGs on nonWindows. On Windows it outputs to the VS output console.
./Common/Log/ConsoleListener.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./Common/Log/ConsoleListener.cpp:#include "Common/CommonWindows.h"
./Common/Log/ConsoleListener.cpp:#endif  // PPSSPP_PLATFORM(WINDOWS)
./Common/Log/ConsoleListener.h:// Windows-only.
./Common/Log/ConsoleListener.h:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./Common/Log/ConsoleListener.h:#include "Common/CommonWindows.h"
./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(UWP) && defined(_DEBUG)
./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(UWP) || PPSSPP_PLATFORM(SWITCH)
./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/Log/LogManager.cpp:#if !PPSSPP_PLATFORM(UWP)
./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(MAC)
./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./Common/Log/LogManager.h:#if PPSSPP_PLATFORM(WINDOWS)
./Common/Log/LogManager.h:#if PPSSPP_PLATFORM(WINDOWS)
./Common/LoongArchCPUDetect.cpp:#if defined(CPU_FEATURES_OS_LINUX)
./Common/LoongArchCPUDetect.cpp:// Only Linux platforms have /proc/cpuinfo
./Common/LoongArchCPUDetect.cpp:#if defined(__linux__)
./Common/LoongArchCPUDetect.cpp:	// https://github.com/torvalds/linux/blob/master/arch/loongarch/include/uapi/asm/hwcap.h
./Common/LoongArchCPUDetect.cpp:#if !defined(__linux__)
./Common/LoongArchCPUDetect.cpp:#else // __linux__
./Common/MachineContext.h:// Note: If MACHINE_CONTEXT_SUPPORTED is not set after including this,
./Common/MachineContext.h:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./Common/MachineContext.h:#include "Common/CommonWindows.h"
./Common/MachineContext.h:#if defined(__LIBRETRO__)
./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./Common/MachineContext.h:#elif PPSSPP_PLATFORM(MAC)
./Common/MachineContext.h:#include <mach/mach.h>
./Common/MachineContext.h:#include <mach/message.h>
./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./Common/MachineContext.h:#elif defined(__linux__)
./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./Common/MachineContext.h:// No context definition for machine
./Common/MachineContext.h:#ifdef MACHINE_CONTEXT_SUPPORTED
./Common/MachineContext.h:#endif  // MACHINE_CONTEXT_SUPPORTED
./Common/Math/SIMDHeaders.h:// Weird how you can't just use #pragma in a macro.
./Common/MemArena.h:#include "CommonWindows.h"
./Common/MemArena.h:#include <mach/mach.h>
./Common/MemArenaAndroid.cpp:#include <linux/ashmem.h>
./Common/MemArenaAndroid.cpp:// Windows mappings need to be on 64K boundaries, due to Alpha legacy.
./Common/MemArenaDarwin.cpp:#include <mach/mach.h>
./Common/MemArenaDarwin.cpp:#include <mach/vm_map.h>
./Common/MemArenaDarwin.cpp:	kern_return_t retval = vm_allocate(mach_task_self(), &vm_mem, size, VM_FLAGS_ANYWHERE);
./Common/MemArenaDarwin.cpp:	vm_deallocate(mach_task_self(), vm_mem, vm_size);
./Common/MemArenaDarwin.cpp:	mach_port_t self = mach_task_self();
./Common/MemArenaDarwin.cpp:	vm_deallocate(mach_task_self(), addr, size);
./Common/MemArenaDarwin.cpp:#if PPSSPP_PLATFORM(IOS) && PPSSPP_ARCH(64BIT)
./Common/MemArenaDarwin.cpp:#if PPSSPP_PLATFORM(IOS) && PPSSPP_ARCH(64BIT)
./Common/MemArenaDarwin.cpp:	// The caller will need to do probing, like on 32-bit Windows.
./Common/MemArenaDarwin.cpp:	kern_return_t retval = vm_allocate(mach_task_self(), &addr, size, VM_FLAGS_ANYWHERE);
./Common/MemArenaDarwin.cpp:		vm_deallocate(mach_task_self(), addr, size);
./Common/MemArenaPosix.cpp:// Do not sync memory to underlying file. Linux has this by default.
./Common/MemArenaWin32.cpp:#include "CommonWindows.h"
./Common/MemArenaWin32.cpp:// Windows mappings need to be on 64K boundaries, due to Alpha legacy.
./Common/MemArenaWin32.cpp:#if !PPSSPP_PLATFORM(UWP)
./Common/MemArenaWin32.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/MemArenaWin32.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/MemoryUtil.cpp:#include "Common/CommonWindows.h"
./Common/MemoryUtil.cpp:#include <mach/vm_param.h>
./Common/MemoryUtil.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/MemoryUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/MemoryUtil.cpp:#else  // Non-Windows platforms
./Common/MemoryUtil.cpp:#endif  // non-windows
./Common/MemoryUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/MemoryUtil.cpp:	// This might also come in useful for UWP (Universal Windows Platform) if I'm understanding things correctly.
./Common/MemoryUtil.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(UWP) || defined(__OpenBSD__)
./Common/MemoryUtil.cpp:#elif PPSSPP_PLATFORM(MAC) && PPSSPP_ARCH(ARM64)
./Common/MemoryUtil.cpp:	// Returning true here lets you test the W^X path on Windows and other non-W^X platforms.
./Common/MemoryUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/MipsCPUDetect.cpp:// Only Linux platforms have /proc/cpuinfo
./Common/MipsCPUDetect.cpp:#if defined(__linux__)
./Common/MipsCPUDetect.cpp:#if !defined(__linux__)
./Common/MipsCPUDetect.cpp:#else // __linux__
./Common/MipsEmitter.h:// Everything that needs to generate machine code should inherit from this.
./Common/MsgHandler.h:// Currently only actually shows a dialog box on Windows.
./Common/MsgHandler.h:// Tricky macro to get the basename, that also works if *built* on Win32.
./Common/Net/HTTPClient.cpp:			// Windows sockets aren't limited by socket number, just by count, so checking FD_SETSIZE there is wrong.
./Common/Net/HTTPClient.cpp:#if !PPSSPP_PLATFORM(WINDOWS)
./Common/Net/HTTPServer.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/Net/HTTPServer.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/Net/HTTPServer.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/Net/Resolve.cpp:#elif defined(SIOCGIFCONF) // Better detection on Linux/UNIX/MacOS/some Android
./Common/Net/Resolve.cpp:#else // Fallback to POSIX/Cross-platform way but may not work well on Linux (ie. only shows 127.0.0.1)
./Common/Net/Resolve.cpp:		ptr += 5; // Null byte + QTYPE (2 bytes) + QCLASS (2 bytes)
./Common/Net/Sinks.cpp:#if !PPSSPP_PLATFORM(WINDOWS)
./Common/Net/Sinks.cpp:#if !PPSSPP_PLATFORM(WINDOWS)
./Common/Net/SocketCompat.h:#if PPSSPP_PLATFORM(WINDOWS)
./Common/Net/SocketCompat.h:#include "Common/CommonWindows.h"
./Common/Net/SocketCompat.h:#if PPSSPP_PLATFORM(WINDOWS)
./Common/OSVersion.cpp:#if !PPSSPP_PLATFORM(UWP)
./Common/OSVersion.cpp:#include "Common/CommonWindows.h"
./Common/OSVersion.cpp:struct WindowsReleaseInfo
./Common/OSVersion.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/OSVersion.cpp:bool DoesVersionMatchWindows(uint32_t major, uint32_t minor, uint32_t spMajor, uint32_t spMinor, uint32_t build, bool greater) {
./Common/OSVersion.cpp:#if !PPSSPP_PLATFORM(UWP)
./Common/OSVersion.cpp:		// "Applications not manifested for Windows 10 will return the Windows 8 OS version value (6.2)."
./Common/OSVersion.cpp:		// Try to use kernel32.dll instead, for Windows 10+.  Doesn't do SP versions.
./Common/OSVersion.cpp:			// To detect Windows 11 we must check build number
./Common/OSVersion.cpp:	return DoesVersionMatchWindows(6, 0, 0, 0, 0, true);
./Common/OSVersion.cpp:	return DoesVersionMatchWindows(6, 1, 0, 0, 0, true);
./Common/OSVersion.cpp:	return DoesVersionMatchWindows(6, 2, 0, 0, 0, true);
./Common/OSVersion.cpp:	return DoesVersionMatchWindows(10, 0, 0, 0, 0, true);
./Common/OSVersion.cpp:	return DoesVersionMatchWindows(10, 0, 0, 0, 22000, true);
./Common/OSVersion.cpp:std::string GetWindowsVersion() {
./Common/OSVersion.cpp:	std::vector<std::pair<std::string, WindowsReleaseInfo>> windowsReleases = {
./Common/OSVersion.cpp:		{ "Microsoft Windows XP, Service Pack 2", { 5, 1, 2, 0 } },
./Common/OSVersion.cpp:		{ "Microsoft Windows XP, Service Pack 3", { 5, 1, 3, 0 } },
./Common/OSVersion.cpp:		{ "Microsoft Windows Vista", { 6, 0, 0, 0 } },
./Common/OSVersion.cpp:		{ "Microsoft Windows Vista, Service Pack 1", { 6, 0, 1, 0 } },
./Common/OSVersion.cpp:		{ "Microsoft Windows Vista, Service Pack 2", { 6, 0, 2, 0 } },
./Common/OSVersion.cpp:		{ "Microsoft Windows 7", { 6, 1, 0, 0 } },
./Common/OSVersion.cpp:		{ "Microsoft Windows 7, Service Pack 1", { 6, 1, 1, 0 } },
./Common/OSVersion.cpp:		{ "Microsoft Windows 8", { 6, 2, 0, 0 } },
./Common/OSVersion.cpp:		{ "Microsoft Windows 8.1", { 6, 3, 0, 0 } },
./Common/OSVersion.cpp:		{ "Microsoft Windows 10", { 10, 0, 0, 0 } },
./Common/OSVersion.cpp:		{ "Microsoft Windows 11", { 10, 0, 0, 0, 22000 } },
./Common/OSVersion.cpp:	for (auto release = rbegin(windowsReleases); release != rend(windowsReleases); ++release) {
./Common/OSVersion.cpp:		WindowsReleaseInfo releaseInfo = release->second;
./Common/OSVersion.cpp:		if (DoesVersionMatchWindows(releaseInfo.major, releaseInfo.minor, releaseInfo.spMajor, releaseInfo.spMinor, releaseInfo.build, releaseInfo.greater)) {
./Common/OSVersion.cpp:	return "Unknown version of Microsoft Windows.";
./Common/OSVersion.cpp:std::string GetWindowsSystemArchitecture() {
./Common/OSVersion.h:bool DoesVersionMatchWindows(uint32_t major, uint32_t minor, uint32_t spMajor, uint32_t spMinor, uint32_t build, bool acceptGreater);
./Common/OSVersion.h:std::string GetWindowsVersion();
./Common/OSVersion.h:std::string GetWindowsSystemArchitecture();
./Common/Profiler/Profiler.cpp:#if PPSSPP_PLATFORM(IOS) && defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_9_0
./Common/Profiler/Profiler.cpp:// iOS did not support C++ thread_local before iOS 9
./Common/Render/DrawBuffer.h:	// Good for stretching out a white image without edge artifacts that I'm getting on iOS.
./Common/Render/Text/draw_text.cpp:#include "Common/Render/Text/draw_text_uwp.h"
./Common/Render/Text/draw_text.cpp:#include "Common/Render/Text/draw_text_qt.h"
./Common/Render/Text/draw_text.cpp:#include "Common/Render/Text/draw_text_sdl.h"
./Common/Render/Text/draw_text.cpp:#if defined(__LIBRETRO__)
./Common/Render/Text/draw_text.cpp:#elif defined(_WIN32) && !PPSSPP_PLATFORM(UWP)
./Common/Render/Text/draw_text.cpp:#elif PPSSPP_PLATFORM(UWP)
./Common/Render/Text/draw_text.cpp:	drawer = new TextDrawerUWP(draw);
./Common/Render/Text/draw_text.cpp:#elif PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./Common/Render/Text/draw_text.cpp:#elif defined(USING_QT_UI)
./Common/Render/Text/draw_text.cpp:	drawer = new TextDrawerQt(draw);
./Common/Render/Text/draw_text.cpp:#elif USE_SDL2_TTF
./Common/Render/Text/draw_text.cpp:	drawer = new TextDrawerSDL(draw);
./Common/Render/Text/draw_text_android.cpp:#if PPSSPP_PLATFORM(ANDROID) && !defined(__LIBRETRO__)
./Common/Render/Text/draw_text_cocoa.h:#if PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./Common/Render/Text/draw_text_cocoa.mm:#if PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./Common/Render/Text/draw_text_cocoa.mm:#if PPSSPP_PLATFORM(MAC)
./Common/Render/Text/draw_text_qt.cpp:#include "Common/Render/Text/draw_text_qt.h"
./Common/Render/Text/draw_text_qt.cpp:#if defined(USING_QT_UI)
./Common/Render/Text/draw_text_qt.cpp:#include <QtGui/QFont>
./Common/Render/Text/draw_text_qt.cpp:#include <QtGui/QImage>
./Common/Render/Text/draw_text_qt.cpp:#include <QtGui/QPainter>
./Common/Render/Text/draw_text_qt.cpp:#include <QtGui/QFontMetrics>
./Common/Render/Text/draw_text_qt.cpp:#include <QtOpenGL/QGLWidget>
./Common/Render/Text/draw_text_qt.cpp:TextDrawerQt::TextDrawerQt(Draw::DrawContext *draw) : TextDrawer(draw) {
./Common/Render/Text/draw_text_qt.cpp:TextDrawerQt::~TextDrawerQt() {
./Common/Render/Text/draw_text_qt.cpp:void TextDrawerQt::SetOrCreateFont(const FontStyle &style) {
./Common/Render/Text/draw_text_qt.cpp:void TextDrawerQt::MeasureStringInternal(std::string_view str, float *w, float *h) {
./Common/Render/Text/draw_text_qt.cpp:bool TextDrawerQt::DrawStringBitmap(std::vector<uint8_t> &bitmapData, TextStringEntry &entry, Draw::DataFormat texFormat, std::string_view str, int align, bool fullColor) {
./Common/Render/Text/draw_text_qt.cpp:	painter.drawText(image.rect(), Qt::AlignTop | Qt::AlignLeft, QString::fromUtf8(str.data(), str.length()));
./Common/Render/Text/draw_text_qt.cpp:void TextDrawerQt::ClearFonts() {
./Common/Render/Text/draw_text_qt.h:#if defined(USING_QT_UI)
./Common/Render/Text/draw_text_qt.h:class TextDrawerQt : public TextDrawer {
./Common/Render/Text/draw_text_qt.h:	TextDrawerQt(Draw::DrawContext *draw);
./Common/Render/Text/draw_text_qt.h:	~TextDrawerQt();
./Common/Render/Text/draw_text_sdl.cpp:#include "Common/Render/Text/draw_text_sdl.h"
./Common/Render/Text/draw_text_sdl.cpp:#if defined(USE_SDL2_TTF)
./Common/Render/Text/draw_text_sdl.cpp:#include "SDL2/SDL.h"
./Common/Render/Text/draw_text_sdl.cpp:#include "SDL2/SDL_ttf.h"
./Common/Render/Text/draw_text_sdl.cpp:TextDrawerSDL::TextDrawerSDL(Draw::DrawContext *draw): TextDrawer(draw) {
./Common/Render/Text/draw_text_sdl.cpp:		ERROR_LOG(Log::G3D, "Unable to initialize SDL2_ttf");
./Common/Render/Text/draw_text_sdl.cpp:#if defined(USE_SDL2_TTF_FONTCONFIG)
./Common/Render/Text/draw_text_sdl.cpp:TextDrawerSDL::~TextDrawerSDL() {
./Common/Render/Text/draw_text_sdl.cpp:#if defined(USE_SDL2_TTF_FONTCONFIG)
./Common/Render/Text/draw_text_sdl.cpp:// If a user complains about missing characters on SDL, re-visit this!
./Common/Render/Text/draw_text_sdl.cpp:void TextDrawerSDL::PrepareFallbackFonts(std::string_view locale) {
./Common/Render/Text/draw_text_sdl.cpp:#if defined(USE_SDL2_TTF_FONTCONFIG)
./Common/Render/Text/draw_text_sdl.cpp:#elif PPSSPP_PLATFORM(MAC)
./Common/Render/Text/draw_text_sdl.cpp:uint32_t TextDrawerSDL::CheckMissingGlyph(std::string_view text) {
./Common/Render/Text/draw_text_sdl.cpp:int TextDrawerSDL::FindFallbackFonts(uint32_t missingGlyph, int ptSize) {
./Common/Render/Text/draw_text_sdl.cpp:void TextDrawerSDL::SetOrCreateFont(const FontStyle &style) {
./Common/Render/Text/draw_text_sdl.cpp:		INFO_LOG(Log::G3D, "Loading SDL font '%s' from VFS at size %d pts", useFont.c_str(), ptSize);
./Common/Render/Text/draw_text_sdl.cpp:			SDL_RWops *rw = SDL_RWFromMem(fileData, static_cast<int>(fileSz));
./Common/Render/Text/draw_text_sdl.cpp:void TextDrawerSDL::MeasureStringInternal(std::string_view str, float *w, float *h) {
./Common/Render/Text/draw_text_sdl.cpp:bool TextDrawerSDL::DrawStringBitmap(std::vector<uint8_t> &bitmapData, TextStringEntry &entry, Draw::DataFormat texFormat, std::string_view str, int align, bool fullColor) {
./Common/Render/Text/draw_text_sdl.cpp:	// If a string includes only newlines, SDL2_ttf will refuse to render it
./Common/Render/Text/draw_text_sdl.cpp:#if SDL_TTF_VERSION_ATLEAST(2, 20, 0)
./Common/Render/Text/draw_text_sdl.cpp:	SDL_Color fgColor = { 0xFF, 0xFF, 0xFF, 0xFF };
./Common/Render/Text/draw_text_sdl.cpp:	SDL_Surface *text = TTF_RenderUTF8_Blended_Wrapped(font, processedStr.c_str(), fgColor, 0);
./Common/Render/Text/draw_text_sdl.cpp:	SDL_LockSurface(text);
./Common/Render/Text/draw_text_sdl.cpp:	SDL_UnlockSurface(text);
./Common/Render/Text/draw_text_sdl.cpp:	SDL_FreeSurface(text);
./Common/Render/Text/draw_text_sdl.cpp:void TextDrawerSDL::ClearFonts() {
./Common/Render/Text/draw_text_sdl.h:#if defined(USE_SDL2_TTF)
./Common/Render/Text/draw_text_sdl.h:#include "SDL2/SDL.h"
./Common/Render/Text/draw_text_sdl.h:#include "SDL2/SDL_ttf.h"
./Common/Render/Text/draw_text_sdl.h:#if defined(USE_SDL2_TTF_FONTCONFIG)
./Common/Render/Text/draw_text_sdl.h:class TextDrawerSDL : public TextDrawer {
./Common/Render/Text/draw_text_sdl.h:	TextDrawerSDL(Draw::DrawContext *draw);
./Common/Render/Text/draw_text_sdl.h:	~TextDrawerSDL();
./Common/Render/Text/draw_text_sdl.h:#if defined(USE_SDL2_TTF_FONTCONFIG)
./Common/Render/Text/draw_text_uwp.cpp:#include "Common/Render/Text/draw_text_uwp.h"
./Common/Render/Text/draw_text_uwp.cpp:#if PPSSPP_PLATFORM(UWP)
./Common/Render/Text/draw_text_uwp.cpp:TextDrawerUWP::TextDrawerUWP(Draw::DrawContext *draw) : TextDrawer(draw), ctx_(nullptr) {
./Common/Render/Text/draw_text_uwp.cpp:	// It's fine to assume we are using D3D11 in UWP
./Common/Render/Text/draw_text_uwp.cpp:TextDrawerUWP::~TextDrawerUWP() {
./Common/Render/Text/draw_text_uwp.cpp:void TextDrawerUWP::SetOrCreateFont(const FontStyle &style) {
./Common/Render/Text/draw_text_uwp.cpp:void TextDrawerUWP::MeasureStringInternal(std::string_view str, float *w, float *h) {
./Common/Render/Text/draw_text_uwp.cpp:bool TextDrawerUWP::DrawStringBitmap(std::vector<uint8_t> &bitmapData, TextStringEntry &entry, Draw::DataFormat texFormat, std::string_view str, int align, bool fullColor) {
./Common/Render/Text/draw_text_uwp.cpp:void TextDrawerUWP::ClearFonts() {
./Common/Render/Text/draw_text_uwp.h:#if PPSSPP_PLATFORM(UWP)
./Common/Render/Text/draw_text_uwp.h:class TextDrawerUWP : public TextDrawer {
./Common/Render/Text/draw_text_uwp.h:	TextDrawerUWP(Draw::DrawContext *draw);
./Common/Render/Text/draw_text_uwp.h:	~TextDrawerUWP();
./Common/Render/Text/draw_text_win.cpp:#if defined(_WIN32) && !defined(USING_QT_UI) && !PPSSPP_PLATFORM(UWP)
./Common/Render/Text/draw_text_win.cpp:#include <Windows.h>
./Common/Render/Text/draw_text_win.h:#if defined(_WIN32) && !defined(USING_QT_UI) && !PPSSPP_PLATFORM(UWP)
./Common/RiscVCPUDetect.cpp:#if defined(CPU_FEATURES_OS_LINUX)
./Common/RiscVCPUDetect.cpp:// Only Linux platforms have /proc/cpuinfo
./Common/RiscVCPUDetect.cpp:#if defined(__linux__)
./Common/RiscVCPUDetect.cpp:#if !defined(__linux__)
./Common/RiscVCPUDetect.cpp:#else // __linux__
./Common/RiscVEmitter.cpp:#if PPSSPP_ARCH(RISCV64) && PPSSPP_PLATFORM(LINUX)
./Common/RiscVEmitter.cpp:	VMACC = 0b101101,
./Common/RiscVEmitter.cpp:	VFMACC = 0b101100,
./Common/RiscVEmitter.cpp:	VFNMACC = 0b101101,
./Common/RiscVEmitter.cpp:	VWMACCU = 0b111100,
./Common/RiscVEmitter.cpp:	VWMACC = 0b111101,
./Common/RiscVEmitter.cpp:	VWMACCUS = 0b111110,
./Common/RiscVEmitter.cpp:	VWMACCSU = 0b111111,
./Common/RiscVEmitter.cpp:	VFWMACC = 0b111100,
./Common/RiscVEmitter.cpp:	VFWNMACC = 0b111101,
./Common/RiscVEmitter.cpp:#if PPSSPP_PLATFORM(LINUX)
./Common/RiscVEmitter.cpp:void RiscVEmitter::VMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeMVV(vd, vs1, vs2, vm, Funct6::VMACC));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VMACC_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeMVX(vd, rs1, vs2, vm, Funct6::VMACC));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VWMACCU_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeMVV(vd, vs1, vs2, vm, Funct6::VWMACCU));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VWMACCU_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeMVX(vd, rs1, vs2, vm, Funct6::VWMACCU));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VWMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeMVV(vd, vs1, vs2, vm, Funct6::VWMACC));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VWMACC_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeMVX(vd, rs1, vs2, vm, Funct6::VWMACC));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VWMACCSU_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeMVV(vd, vs1, vs2, vm, Funct6::VWMACCSU));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VWMACCSU_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeMVX(vd, rs1, vs2, vm, Funct6::VWMACCSU));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VWMACCUS_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeMVX(vd, rs1, vs2, vm, Funct6::VWMACCUS));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VFMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeFVV(vd, vs1, vs2, vm, Funct6::VFMACC));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VFMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeFVF(vd, rs1, vs2, vm, Funct6::VFMACC));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VFNMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeFVV(vd, vs1, vs2, vm, Funct6::VFNMACC));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VFNMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeFVF(vd, rs1, vs2, vm, Funct6::VFNMACC));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VFWMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeFVV(vd, vs1, vs2, vm, Funct6::VFWMACC));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VFWMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeFVF(vd, rs1, vs2, vm, Funct6::VFWMACC));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VFWNMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeFVV(vd, vs1, vs2, vm, Funct6::VFWNMACC));
./Common/RiscVEmitter.cpp:void RiscVEmitter::VFWNMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./Common/RiscVEmitter.cpp:	Write32(EncodeFVF(vd, rs1, vs2, vm, Funct6::VFWNMACC));
./Common/RiscVEmitter.h:	void VMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VMACC_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VWMACCU_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VWMACCU_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VWMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VWMACC_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VWMACCSU_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VWMACCSU_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VWMACCUS_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VFMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VFMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VFNMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VFNMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VFWMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VFWMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VFWNMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/RiscVEmitter.h:	void VFWNMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./Common/Serialize/SerializeFuncs.h:// Which also can be a problem, for example struct tm is non-POD on linux, for whatever reason...
./Common/Serialize/Serializer.h:	// If it's not null, it will be used, but only hope can save you from overruns at the end. For libretro.
./Common/StringUtils.cpp:#include "Common/CommonWindows.h"
./Common/StringUtils.h:// if not nullptr. Useful for Windows menu strings.
./Common/SysError.cpp:#include "CommonWindows.h"
./Common/System/Display.h:// On some platforms (currently only Windows UWP) we need to manually rotate
./Common/System/Request.h:// images with the file browser below. If you provide savePath, iOS will be able to
./Common/System/System.h:// These APIs must be implemented by every port (for example app-android.cpp, SDLMain.cpp).
./Common/System/System.h:	// for iOS IAP support
./Common/System/System.h:	// Exposed on SDL.
./Common/System/System.h:	// iOS app store limitation: The documents directory should be the only browsable directory.
./Common/Thread/ThreadUtil.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/Thread/ThreadUtil.cpp:#include "Common/CommonWindows.h"
./Common/Thread/ThreadUtil.cpp:#if (PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(LINUX)) && !defined(_GNU_SOURCE)
./Common/Thread/ThreadUtil.cpp:#if !PPSSPP_PLATFORM(WINDOWS)
./Common/Thread/ThreadUtil.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./Common/Thread/ThreadUtil.cpp:		// Failed to find the function. Windows version too old, most likely.
./Common/Thread/ThreadUtil.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./Common/Thread/ThreadUtil.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./Common/Thread/ThreadUtil.cpp:#elif PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(LINUX)
./Common/Thread/ThreadUtil.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/Thread/ThreadUtil.cpp:#if __LIBRETRO__
./Common/Thread/ThreadUtil.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./Common/Thread/ThreadUtil.cpp:#elif PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./Common/Thread/ThreadUtil.cpp:#elif PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(LINUX)
./Common/Thunk.cpp:	// Account for the return address and "home space" on Windows (which needs to be at the bottom.)
./Common/TimeUtil.cpp:#include "CommonWindows.h"
./Common/TimeUtil.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Common/TimeUtil.cpp:#if !PPSSPP_PLATFORM(UWP)
./Common/TimeUtil.cpp:#elif PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(LINUX) || PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./Common/TimeUtil.cpp:	// Precise Windows sleep function from: https://github.com/blat-blatnik/Snippets/blob/main/precise_sleep.c
./Common/TimeUtil.h:// This is only interesting for Linux, in relation to VK_GOOGLE_display_timing.
./Common/TimeUtil.h:// Sleep for milliseconds. Does not necessarily have millisecond granularity, especially on Windows.
./Common/TimeUtil.h:// Sleep for microseconds. Does not necessarily have microsecond granularity, especially on Windows.
./Common/TimeUtil.h:// Precise sleep. Can consume a little bit of CPU on Windows at least.
./Common/UI/Root.cpp:				// We stupidly interpret the joystick Y axis backwards on Android and Linux instead of reversing
./Common/UI/Root.cpp:#if PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(LINUX) || PPSSPP_PLATFORM(SWITCH)
./Common/UI/View.cpp:// Handles both windows and unix line endings.
./Common/VR/OpenXRLoader.cpp:#include "Common/CommonWindows.h"
./Common/VR/OpenXRLoader.h:#include "Common/CommonWindows.h"
./Common/VR/OpenXRLoader.h:// On Windows (and Linux etc), we're not so lucky - we could link to static libraries, but we really
./Common/x64Emitter.cpp:	sseMOVDQtoRM   = 0x7F,
./Common/x64Emitter.cpp:	// Nop strings from https://stackoverflow.com/questions/25545470/long-multi-byte-nops-commonly-understood-macros-or-other-notation
./Common/x64Emitter.cpp:void XEmitter::MOVDQA(OpArg arg, X64Reg regOp)  {WriteSSEOp(0x66, sseMOVDQtoRM, regOp, arg);}
./Common/x64Emitter.cpp:void XEmitter::MOVDQU(OpArg arg, X64Reg regOp)  {WriteSSEOp(0xF3, sseMOVDQtoRM, regOp, arg);}
./Common/x64Emitter.cpp:void XEmitter::VMOVDQA(int bits, OpArg arg, X64Reg regOp1) { WriteAVXOp(bits, 0x66, sseMOVDQtoRM, regOp1, arg); }
./Common/x64Emitter.cpp:void XEmitter::VMOVDQU(int bits, OpArg arg, X64Reg regOp1) { WriteAVXOp(bits, 0xF3, sseMOVDQtoRM, regOp1, arg); }
./Common/x64Emitter.h:inline OpArg MAccessibleDisp(X64Reg r, const T *tbase, const T *t) {
./Core/AVIDump.cpp:#define __STDC_CONSTANT_MACROS 1
./Core/Config.cpp:#if PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(IOS)
./Core/Config.cpp:std::string CreateRandMAC() {
./Core/Config.cpp:#if PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(IOS)
./Core/Config.cpp:#if PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(LINUX) || PPSSPP_PLATFORM(MAC)
./Core/Config.cpp:	ConfigSetting("IgnoreBadMemAccess", SETTING(g_Config, bIgnoreBadMemAccess), true, CfgFlag::DEFAULT),
./Core/Config.cpp:#if PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(IOS)
./Core/Config.cpp:	ConfigSetting("ShrinkIfWindowSmall", SETTING(g_Config, bShrinkIfWindowSmall), false, CfgFlag::DEFAULT),
./Core/Config.cpp:	// Auto on Windows and Linux, 2x on large screens and iOS, 1x elsewhere.
./Core/Config.cpp:#if defined(USING_WIN_UI) || defined(USING_QT_UI)
./Core/Config.cpp:#elif PPSSPP_PLATFORM(IOS)
./Core/Config.cpp:#if PPSSPP_PLATFORM(ANDROID) || defined(USING_QT_UI) || PPSSPP_PLATFORM(UWP) || PPSSPP_PLATFORM(IOS)
./Core/Config.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Core/Config.cpp:	// On older Windows, to be safe, use Direct3D 11.
./Core/Config.cpp:#elif PPSSPP_PLATFORM(MAC)
./Core/Config.cpp:	// On Intel (generally older Macs) default to OpenGL.
./Core/Config.cpp:#elif PPSSPP_PLATFORM(IOS_APP_STORE)
./Core/Config.cpp:	// TODO: On some additional Linux platforms, we should also default to Vulkan.
./Core/Config.cpp:#if !PPSSPP_PLATFORM(UWP)
./Core/Config.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Core/Config.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/Config.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./Core/Config.cpp:#if PPSSPP_PLATFORM(IOS)
./Core/Config.cpp:	ConfigSetting("AudioBufferSize", SETTING(g_Config, iSDLAudioBufferSize), 256, CfgFlag::DEFAULT),
./Core/Config.cpp:	ConfigSetting("AudioSyncMode", SETTING(g_Config, iAudioPlaybackMode), (int)AudioSyncMode::CLASSIC_PITCH, CfgFlag::DEFAULT),
./Core/Config.cpp:	ConfigSetting("IgnoreWindowsKey", SETTING(g_Config, bIgnoreWindowsKey), false, CfgFlag::PER_GAME),
./Core/Config.cpp:	ConfigSetting("MacAddress", SETTING(g_Config, sMACAddress), "", CfgFlag::PER_GAME),
./Core/Config.cpp:#if defined(USING_WIN_UI) || defined(USING_QT_UI) || PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(SWITCH)
./Core/Config.cpp:	// For iOS, issue #19211
./Core/Config.cpp:	// Set a default MAC, and correct if it's an old format.
./Core/Config.cpp:	if (sMACAddress.length() != 17)
./Core/Config.cpp:		sMACAddress = CreateRandMAC();
./Core/Config.h:	bool bIgnoreWindowsKey;
./Core/Config.h:	bool bIgnoreBadMemAccess;
./Core/Config.h:	bool bShrinkIfWindowSmall;
./Core/Config.h:	std::string sD3D11Device;  // Windows only
./Core/Config.h:	int iWindowWidth;  // Windows and other windowed environments
./Core/Config.h:	bool bShowMenuBar;  // Windows-only
./Core/Config.h:	int iSDLAudioBufferSize;
./Core/Config.h:	// iOS only for now
./Core/Config.h:	// Ignored on iOS and other platforms that lack pause.
./Core/Config.h:	// Use the hardware scaler to scale up the image to save fillrate. Similar to Windows' window size, really.
./Core/Config.h:	std::string sMACAddress;
./Core/Config.h:std::string CreateRandMAC();
./Core/ConfigValues.h:constexpr int AUDIOSAMPLES_MIN = 0;
./Core/ConfigValues.h:constexpr int AUDIOSAMPLES_MAX = 2048;
./Core/ConfigValues.h:enum class AudioSyncMode {
./Core/ConfigValues.h:// iOS only
./Core/Core.cpp:			switch (gpu->ProcessDLQueue()) {
./Core/Core.cpp:			// If not a branch, just do a simple single-step, no point in involving the breakpoint machinery.
./Core/Core.cpp:	// In jit, we only flush PC when bIgnoreBadMemAccess is off.
./Core/Core.cpp:	if ((g_Config.iCpuCore == (int)CPUCore::JIT || g_Config.iCpuCore == (int)CPUCore::JIT_IR) && g_Config.bIgnoreBadMemAccess) {
./Core/Core.cpp:	if (!g_Config.bIgnoreBadMemAccess) {
./Core/Core.cpp:	// In jit, we only flush PC when bIgnoreBadMemAccess is off.
./Core/Core.cpp:	if ((g_Config.iCpuCore == (int)CPUCore::JIT || g_Config.iCpuCore == (int)CPUCore::JIT_IR) && g_Config.bIgnoreBadMemAccess) {
./Core/Core.cpp:	if (!g_Config.bIgnoreBadMemAccess || forceReport) {
./Core/Core.cpp:	if (!g_Config.bIgnoreBadMemAccess) {
./Core/Core.h:// Warning: these three are only used on Windows - debugger integration.
./Core/Core.vcxproj:    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
./Core/Core.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./Core/Core.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./Core/Core.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./Core/Core.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./Core/Core.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./Core/Core.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./Core/Core.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./Core/Core.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./Core/Core.vcxproj:  <PropertyGroup Label="UserMacros" />
./Core/Core.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ext\libchdr\include;..\ffmpeg\Windows\x86\include;../common;..;../ext/glew;../ext/snappy;../ext/libpng17;../ext/zlib;../ext;../ext/zstd/lib</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <Command>../Windows/git-version-gen.cmd</Command>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ext\libchdr\include;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/glew;../ext/snappy;../ext/libpng17;../ext/zlib;../ext;../ext/zstd/lib;../ext/zstd/lib</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <Command>../Windows/git-version-gen.cmd</Command>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ext\libchdr\include;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/glew;../ext/snappy;../ext/libpng17;../ext/zlib;../ext;../ext/zstd/lib</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <Command>../Windows/git-version-gen.cmd</Command>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ext\libchdr\include;..\ffmpeg\Windows\x86\include;../common;..;../ext/glew;../ext/snappy;../ext/libpng17;../ext/zlib;../ext;../ext/zstd/lib</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <Command>../Windows/git-version-gen.cmd</Command>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ext\libchdr\include;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/glew;../ext/snappy;../ext/libpng17;../ext/zlib;../ext;../ext/zstd/lib;../ext/zstd/lib</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <Command>../Windows/git-version-gen.cmd</Command>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ext\libchdr\include;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/glew;../ext/snappy;../ext/libpng17;../ext/zlib;../ext;../ext/zstd/lib</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <Command>../Windows/git-version-gen.cmd</Command>
./Core/Core.vcxproj:    <ClCompile Include="..\ext\libzip\zip_random_uwp.c">
./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./Core/Core.vcxproj:    <ClCompile Include="HLE\sceDmac.cpp" />
./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./Core/Core.vcxproj:    <ClInclude Include="HLE\sceDmac.h" />
./Core/Core.vcxproj.filters:    <ClCompile Include="HLE\sceDmac.cpp">
./Core/Core.vcxproj.filters:    <ClCompile Include="..\ext\libzip\zip_random_uwp.c">
./Core/Core.vcxproj.filters:    <ClInclude Include="HLE\sceDmac.h">
./Core/CoreTiming.cpp:	// Now, now... no time machines, please.
./Core/CoreTiming.h:// This is a system to schedule events into the emulated machine's future. Time is measured
./Core/CwCheat.h:#include <iostream>
./Core/Debugger/DisassemblyManager.cpp:			// otherwise there may be hidden consequences if the macro is displayed.
./Core/Debugger/DisassemblyManager.cpp:			// also, don't create a macro if something branches into the middle of it
./Core/Debugger/DisassemblyManager.cpp:				DisassemblyMacro* macro = NULL;
./Core/Debugger/DisassemblyManager.cpp:					macro = new DisassemblyMacro(opAddress);
./Core/Debugger/DisassemblyManager.cpp:					macro->setMacroLi(immediate,rt);
./Core/Debugger/DisassemblyManager.cpp:					macro = new DisassemblyMacro(opAddress);
./Core/Debugger/DisassemblyManager.cpp:						delete macro;
./Core/Debugger/DisassemblyManager.cpp:					macro->setMacroMemory(MIPSGetName(next),immediate,rt,dataSize);
./Core/Debugger/DisassemblyManager.cpp:				if (macro != NULL)
./Core/Debugger/DisassemblyManager.cpp:					entries[opAddress] = macro;
./Core/Debugger/DisassemblyManager.cpp:					for (int i = 0; i < macro->getNumLines(); i++)
./Core/Debugger/DisassemblyManager.cpp:						lineAddresses.push_back(macro->getLineAddress(i));
./Core/Debugger/DisassemblyManager.cpp:void DisassemblyMacro::setMacroLi(u32 _immediate, u8 _rt)
./Core/Debugger/DisassemblyManager.cpp:	type = MACRO_LI;
./Core/Debugger/DisassemblyManager.cpp:void DisassemblyMacro::setMacroMemory(std::string_view _name, u32 _immediate, u8 _rt, int _dataSize)
./Core/Debugger/DisassemblyManager.cpp:	type = MACRO_MEMORYIMM;
./Core/Debugger/DisassemblyManager.cpp:bool DisassemblyMacro::disassemble(u32 address, DisassemblyLineInfo &dest, bool insertSymbols, DebugInterface *cpuDebug)
./Core/Debugger/DisassemblyManager.cpp:	dest.type = DISTYPE_MACRO;
./Core/Debugger/DisassemblyManager.cpp:	case MACRO_LI:
./Core/Debugger/DisassemblyManager.cpp:	case MACRO_MEMORYIMM:
./Core/Debugger/DisassemblyManager.h:enum DisassemblyLineType { DISTYPE_OPCODE, DISTYPE_MACRO, DISTYPE_DATA, DISTYPE_OTHER };
./Core/Debugger/DisassemblyManager.h:class DisassemblyMacro: public DisassemblyEntry
./Core/Debugger/DisassemblyManager.h:	DisassemblyMacro(u32 _address): address(_address) { }
./Core/Debugger/DisassemblyManager.h:	void setMacroLi(u32 _immediate, u8 _rt);
./Core/Debugger/DisassemblyManager.h:	void setMacroMemory(std::string_view _name, u32 _immediate, u8 _rt, int _dataSize);
./Core/Debugger/DisassemblyManager.h:	enum MacroType { MACRO_LI, MACRO_MEMORYIMM };
./Core/Debugger/DisassemblyManager.h:	MacroType type;
./Core/Debugger/SymbolMap.cpp:#include "Common/CommonWindows.h"
./Core/Debugger/SymbolMap.cpp:#include <WindowsX.h>
./Core/Debugger/SymbolMap.cpp:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP)
./Core/Debugger/WebSocket/DisasmSubscriber.cpp:	else if (l.type == DISTYPE_MACRO)
./Core/Debugger/WebSocket/DisasmSubscriber.cpp:		json.writeString("type", "macro");
./Core/Debugger/WebSocket/DisasmSubscriber.cpp:		json.pushArray("macroEncoding");
./Core/Debugger/WebSocket/DisasmSubscriber.cpp:		json.writeNull("macroEncoding");
./Core/Debugger/WebSocket/DisasmSubscriber.cpp:	// TODO: Account for bp inside macro?
./Core/Debugger/WebSocket/DisasmSubscriber.cpp://     - type: "opcode", "macro", "data", or "other".
./Core/Debugger/WebSocket/DisasmSubscriber.cpp://     - macroEncoding: null, or an array of encodings if this line represents multiple instructions.
./Core/Debugger/WebSocket/DisasmSubscriber.cpp:		// This accounts for macros as one line, although two instructions.
./Core/Debugger/WebSocket/DisasmSubscriber.cpp://  - encoding: resulting encoding at this address.  Always returns one value, even for macros.
./Core/Debugger/WebSocket/GPUBufferSubscriber.cpp:#ifndef USING_QT_UI
./Core/Debugger/WebSocket/GPUBufferSubscriber.cpp:#ifdef USING_QT_UI
./Core/Debugger/WebSocket/GPUBufferSubscriber.cpp:	req.Fail("Not supported on Qt yet, pull requests accepted");
./Core/Debugger/WebSocket/WebSocketUtils.h:#if PPSSPP_PLATFORM(UWP)
./Core/Debugger/WebSocket/WebSocketUtils.h:// Enum name overlapped with UWP macro, quick hack to disable it
./Core/Dialog/PSPOskDialog.cpp:#if defined(USING_WIN_UI) || defined(USING_QT_UI) || PPSSPP_PLATFORM(ANDROID)
./Core/Dialog/PSPOskDialog.cpp:#if defined(USING_WIN_UI) || defined(USING_QT_UI) || PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(SWITCH)
./Core/Dialog/PSPOskDialog.cpp:	// Windows: Fall back to the OSK/continue normally if we're in fullscreen.
./Core/Dialog/PSPSaveDialog.h:	enum SaveIOStatus {
./Core/Dialog/PSPSaveDialog.h:	volatile SaveIOStatus ioThreadStatus = SAVEIO_NONE;
./Core/Dialog/SavedataParam.cpp:	if (sceSdMacInit(ctx1, mode) < 0)
./Core/Dialog/SavedataParam.cpp:	if (sceSdMacUpdate(ctx1, data, 0x10) < 0)
./Core/Dialog/SavedataParam.cpp:	if (sceSdMacUpdate(ctx1, data + 0x10, *alignedLen) < 0)
./Core/Dialog/SavedataParam.cpp:	if (sceSdMacFinal(ctx1, hash, cryptkey) < 0)
./Core/Dialog/SavedataParam.cpp:	if (sceSdMacInit(ctx1, mode) < 0)
./Core/Dialog/SavedataParam.cpp:	if (sceSdMacUpdate(ctx1, data, 0x10) < 0)
./Core/Dialog/SavedataParam.cpp:	if (sceSdMacUpdate(ctx1, data + 0x10, *alignedLen) < 0)
./Core/Dialog/SavedataParam.cpp:		if (sceSdMacFinal(ctx1, hash, cryptkey) < 0)
./Core/Dialog/SavedataParam.cpp:	if (sceSdMacInit(ctx1, mode & 0xFF) < 0)
./Core/Dialog/SavedataParam.cpp:	if (sceSdMacUpdate(ctx1, data, alignedLen) < 0)
./Core/Dialog/SavedataParam.cpp:	if (sceSdMacFinal(ctx1, output, cryptkey) < 0)
./Core/ELF/ElfReader.h:	ElfMachine GetMachine() const { return (ElfMachine)(u16)(header->e_machine); }
./Core/ELF/PSPElfTypes.h:// Machine/Architecture
./Core/ELF/PSPElfTypes.h:enum ElfMachine
./Core/ELF/PSPElfTypes.h:#define EF_MIPS_MACH_MASK 0x00ff0000
./Core/ELF/PSPElfTypes.h:#define EF_MIPS_MACH_PSP  0x00a20000
./Core/ELF/PSPElfTypes.h:    Elf32_Half    e_machine;
./Core/FileLoaders/DiskCachingFileLoader.cpp:#include "Common/CommonWindows.h"
./Core/FileLoaders/DiskCachingFileLoader.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/FileLoaders/DiskCachingFileLoader.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/FileLoaders/LocalFileLoader.cpp:#include "Common/CommonWindows.h"
./Core/FileLoaders/LocalFileLoader.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/FileLoaders/LocalFileLoader.cpp:#ifdef HAVE_LIBRETRO_VFS
./Core/FileLoaders/LocalFileLoader.cpp:#if !defined(_WIN32) && !defined(HAVE_LIBRETRO_VFS)
./Core/FileLoaders/LocalFileLoader.cpp:#if HAVE_LIBRETRO_VFS
./Core/FileLoaders/LocalFileLoader.cpp:#if PPSSPP_PLATFORM(ANDROID) && !defined(HAVE_LIBRETRO_VFS)
./Core/FileLoaders/LocalFileLoader.cpp:#if defined(HAVE_LIBRETRO_VFS)
./Core/FileLoaders/LocalFileLoader.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/FileLoaders/LocalFileLoader.cpp:#if defined(HAVE_LIBRETRO_VFS)
./Core/FileLoaders/LocalFileLoader.cpp:#if defined(HAVE_LIBRETRO_VFS)
./Core/FileLoaders/LocalFileLoader.cpp:#if defined(HAVE_LIBRETRO_VFS)
./Core/FileLoaders/LocalFileLoader.h:#ifdef HAVE_LIBRETRO_VFS
./Core/FileLoaders/LocalFileLoader.h:#if !defined(_WIN32) && !defined(HAVE_LIBRETRO_VFS)
./Core/FileSystems/BlockDevices.cpp:	MAC_KEY mkey;
./Core/FileSystems/BlockDevices.cpp:	sceDrmBBMacInit(&mkey, 3);
./Core/FileSystems/BlockDevices.cpp:	sceDrmBBMacUpdate(&kirk_, &mkey, np_header, 0xc0);
./Core/FileSystems/BlockDevices.cpp:	bbmac_getkey(&kirk_, &mkey, np_header+0xc0, vkey);
./Core/FileSystems/BlockDevices.cpp:		// skip mac check
./Core/FileSystems/BlockDevices.h:	u8 mac[16];
./Core/FileSystems/DirectoryFileSystem.cpp:#include "Common/CommonWindows.h"
./Core/FileSystems/DirectoryFileSystem.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/FileSystems/DirectoryFileSystem.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Core/FileSystems/DirectoryFileSystem.cpp:	// Convert parameters to Windows permissions and access
./Core/FileSystems/DirectoryFileSystem.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/FileSystems/DirectoryFileSystem.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/FileSystems/DirectoryFileSystem.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/FileSystems/DirectoryFileSystem.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./Core/FileSystems/DirectoryFileSystem.cpp:#if !PPSSPP_PLATFORM(WINDOWS)
./Core/FileSystems/DirectoryFileSystem.cpp:// Windows NT VFAT optimizes valid DOS filenames that are in lowercase.
./Core/FileSystems/DirectoryFileSystem.cpp:// The PSP VFAT driver doesn't support this optimization, and behaves like Windows 98.
./Core/FileSystems/DirectoryFileSystem.cpp:// This essentially tries to simulate the "Windows 98 world view" on modern operating systems.
./Core/FileSystems/DirectoryFileSystem.cpp:	// Then apply transforms to match PSP idiosynchrasies, as we convert the entries.
./Core/FileSystems/DirectoryFileSystem.h:// TODO: Remove the Windows-specific code, FILE is fine there too.
./Core/FileSystems/ISOFileSystem.h:// Simply wrap around an ISOFileSystem which has all the necessary machinery, while changing
./Core/FileSystems/VirtualDiscFileSystem.cpp:#include "Common/CommonWindows.h"
./Core/FileSystems/VirtualDiscFileSystem.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/FileSystems/VirtualDiscFileSystem.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/FileSystems/VirtualDiscFileSystem.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/FileSystems/VirtualDiscFileSystem.cpp:#if !PPSSPP_PLATFORM(UWP) && !PPSSPP_PLATFORM(SWITCH)
./Core/FileSystems/VirtualDiscFileSystem.h:// TODO: Remove the Windows-specific code, FILE is fine there too.
./Core/FrameTiming.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Core/FrameTiming.cpp:		// Only FIFO mode is supported (like on iOS and some GLES backends).
./Core/HLE/AtracCtx2.cpp:// Windows\x64\debug\PPSSPPHeadless.exe  --root pspautotests/tests/../ -o --compare --new-atrac --timeout=30 --graphics=software pspautotests/tests/audio/atrac/stream.prx
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_REQUEST_FAILED              = 0x800202bc,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_REQUEST_DENIED              = 0x800202bd,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_QUEUED                   = 0x800202be,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_NOT_QUEUED               = 0x800202bf,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_RUNNING                  = 0x800202c0,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_NOT_ASSIGNED             = 0x800202c1,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_TIMEOUT                  = 0x800202c2,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_FREED                    = 0x800202c3,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_USED                     = 0x800202c4,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_EMPTY                    = 0x800202c5,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_ABORTED                  = 0x800202c6,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_ERROR                    = 0x800202c7,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_CHANNEL_RESERVED            = 0x800202c8,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_CHANNEL_EXCLUDED            = 0x800202c9,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_PRIVILEGE_ADDRESS           = 0x800202ca,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_NO_ENOUGHSPACE              = 0x800202cb,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_CHANNEL_NOT_ASSIGNED        = 0x800202cc,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_CHILD_OPERATION             = 0x800202cd,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_TOO_MUCH_SIZE               = 0x800202ce,
./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_INVALID_ARGUMENT            = 0x800202cf,
./Core/HLE/HLE.h:// Don't manually call this, it's called by the various syscall return macros.
./Core/HLE/HLETables.cpp:#include "sceDmac.h"
./Core/HLE/HLETables.cpp:	{"Pspnet_Show_MacAddr"},
./Core/HLE/HLETables.cpp:	Register_sceDmac();
./Core/HLE/NetInetConstants.cpp:		// FIXME: SOCK_RAW have some restrictions on newer Windows?
./Core/HLE/NetInetConstants.h:// Socket Types (based on https://github.com/justincormack/netbsd-src/blob/master/src/sys/sys/socket.h )
./Core/HLE/NetInetConstants.h:#define	PSP_NET_INET_SOCK_RAW			3			// raw-protocol interface // SOCK_RAW is similar to but not compatible with the obsolete AF_INET / SOCK_PACKET // SOCK_RAW have some restrictions on newer Windows https://docs.microsoft.com/en-us/windows/win32/winsock/tcp-ip-raw-sockets-2
./Core/HLE/NetInetConstants.h:#define PSP_NET_INET_SOCK_PACKET		10			// Linux specific way of getting packets at the dev level. For writing rarp and other similar things on the user level // SOCK_PACKET is an obsolete socket type to receive raw packets directly from the device driver
./Core/HLE/NetInetConstants.h:// Option flags per-socket (based on SOL_SOCKET value on PSP (0xffff) seems to be different with linux/android's auto-generated socket.h (1), but similar to posix/gnu/BSD <sys/socket.h> like this https://github.com/eblot/newlib/blob/master/newlib/libc/sys/linux/sys/socket.h ?)
./Core/HLE/NetInetConstants.h:#define ERROR_INET_ESOCKTNOSUPPORT	124	// Socket type not supported (linux?)
./Core/HLE/ReplaceTables.h:// own parameter parsing using the old school PARAM macros.
./Core/HLE/ThreadQueueList.h:		// Start smack in the middle so it can move both directions.
./Core/HLE/__sceAudio.cpp:void __AudioShutdown() {
./Core/HLE/__sceAudio.cpp:void __AudioSetOutputFrequency(int freq) {
./Core/HLE/__sceAudio.cpp:void __AudioSetSRCFrequency(int freq) {
./Core/HLE/__sceAudio.h:void __AudioShutdown();
./Core/HLE/__sceAudio.h:void __AudioSetOutputFrequency(int freq);
./Core/HLE/__sceAudio.h:void __AudioSetSRCFrequency(int freq);
./Core/HLE/proAdhoc.cpp:std::vector<SceNetEtherAddr> requiredGameModeMacs;
./Core/HLE/proAdhoc.cpp:std::vector<SceNetEtherAddr> gameModeMacs;
./Core/HLE/proAdhoc.cpp:// Broadcast MAC
./Core/HLE/proAdhoc.cpp:uint8_t broadcastMAC[ETHER_ADDR_LEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
./Core/HLE/proAdhoc.cpp:bool isMacMatch(const SceNetEtherAddr* addr1, const SceNetEtherAddr* addr2) {
./Core/HLE/proAdhoc.cpp:bool isLocalMAC(const SceNetEtherAddr * addr) {
./Core/HLE/proAdhoc.cpp:	getLocalMac(&saddr);
./Core/HLE/proAdhoc.cpp:	return isMacMatch(addr, &saddr);
./Core/HLE/proAdhoc.cpp:bool isPTPPortInUse(uint16_t port, bool forListen, SceNetEtherAddr* dstmac, uint16_t dstport) {
./Core/HLE/proAdhoc.cpp:			// It's allowed to Listen and Open the same PTP port, But it's not allowed to Listen or Open the same PTP port twice (unless destination mac or port are different).
./Core/HLE/proAdhoc.cpp:			      sock->data.ptp.pport == dstport && dstmac != nullptr && isMacMatch(&sock->data.ptp.paddr, dstmac)))) 
./Core/HLE/proAdhoc.cpp:std::string mac2str(const SceNetEtherAddr *mac) {
./Core/HLE/proAdhoc.cpp:	if (mac != NULL) {
./Core/HLE/proAdhoc.cpp:		snprintf(str, sizeof(str), "%02x:%02x:%02x:%02x:%02x:%02x", mac->data[0], mac->data[1], mac->data[2], mac->data[3], mac->data[4], mac->data[5]);
./Core/HLE/proAdhoc.cpp:SceNetAdhocMatchingMemberInternal* addMember(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac) {
./Core/HLE/proAdhoc.cpp:	if (context == NULL || mac == NULL) return NULL;
./Core/HLE/proAdhoc.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, mac);
./Core/HLE/proAdhoc.cpp:		WARN_LOG(Log::sceNet, "Member Peer Already Existed! Updating [%s]", mac2str(mac).c_str());
./Core/HLE/proAdhoc.cpp:			peer->mac = *mac;
./Core/HLE/proAdhoc.cpp:	SceNetAdhocctlPeerInfo * peer = findFriend(&packet->mac);
./Core/HLE/proAdhoc.cpp:		WARN_LOG(Log::sceNet, "Friend Peer Already Existed! Updating [%s][%s][%s]", mac2str(&packet->mac).c_str(), ip2str(*(struct in_addr*)&tmpip).c_str(), packet->name.data); //inet_ntoa(*(in_addr*)&packet->ip)
./Core/HLE/proAdhoc.cpp:		peer->mac_addr = packet->mac;
./Core/HLE/proAdhoc.cpp:			// Save MAC Address
./Core/HLE/proAdhoc.cpp:			peer->mac_addr = packet->mac;
./Core/HLE/proAdhoc.cpp:SceNetAdhocctlPeerInfo * findFriend(SceNetEtherAddr * MAC) {
./Core/HLE/proAdhoc.cpp:	if (MAC == NULL) return NULL;
./Core/HLE/proAdhoc.cpp:		if (isMacMatch(&peer->mac_addr, MAC)) break;
./Core/HLE/proAdhoc.cpp:	// Avoid getting Fatal signal 6 (SIGABRT) on linux/android
./Core/HLE/proAdhoc.cpp:	// Note: select will flags an unconnected TCP socket (ie. a freshly created socket without connecting first, or when connect failed with ECONNREFUSED on linux) as writeable/readable, thus can't be used to tell whether the connection has established or not.
./Core/HLE/proAdhoc.cpp:	for (; group != NULL && (!excludeSelf || !isLocalMAC(&group->bssid.mac_addr)); group = group->next) count++;
./Core/HLE/proAdhoc.cpp:SceNetAdhocctlScanInfo * findGroup(SceNetEtherAddr * MAC) {
./Core/HLE/proAdhoc.cpp:	if (MAC == NULL) return NULL;
./Core/HLE/proAdhoc.cpp:		if (isMacMatch(&group->bssid.mac_addr, MAC)) break;
./Core/HLE/proAdhoc.cpp:	gameModeMacs.clear();
./Core/HLE/proAdhoc.cpp:	requiredGameModeMacs.clear();
./Core/HLE/proAdhoc.cpp:			INFO_LOG(Log::sceNet, "Removing Friend Peer %s [%s]", mac2str(&peer->mac_addr).c_str(), ip2str(*(struct in_addr *)&tmpip).c_str()); //inet_ntoa(*(in_addr*)&peer->ip_addr)
./Core/HLE/proAdhoc.cpp:* @param siblings Sibling MAC Array
./Core/HLE/proAdhoc.cpp:	// Cast Sibling MAC Array to uint8_t
./Core/HLE/proAdhoc.cpp:		SceNetEtherAddr* mac = (SceNetEtherAddr*)(siblings_u8 + sizeof(SceNetEtherAddr) * i);
./Core/HLE/proAdhoc.cpp:		auto peer = findPeer(context, mac);
./Core/HLE/proAdhoc.cpp:			WARN_LOG(Log::sceNet, "Updating Sibling Peer %s", mac2str(mac).c_str());
./Core/HLE/proAdhoc.cpp:				// Save MAC Address
./Core/HLE/proAdhoc.cpp:				memcpy(&sibling->mac, mac, sizeof(SceNetEtherAddr));
./Core/HLE/proAdhoc.cpp:				//spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_ESTABLISHED, &sibling->mac, 0, NULL);
./Core/HLE/proAdhoc.cpp:				INFO_LOG(Log::sceNet, "Accepting Sibling Peer %s", mac2str(&sibling->mac).c_str());
./Core/HLE/proAdhoc.cpp:* Find Peer in Context by MAC
./Core/HLE/proAdhoc.cpp:* @param mac Peer MAC Address
./Core/HLE/proAdhoc.cpp:SceNetAdhocMatchingMemberInternal * findPeer(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac)
./Core/HLE/proAdhoc.cpp:	if (mac == NULL)
./Core/HLE/proAdhoc.cpp:		if (isMacMatch(&peer->mac, mac))
./Core/HLE/proAdhoc.cpp:			INFO_LOG(Log::sceNet, "Removing Member Peer %s", mac2str(&peer->mac).c_str());
./Core/HLE/proAdhoc.cpp:* @param mac Target MAC
./Core/HLE/proAdhoc.cpp:void sendGenericMessage(SceNetAdhocMatchingContext * context, int stack, SceNetEtherAddr * mac, int opcode, int optlen, const void * opt)
./Core/HLE/proAdhoc.cpp:		// Set Peer MAC Address
./Core/HLE/proAdhoc.cpp:		header->mac = *mac;
./Core/HLE/proAdhoc.cpp:	auto peer = findPeer(context, mac);
./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_INPUT_STACK, &peer->mac, PSP_ADHOC_MATCHING_PACKET_ACCEPT, optlen, opt);
./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_INPUT_STACK, &peer->mac, PSP_ADHOC_MATCHING_PACKET_JOIN, optlen, opt);
./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_INPUT_STACK, &peer->mac, PSP_ADHOC_MATCHING_PACKET_CANCEL, optlen, opt);
./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_INPUT_STACK, &peer->mac, PSP_ADHOC_MATCHING_PACKET_BULK, datalen, data);
./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_INPUT_STACK, &peer->mac, PSP_ADHOC_MATCHING_PACKET_BULK_ABORT, 0, NULL);
./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_INPUT_STACK, &peer->mac, PSP_ADHOC_MATCHING_PACKET_BIRTH, 0, NULL);
./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_INPUT_STACK, &peer->mac, PSP_ADHOC_MATCHING_PACKET_DEATH, 0, NULL);
./Core/HLE/proAdhoc.cpp:* @param mac Event Source MAC
./Core/HLE/proAdhoc.cpp:void spawnLocalEvent(SceNetAdhocMatchingContext * context, int event, SceNetEtherAddr * mac, int optlen, void * opt)
./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_EVENT_STACK, mac, event, optlen, opt);
./Core/HLE/proAdhoc.cpp:				spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_TIMEOUT, &peer->mac, 0, NULL);
./Core/HLE/proAdhoc.cpp:				INFO_LOG(Log::sceNet, "TimedOut Member Peer %s (%lld - %lld = %lld > %lld us)", mac2str(&peer->mac).c_str(), now, peer->lastping, (now - peer->lastping), context->timeout);
./Core/HLE/proAdhoc.cpp:	DEBUG_LOG(Log::sceNet, "AfterMatchingMipsCall::run [ID=%i][Event=%d][%s] [cbId: %u][retV0: %08x]", contextID, EventID, mac2str((SceNetEtherAddr*)Memory::GetPointer(bufAddr)).c_str(), call.cbId, v0);
./Core/HLE/proAdhoc.cpp:				// Send Ping to Server, may failed with socket error 10054/10053 if someone else with the same IP already connected to AdHoc Server (the server might need to be modified to differentiate MAC instead of IP)
./Core/HLE/proAdhoc.cpp:						INFO_LOG(Log::sceNet, "FriendFinder: Incoming OPCODE_CONNECT_BSSID [%s]", mac2str(&packet->mac).c_str());
./Core/HLE/proAdhoc.cpp:						parameter.bssid.mac_addr = packet->mac; // This packet seems to contains Adhoc Group Creator's BSSID (similar to AP's BSSID) so it shouldn't get mixed up with local MAC address. Note: On JPCSP + prx files params.bssid is hardcoded to "Jpcsp\0" and doesn't match to any of player's mac
./Core/HLE/proAdhoc.cpp:							SceNetEtherAddr localMac;
./Core/HLE/proAdhoc.cpp:							getLocalMac(&localMac);
./Core/HLE/proAdhoc.cpp:							if (std::find_if(gameModeMacs.begin(), gameModeMacs.end(),
./Core/HLE/proAdhoc.cpp:								[localMac](SceNetEtherAddr const& e) {
./Core/HLE/proAdhoc.cpp:									return isMacMatch(&e, &localMac);
./Core/HLE/proAdhoc.cpp:								}) == gameModeMacs.end()) {
./Core/HLE/proAdhoc.cpp:								gameModeMacs.push_back(localMac);
./Core/HLE/proAdhoc.cpp:								if (netAdhocGameModeEntered && gameModeMacs.size() >= requiredGameModeMacs.size()) {
./Core/HLE/proAdhoc.cpp:								WARN_LOG(Log::sceNet, "GameMode SelfMember [%s] Already Existed!", mac2str(&localMac).c_str());
./Core/HLE/proAdhoc.cpp:						INFO_LOG(Log::sceNet, "FriendFinder: Incoming OPCODE_CONNECT [%s][%s][%s]", mac2str(&packet->mac).c_str(), ip2str(*(in_addr*)&ipaddr).c_str(), packet->name.data);
./Core/HLE/proAdhoc.cpp:						// Make sure GameMode participants are all joined (including self MAC)
./Core/HLE/proAdhoc.cpp:							if (std::find_if(gameModeMacs.begin(), gameModeMacs.end(),
./Core/HLE/proAdhoc.cpp:									return isMacMatch(&e, &packet->mac);
./Core/HLE/proAdhoc.cpp:								}) == gameModeMacs.end()) {
./Core/HLE/proAdhoc.cpp:								SceNetEtherAddr localMac;
./Core/HLE/proAdhoc.cpp:								getLocalMac(&localMac);
./Core/HLE/proAdhoc.cpp:								auto it = std::find_if(gameModeMacs.begin(), gameModeMacs.end(),
./Core/HLE/proAdhoc.cpp:									[localMac](SceNetEtherAddr const& e) {
./Core/HLE/proAdhoc.cpp:										return isMacMatch(&e, &localMac);
./Core/HLE/proAdhoc.cpp:								if (it != gameModeMacs.end()) {
./Core/HLE/proAdhoc.cpp:									gameModeMacs.push_back(packet->mac);
./Core/HLE/proAdhoc.cpp:									it = gameModeMacs.begin() + 1;
./Core/HLE/proAdhoc.cpp:									gameModeMacs.insert(it, packet->mac);
./Core/HLE/proAdhoc.cpp:								// From JPCSP: Join complete when all the required MACs have joined
./Core/HLE/proAdhoc.cpp:								if (netAdhocGameModeEntered && requiredGameModeMacs.size() > 0 && gameModeMacs.size() == requiredGameModeMacs.size()) {
./Core/HLE/proAdhoc.cpp:									// TODO: Should we replace gameModeMacs contents with requiredGameModeMacs contents to make sure they are in the same order with macs from sceNetAdhocctlCreateEnterGameMode? But may not be consistent with the list on client side!
./Core/HLE/proAdhoc.cpp:									//gameModeMacs = requiredGameModeMacs;
./Core/HLE/proAdhoc.cpp:								WARN_LOG(Log::sceNet, "GameMode Member [%s] Already Existed!", mac2str(&packet->mac).c_str());
./Core/HLE/proAdhoc.cpp:								if (isMacMatch(&gma.mac, &peer->mac_addr)) {
./Core/HLE/proAdhoc.cpp:						// Delete User by IP, should delete by MAC since IP can be shared (behind NAT) isn't?
./Core/HLE/proAdhoc.cpp:							group->bssid.mac_addr = packet->mac;
./Core/HLE/proAdhoc.cpp:void getLocalMac(SceNetEtherAddr * addr){
./Core/HLE/proAdhoc.cpp:	// Read MAC Address from config
./Core/HLE/proAdhoc.cpp:	uint8_t mac[ETHER_ADDR_LEN] = {0};
./Core/HLE/proAdhoc.cpp:		memset(&mac, PPSSPP_ID, sizeof(mac));
./Core/HLE/proAdhoc.cpp:		mac[0] &= 0xfc;
./Core/HLE/proAdhoc.cpp:	if (!ParseMacAddress(g_Config.sMACAddress, mac)) {
./Core/HLE/proAdhoc.cpp:		ERROR_LOG(Log::sceNet, "Error parsing mac address %s", g_Config.sMACAddress.c_str());
./Core/HLE/proAdhoc.cpp:		memset(&mac, 0, sizeof(mac));
./Core/HLE/proAdhoc.cpp:	memcpy(addr, mac, ETHER_ADDR_LEN);
./Core/HLE/proAdhoc.cpp:		// TODO: May need to filter out packets from an IP that can't be translated to MAC address
./Core/HLE/proAdhoc.cpp:	if (timeout_usec > 0 && optval == 0) optval = 1; // Since there are games that use 100 usec timeout, we should set it to minimum value on Windows (1 msec) instead of using 0 (0 = indefinitely timeout)
./Core/HLE/proAdhoc.cpp:	// Set SIGPIPE when supported (ie. BSD/MacOS X)
./Core/HLE/proAdhoc.cpp:	// Note: Linux might have SO_NOSIGPIPE defined too, but using it on setsockopt will result to EINVAL error
./Core/HLE/proAdhoc.cpp:	// On Windows: Connection Reset error on UDP could cause a strange behavior https://stackoverflow.com/questions/34242622/windows-udp-sockets-recvfrom-fails-with-error-10054
./Core/HLE/proAdhoc.cpp:#define TCP_KEEPIDLE	TCP_KEEPALIVE //TCP_KEEPIDLE on Linux is equivalent to TCP_KEEPALIVE on macOS
./Core/HLE/proAdhoc.cpp:	// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./Core/HLE/proAdhoc.cpp:	//getLocalMac(&parameter.bssid.mac_addr);
./Core/HLE/proAdhoc.cpp:	getLocalMac(&addres);
./Core/HLE/proAdhoc.cpp:	packet.mac = addres;
./Core/HLE/proAdhoc.cpp:bool isZeroMAC(const SceNetEtherAddr* addr) {
./Core/HLE/proAdhoc.cpp:bool isBroadcastMAC(const SceNetEtherAddr * addr) {
./Core/HLE/proAdhoc.cpp:bool resolveIP(uint32_t ip, SceNetEtherAddr * mac) {
./Core/HLE/proAdhoc.cpp:		getLocalMac(mac);
./Core/HLE/proAdhoc.cpp:			*mac = peer->mac_addr;
./Core/HLE/proAdhoc.cpp:bool resolveMAC(SceNetEtherAddr* mac, uint32_t* ip, u16* port_offset) {
./Core/HLE/proAdhoc.cpp:	// Get Local MAC Address
./Core/HLE/proAdhoc.cpp:	SceNetEtherAddr localMac;
./Core/HLE/proAdhoc.cpp:	getLocalMac(&localMac);
./Core/HLE/proAdhoc.cpp:	// Local MAC Requested
./Core/HLE/proAdhoc.cpp:	if (isMacMatch(&localMac, mac)) {
./Core/HLE/proAdhoc.cpp:		if (isMacMatch(&peer->mac_addr, mac)) {
./Core/HLE/proAdhoc.h:// Broadcast MAC
./Core/HLE/proAdhoc.h:extern uint8_t broadcastMAC[ETHER_ADDR_LEN];
./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac_addr;
./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac_addr;
./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac_addr;
./Core/HLE/proAdhoc.h:	SceNetEtherAddr mac_addr;
./Core/HLE/proAdhoc.h:	SceNetEtherAddr mac_addr;
./Core/HLE/proAdhoc.h:	SceNetEtherAddr mac;
./Core/HLE/proAdhoc.h:  // MAC Address
./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac;
./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac; // peer //u32_le macaddr;
./Core/HLE/proAdhoc.h:  // Target MAC Address
./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac;
./Core/HLE/proAdhoc.h:  // Local MAC Address
./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac;
./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac;
./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac;
./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac;
./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac;
./Core/HLE/proAdhoc.h:	SceNetEtherAddr fromMAC;
./Core/HLE/proAdhoc.h:	SceNetEtherAddr toMAC;
./Core/HLE/proAdhoc.h:	u32_le numMACs; //number of peers
./Core/HLE/proAdhoc.h:	/*u32_le*/PSPPointer<SceNetEtherAddr> MACsPtr; //peers //SceNetEtherAddr * MACs
./Core/HLE/proAdhoc.h:extern std::vector<SceNetEtherAddr> requiredGameModeMacs;
./Core/HLE/proAdhoc.h:extern std::vector<SceNetEtherAddr> gameModeMacs;
./Core/HLE/proAdhoc.h: * Compare MAC Addresses
./Core/HLE/proAdhoc.h: * @param addr1 & addr2 To-be-compared MAC Address
./Core/HLE/proAdhoc.h:bool isMacMatch(const SceNetEtherAddr* addr1, const SceNetEtherAddr* addr2);
./Core/HLE/proAdhoc.h: * Local MAC Check
./Core/HLE/proAdhoc.h: * @param saddr To-be-checked MAC Address
./Core/HLE/proAdhoc.h: * @return True if it's local mac
./Core/HLE/proAdhoc.h:bool isLocalMAC(const SceNetEtherAddr * addr);
./Core/HLE/proAdhoc.h: * @param dstmac destination address (non-listening only)
./Core/HLE/proAdhoc.h:bool isPTPPortInUse(uint16_t port, bool forListen, SceNetEtherAddr* dstmac = nullptr, uint16_t dstport = 0);
./Core/HLE/proAdhoc.h:// Convert MAC address to string
./Core/HLE/proAdhoc.h:std::string mac2str(const SceNetEtherAddr *mac);
./Core/HLE/proAdhoc.h://SceNetAdhocMatchingMemberInternal* findMember(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac); // findPeer
./Core/HLE/proAdhoc.h:SceNetAdhocMatchingMemberInternal* addMember(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac);
./Core/HLE/proAdhoc.h://void deleteMember(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac); // deletePeer
./Core/HLE/proAdhoc.h: * Find a Peer/Friend by MAC address
./Core/HLE/proAdhoc.h:SceNetAdhocctlPeerInfo * findFriend(SceNetEtherAddr * MAC);
./Core/HLE/proAdhoc.h:SceNetAdhocctlScanInfo * findGroup(SceNetEtherAddr * MAC);
./Core/HLE/proAdhoc.h:* Find Peer in Context by MAC
./Core/HLE/proAdhoc.h:* @param mac Peer MAC Address
./Core/HLE/proAdhoc.h:SceNetAdhocMatchingMemberInternal * findPeer(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac);
./Core/HLE/proAdhoc.h:* @param mac Event Source MAC
./Core/HLE/proAdhoc.h:void spawnLocalEvent(SceNetAdhocMatchingContext * context, int event, SceNetEtherAddr * mac, int optlen, void * opt);
./Core/HLE/proAdhoc.h: * Returns the locall Ip of this machine
./Core/HLE/proAdhoc.h: * Returns the local mac
./Core/HLE/proAdhoc.h: * @param addr OUT: 6-bytes of Local Mac
./Core/HLE/proAdhoc.h:void getLocalMac(SceNetEtherAddr * addr);
./Core/HLE/proAdhoc.h: * Zero MAC Check
./Core/HLE/proAdhoc.h: * @param addr To-be-checked MAC Address
./Core/HLE/proAdhoc.h: * @return true if MAC is all zeroes
./Core/HLE/proAdhoc.h:bool isZeroMAC(const SceNetEtherAddr* addr);
./Core/HLE/proAdhoc.h: * Broadcast MAC Check
./Core/HLE/proAdhoc.h: * @param addr To-be-checked MAC Address
./Core/HLE/proAdhoc.h: * @return true if Broadcast MAC or... 0
./Core/HLE/proAdhoc.h:bool isBroadcastMAC(const SceNetEtherAddr * addr);
./Core/HLE/proAdhoc.h: * Resolve IP to MAC
./Core/HLE/proAdhoc.h: * @param mac OUT: Peer MAC
./Core/HLE/proAdhoc.h:bool resolveIP(uint32_t ip, SceNetEtherAddr * mac);
./Core/HLE/proAdhoc.h: * Resolve MAC to IP
./Core/HLE/proAdhoc.h: * @param mac Peer MAC Address
./Core/HLE/proAdhoc.h:bool resolveMAC(SceNetEtherAddr* mac, uint32_t* ip, u16* port_offset = nullptr);
./Core/HLE/proAdhocServer.cpp:	{ "ULES00368", "Micro Machines V4" },
./Core/HLE/proAdhocServer.cpp:	{ "ULUS10543", "WWE Smackdown vs. Raw 2011" },
./Core/HLE/proAdhocServer.cpp:	if(valid_product_code == 1 && memcmp(&data->mac, "\xFF\xFF\xFF\xFF\xFF\xFF", sizeof(data->mac)) != 0 && memcmp(&data->mac, "\x00\x00\x00\x00\x00\x00", sizeof(data->mac)) != 0 && data->name.data[0] != 0)
./Core/HLE/proAdhocServer.cpp:		// Check for duplicated MAC as most games identify Players by MAC
./Core/HLE/proAdhocServer.cpp:		while (u != NULL && !IsMatch(u->resolver.mac, data->mac)) u = u->next;
./Core/HLE/proAdhocServer.cpp:		if (u != NULL) { // MAC Already existed
./Core/HLE/proAdhocServer.cpp:			WARN_LOG(Log::sceNet, "AdhocServer: Already Existing MAC: %s [%s]\n", mac2str(&data->mac).c_str(), ip2str(*(in_addr*)&u->resolver.ip).c_str());
./Core/HLE/proAdhocServer.cpp:			// Save MAC
./Core/HLE/proAdhocServer.cpp:			user->resolver.mac = data->mac;
./Core/HLE/proAdhocServer.cpp:			INFO_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) started playing %s", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr);
./Core/HLE/proAdhocServer.cpp:		INFO_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) stopped playing %s", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr);
./Core/HLE/proAdhocServer.cpp:			bssid.mac = user->resolver.mac;
./Core/HLE/proAdhocServer.cpp:					// Set Player MAC
./Core/HLE/proAdhocServer.cpp:					packet.mac = user->resolver.mac;
./Core/HLE/proAdhocServer.cpp:					// Set Player MAC
./Core/HLE/proAdhocServer.cpp:					packet.mac = peer->resolver.mac;
./Core/HLE/proAdhocServer.cpp:					if(peer->group_next == NULL) bssid.mac = peer->resolver.mac;
./Core/HLE/proAdhocServer.cpp:				INFO_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) joined %s group %s", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr, safegroupstr);
./Core/HLE/proAdhocServer.cpp:			WARN_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) attempted to join %s group %s without disconnecting from %s first", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr, safegroupstr, safegroupstr2);
./Core/HLE/proAdhocServer.cpp:		WARN_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) attempted to join invalid %s group %s", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr, safegroupstr);
./Core/HLE/proAdhocServer.cpp:		INFO_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) left %s group %s", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr, safegroupstr);
./Core/HLE/proAdhocServer.cpp:		WARN_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) attempted to leave %s group without joining one first", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr);
./Core/HLE/proAdhocServer.cpp:					// Set Group Host MAC
./Core/HLE/proAdhocServer.cpp:					packet.mac = peer->resolver.mac;
./Core/HLE/proAdhocServer.cpp:		INFO_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) requested information on %d %s groups", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), user->game->groupcount, safegamestr);
./Core/HLE/proAdhocServer.cpp:		WARN_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) attempted to scan for %s groups without disconnecting from %s first", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr, safegroupstr);
./Core/HLE/proAdhocServer.cpp:			INFO_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) sent \"%s\" to %d players in %s group %s", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), message, counter, safegamestr, safegroupstr);
./Core/HLE/proAdhocServer.cpp:		WARN_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) attempted to send a text message without joining a %s group first", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr);
./Core/HLE/proAdhocServer.cpp:		// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./Core/HLE/proAdhocServer.cpp:				// Alternative Accept Approach (some Linux Kernel don't support the accept4 Syscall... wtf?)
./Core/HLE/proAdhocServer.cpp:						WARN_LOG(Log::sceNet, "AdhocServer: Invalid Opcode 0x%02X in Logged-In State from %s (MAC: %s - IP: %s)", user->rx[0], (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str());
./Core/HLE/proAdhocServer.h:// Ethernet Address (MAC)
./Core/HLE/proAdhocServer.h:	SceNetEtherAddr mac;
./Core/HLE/proAdhocServer.h:	SceNetEtherAddr mac;
./Core/HLE/proAdhocServer.h:	SceNetEtherAddr mac;
./Core/HLE/proAdhocServer.h:	SceNetEtherAddr mac;
./Core/HLE/proAdhocServer.h:	// PSP MAC Address
./Core/HLE/proAdhocServer.h:	SceNetEtherAddr mac;
./Core/HLE/sceAudio.cpp:static u32 sceAudioSetChannelDataLen(u32 chan, u32 len) {
./Core/HLE/sceAudio.cpp:	__AudioSetSRCFrequency(0);
./Core/HLE/sceAudio.cpp:static u32 sceAudioSetFrequency(u32 freq) {
./Core/HLE/sceAudio.cpp:		INFO_LOG(Log::sceAudio, "sceAudioSetFrequency(%08x)", freq);
./Core/HLE/sceAudio.cpp:		__AudioSetOutputFrequency(freq);
./Core/HLE/sceAudio.cpp:		ERROR_LOG(Log::sceAudio, "sceAudioSetFrequency(%08x) - invalid frequency (must be 44.1 or 48 khz)", freq);
./Core/HLE/sceAudio.cpp:static u32 sceAudioSetVolumeOffset() {
./Core/HLE/sceAudio.cpp:	ERROR_LOG(Log::sceAudio, "UNIMPL sceAudioSetVolumeOffset()");
./Core/HLE/sceAudio.cpp:static u32 sceAudioSRCChReserve(u32 sampleCount, u32 freq, u32 format) {
./Core/HLE/sceAudio.cpp:	__AudioSetSRCFrequency(freq);
./Core/HLE/sceAudio.cpp:static u32 sceAudioSRCChRelease() {
./Core/HLE/sceAudio.cpp:static u32 sceAudioSRCOutputBlocking(u32 vol, u32 buf) {
./Core/HLE/sceAudio.cpp:	{0XA2BEAA6C, &WrapU_U<sceAudioSetFrequency>,            "sceAudioSetFrequency",          'x', "i"   },
./Core/HLE/sceAudio.cpp:	{0X927AC32B, &WrapU_V<sceAudioSetVolumeOffset>,         "sceAudioSetVolumeOffset",       'x', ""    },
./Core/HLE/sceAudio.cpp:	{0XCB2E439E, &WrapU_UU<sceAudioSetChannelDataLen>,      "sceAudioSetChannelDataLen",     'x', "ii"  },
./Core/HLE/sceAudio.cpp:	{0X38553111, &WrapU_UUU<sceAudioSRCChReserve>,          "sceAudioSRCChReserve",          'x', "iii" },
./Core/HLE/sceAudio.cpp:	{0X5C37C0AE, &WrapU_V<sceAudioSRCChRelease>,            "sceAudioSRCChRelease",          'x', ""    },
./Core/HLE/sceAudio.cpp:	{0XE0727056, &WrapU_UU<sceAudioSRCOutputBlocking>,      "sceAudioSRCOutputBlocking",     'x', "xx"  },
./Core/HLE/sceAudiocodec.cpp:// g_audioDecoderContexts is to store current playing audios.
./Core/HLE/sceChnnlsv.cpp:	return hleLogDebug(Log::sceMisc, sceSdMacFinal(*ctx, hash, Memory::GetPointerWrite(addressKey)));
./Core/HLE/sceChnnlsv.cpp:int sceSdMacFinal(pspChnnlsvContext1& ctx, u8* in_hash, const u8* in_key)
./Core/HLE/sceChnnlsv.cpp:	sceSdMacInit(ctx, 0);
./Core/HLE/sceChnnlsv.cpp:	return hleLogDebug(Log::sceMisc, sceSdMacInit(*ctx, value));
./Core/HLE/sceChnnlsv.cpp:int sceSdMacInit(pspChnnlsvContext1& ctx, int value)
./Core/HLE/sceChnnlsv.cpp:	return hleLogDebug(Log::sceMisc, sceSdMacUpdate(*ctx, Memory::GetPointerWrite(addressData), length));
./Core/HLE/sceChnnlsv.cpp:int sceSdMacUpdate(pspChnnlsvContext1& ctx, const u8* data, int length)
./Core/HLE/sceChnnlsv.h:int sceSdMacInit(pspChnnlsvContext1& ctx, int value);
./Core/HLE/sceChnnlsv.h:int sceSdMacUpdate(pspChnnlsvContext1& ctx, const u8* data, int length);
./Core/HLE/sceChnnlsv.h:int sceSdMacFinal(pspChnnlsvContext1& ctx, u8* in_hash, const u8* in_key);
./Core/HLE/sceDmac.cpp:#include "Core/HLE/sceDmac.h"
./Core/HLE/sceDmac.cpp:u64 dmacMemcpyDeadline;
./Core/HLE/sceDmac.cpp:void __DmacInit() {
./Core/HLE/sceDmac.cpp:	dmacMemcpyDeadline = 0;
./Core/HLE/sceDmac.cpp:void __DmacDoState(PointerWrap &p) {
./Core/HLE/sceDmac.cpp:	auto s = p.Section("sceDmac", 0, 1);
./Core/HLE/sceDmac.cpp:		dmacMemcpyDeadline = 0;
./Core/HLE/sceDmac.cpp:	Do(p, dmacMemcpyDeadline);
./Core/HLE/sceDmac.cpp:static int __DmacMemcpy(u32 dst, u32 src, u32 size) {
./Core/HLE/sceDmac.cpp:			NotifyMemInfoCopy(dst, src, size, "DmacMemcpy/");
./Core/HLE/sceDmac.cpp:		dmacMemcpyDeadline = CoreTiming::GetTicks() + usToCycles(delayUs);
./Core/HLE/sceDmac.cpp:static u32 sceDmacMemcpy(u32 dst, u32 src, u32 size) {
./Core/HLE/sceDmac.cpp:	if (dmacMemcpyDeadline > CoreTiming::GetTicks()) {
./Core/HLE/sceDmac.cpp:		WARN_LOG(Log::HLE, "sceDmacMemcpy(dest=%08x, src=%08x, size=%d): overlapping read", dst, src, size);
./Core/HLE/sceDmac.cpp:	int delay = __DmacMemcpy(dst, src, size);
./Core/HLE/sceDmac.cpp:	return delay ? hleDelayResult(result, "dmac-memcpy", delay) : delay;
./Core/HLE/sceDmac.cpp:static u32 sceDmacTryMemcpy(u32 dst, u32 src, u32 size) {
./Core/HLE/sceDmac.cpp:	if (dmacMemcpyDeadline > CoreTiming::GetTicks()) {
./Core/HLE/sceDmac.cpp:	int delay = __DmacMemcpy(dst, src, size);
./Core/HLE/sceDmac.cpp:	return delay ? hleDelayResult(result, "dmac-memcpy", delay) : delay;
./Core/HLE/sceDmac.cpp:const HLEFunction sceDmac[] = {
./Core/HLE/sceDmac.cpp:	{0X617F3FE6, &WrapU_UUU<sceDmacMemcpy>,          "sceDmacMemcpy",    'x', "xxx"},
./Core/HLE/sceDmac.cpp:	{0XD97F94D8, &WrapU_UUU<sceDmacTryMemcpy>,       "sceDmacTryMemcpy", 'x', "xxx"},
./Core/HLE/sceDmac.cpp:void Register_sceDmac() {
./Core/HLE/sceDmac.cpp:	RegisterHLEModule("sceDmac", ARRAY_SIZE(sceDmac), sceDmac);
./Core/HLE/sceDmac.h:void __DmacInit();
./Core/HLE/sceDmac.h:void __DmacDoState(PointerWrap &p);
./Core/HLE/sceDmac.h:void Register_sceDmac();
./Core/HLE/sceGe.cpp:		DLResult result = gpu->ProcessDLQueue();
./Core/HLE/sceGe.cpp:			DLResult result = gpu->ProcessDLQueue();
./Core/HLE/sceGe.cpp:			gpu->ProcessDLQueue();
./Core/HLE/sceGe.cpp:			gpu->ProcessDLQueue();
./Core/HLE/sceGe.cpp:			gpu->ProcessDLQueue();
./Core/HLE/sceGe.cpp:			gpu->ProcessDLQueue();
./Core/HLE/sceIo.cpp:struct SceIoStat {
./Core/HLE/sceIo.cpp:	SceIoStat d_stat;
./Core/HLE/sceIo.cpp:static void __IoSyncNotify(u64 userdata, int cyclesLate) {
./Core/HLE/sceIo.cpp:		ERROR_LOG_REPORT(Log::sceIo, "__IoSyncNotify: file no longer exists?");
./Core/HLE/sceIo.cpp:	syncNotifyEvent = CoreTiming::RegisterEvent("IoSyncNotify", __IoSyncNotify);
./Core/HLE/sceIo.cpp:	CoreTiming::RestoreRegisterEvent(syncNotifyEvent, "IoSyncNotify", __IoSyncNotify);
./Core/HLE/sceIo.cpp:void __IoShutdown() {
./Core/HLE/sceIo.cpp:static void IoStartAsyncThread(int id, FileNode *f) {
./Core/HLE/sceIo.cpp:static void __IoGetStat(SceIoStat *stat, PSPFileInfo &info) {
./Core/HLE/sceIo.cpp:	memset(stat, 0xfe, sizeof(SceIoStat));
./Core/HLE/sceIo.cpp:static void __IoSchedAsync(FileNode *f, int fd, int usec) {
./Core/HLE/sceIo.cpp:static void __IoSchedSync(FileNode *f, int fd, int usec) {
./Core/HLE/sceIo.cpp:	auto stat = PSPPointer<SceIoStat>::Create(addr);
./Core/HLE/sceIo.cpp:static u32 sceIoChstat(const char *filename, u32 iostatptr, u32 changebits) {
./Core/HLE/sceIo.cpp:	auto iostat = PSPPointer<SceIoStat>::Create(iostatptr);
./Core/HLE/sceIo.cpp:	if (!iostat.IsValid())
./Core/HLE/sceIo.cpp:	ERROR_LOG(Log::sceIo, "UNIMPL sceIoChstat(%s, %08x, %08x)", filename, iostatptr, changebits);
./Core/HLE/sceIo.cpp:		ERROR_LOG_REPORT(Log::sceIo, "sceIoChstat: change mode to %03o requested", iostat->st_mode);
./Core/HLE/sceIo.cpp:		ERROR_LOG_REPORT(Log::sceIo, "sceIoChstat: change attr to %04x requested", iostat->st_attr);
./Core/HLE/sceIo.cpp:		ERROR_LOG_REPORT(Log::sceIo, "sceIoChstat: change modification time to %04d-%02d-%02d requested", iostat->st_m_time.year, iostat->st_m_time.month, iostat->st_m_time.day);
./Core/HLE/sceIo.cpp:		__IoSchedSync(f, id, us);
./Core/HLE/sceIo.cpp:		IoStartAsyncThread(id, f);
./Core/HLE/sceIo.cpp:		__IoSchedSync(f, id, us);
./Core/HLE/sceIo.cpp:		IoStartAsyncThread(id, f);
./Core/HLE/sceIo.cpp:		IoStartAsyncThread(id, f);
./Core/HLE/sceIo.cpp:		IoStartAsyncThread(id, f);
./Core/HLE/sceIo.cpp:static u32 sceIoSync(const char *devicename, int flag) {
./Core/HLE/sceIo.cpp:	IoStartAsyncThread(id, f);
./Core/HLE/sceIo.cpp:static u32 sceIoSetAsyncCallback(int id, u32 clbckId, u32 clbckArg) {
./Core/HLE/sceIo.cpp:	IoStartAsyncThread(fd, f);
./Core/HLE/sceIo.cpp:		IoStartAsyncThread(id, f);
./Core/HLE/sceIo.cpp:		__IoSchedAsync(f, id, us);
./Core/HLE/sceIo.cpp:	{0XA12A0514, &WrapU_IUU<sceIoSetAsyncCallback>,     "sceIoSetAsyncCallback",       'i', "ixx"   },
./Core/HLE/sceIo.cpp:	{0xAB96437F, &WrapU_CI<sceIoSync>,                  "sceIoSync",                   'i', "si"    },
./Core/HLE/sceIo.cpp:	{0xAB96437F, &WrapU_CI<sceIoSync>,                  "sceIoSync",                   'i', "si",     HLE_KERNEL_SYSCALL },
./Core/HLE/sceIo.cpp:	{0XA46785C9, nullptr,                               "sceKernelStdioSendChar",      '?', ""      },
./Core/HLE/sceIo.h:void __IoShutdown();
./Core/HLE/sceKernel.cpp:#include "sceDmac.h"
./Core/HLE/sceKernel.cpp:	__DmacInit();
./Core/HLE/sceKernel.cpp:	__AudioShutdown();
./Core/HLE/sceKernel.cpp:	__IoShutdown();
./Core/HLE/sceKernel.cpp:	{0X6D212BAC, &WrapI_IIU<sceKernelWaitSemaCB>,                    "sceKernelWaitSemaCB",                       'i', "iix",    HLE_NOT_IN_INTERRUPT | HLE_NOT_DISPATCH_SUSPENDED },
./Core/HLE/sceKernel.cpp:	case 0x800202bc: return "DMAC_REQUEST_FAILED";
./Core/HLE/sceKernel.cpp:	case 0x800202bd: return "DMAC_REQUEST_DENIED";
./Core/HLE/sceKernel.cpp:	case 0x800202be: return "DMAC_OP_QUEUED";
./Core/HLE/sceKernel.cpp:	case 0x800202bf: return "DMAC_OP_NOT_QUEUED";
./Core/HLE/sceKernel.cpp:	case 0x800202c0: return "DMAC_OP_RUNNING";
./Core/HLE/sceKernel.cpp:	case 0x800202c1: return "DMAC_OP_NOT_ASSIGNED";
./Core/HLE/sceKernel.cpp:	case 0x800202c2: return "DMAC_OP_TIMEOUT";
./Core/HLE/sceKernel.cpp:	case 0x800202c3: return "DMAC_OP_FREED";
./Core/HLE/sceKernel.cpp:	case 0x800202c4: return "DMAC_OP_USED";
./Core/HLE/sceKernel.cpp:	case 0x800202c5: return "DMAC_OP_EMPTY";
./Core/HLE/sceKernel.cpp:	case 0x800202c6: return "DMAC_OP_ABORTED";
./Core/HLE/sceKernel.cpp:	case 0x800202c7: return "DMAC_OP_ERROR";
./Core/HLE/sceKernel.cpp:	case 0x800202c8: return "DMAC_CHANNEL_RESERVED";
./Core/HLE/sceKernel.cpp:	case 0x800202c9: return "DMAC_CHANNEL_EXCLUDED";
./Core/HLE/sceKernel.cpp:	case 0x800202ca: return "DMAC_PRIVILEGE_ADDRESS";
./Core/HLE/sceKernel.cpp:	case 0x800202cb: return "DMAC_NO_ENOUGHSPACE";
./Core/HLE/sceKernel.cpp:	case 0x800202cc: return "DMAC_CHANNEL_NOT_ASSIGNED";
./Core/HLE/sceKernel.cpp:	case 0x800202cd: return "DMAC_CHILD_OPERATION";
./Core/HLE/sceKernel.cpp:	case 0x800202ce: return "DMAC_TOO_MUCH_SIZE";
./Core/HLE/sceKernel.cpp:	case 0x800202cf: return "DMAC_INVALID_ARGUMENT";
./Core/HLE/sceKernelInterrupt.h:	PSP_DMACPLUS_INTR  = 21,
./Core/HLE/sceKernelModule.cpp:				// Seen in WWE: Smackdown vs Raw 2009. See #17435.
./Core/HLE/sceKernelSemaphore.cpp:		DEBUG_LOG(Log::sceKernel, "sceKernelWaitSemaCB: Suspending sema wait for callback");
./Core/HLE/sceKernelSemaphore.cpp:		WARN_LOG_REPORT(Log::sceKernel, "sceKernelWaitSemaCB: beginning callback with bad wait id?");
./Core/HLE/sceKernelSemaphore.cpp:		DEBUG_LOG(Log::sceKernel, "sceKernelWaitSemaCB: Resuming sema wait for callback");
./Core/HLE/sceKernelSemaphore.cpp:int sceKernelWaitSemaCB(SceUID id, int wantedCount, u32 timeoutPtr) {
./Core/HLE/sceKernelSemaphore.h:int sceKernelWaitSemaCB(SceUID semaid, int signal, u32 timeoutPtr);
./Core/HLE/sceKernelTime.cpp:#include "Common/CommonWindows.h"
./Core/HLE/sceMpeg.cpp:		ctx->mediaengine->setAudioStream(streamNum);
./Core/HLE/sceMpeg.cpp:		ctx->mediaengine->setAudioStream(streamInfo->second.num);
./Core/HLE/sceMpeg.cpp:	ctx->mediaengine->setAudioStream(atracAu.esBuffer);
./Core/HLE/sceMpeg.cpp:	ctx->mediaengine->getAudioSamples(bufferAddr);
./Core/HLE/sceNet.cpp:#include "Core/MIPS/MIPSCodeUtils.h" // for macros to implement __CreateHLELoop
./Core/HLE/sceNet.cpp:	// Windows: Assuming WSAStartup already called beforehand
./Core/HLE/sceNet.cpp:	SceNetEtherAddr mac;
./Core/HLE/sceNet.cpp:	getLocalMac(&mac);
./Core/HLE/sceNet.cpp:	INFO_LOG(Log::sceNet, "LocalHost IP will be %s [%s]", ip2str(g_localhostIP.in.sin_addr).c_str(), mac2str(&mac).c_str());
./Core/HLE/sceNet.cpp:	// For libretro we don't have a better place. On other platforms, we just init/shutdown it with the rest of the emu (NativeInit / NativeShutdown).
./Core/HLE/sceNet.cpp:#ifdef __LIBRETRO__
./Core/HLE/sceNet.cpp:#ifdef __LIBRETRO__
./Core/HLE/sceNet.cpp:		// Read MAC Address from config
./Core/HLE/sceNet.cpp:		if (!ParseMacAddress(g_Config.sMACAddress, addr)) {
./Core/HLE/sceNet.cpp:			ERROR_LOG(Log::sceNet, "Error parsing mac address %s", g_Config.sMACAddress.c_str());
./Core/HLE/sceNet.cpp:	return hleDelayResult(hleLogDebug(Log::sceNet, 0), "get ether mac", 200);
./Core/HLE/sceNet.cpp:static void sceNetEtherNtostr(u32 macPtr, u32 bufferPtr) {
./Core/HLE/sceNet.cpp:	DEBUG_LOG(Log::sceNet, "sceNetEtherNtostr(%08x, %08x) at %08x", macPtr, bufferPtr, currentMIPS->pc);
./Core/HLE/sceNet.cpp:	if (Memory::IsValidAddress(bufferPtr) && Memory::IsValidAddress(macPtr)) {
./Core/HLE/sceNet.cpp:		const u8 *mac = Memory::GetPointerUnchecked(macPtr);
./Core/HLE/sceNet.cpp:		// MAC address is always 6 bytes / 48 bits.
./Core/HLE/sceNet.cpp:			mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
./Core/HLE/sceNet.cpp:static void sceNetEtherStrton(u32 bufferPtr, u32 macPtr) {
./Core/HLE/sceNet.cpp:	DEBUG_LOG(Log::sceNet, "sceNetEtherStrton(%08x, %08x)", bufferPtr, macPtr);
./Core/HLE/sceNet.cpp:	if (Memory::IsValidAddress(bufferPtr) && Memory::IsValidAddress(macPtr)) {
./Core/HLE/sceNet.cpp:		u8 *mac = Memory::GetPointerWrite(macPtr);
./Core/HLE/sceNet.cpp:		// MAC address is always 6 pairs of hex digits.
./Core/HLE/sceNet.cpp:			*mac++ = value;
./Core/HLE/sceNet.cpp:		VERBOSE_LOG(Log::sceNet, "sceNetEtherStrton - [%s]", mac2str((SceNetEtherAddr*)Memory::GetPointer(macPtr)).c_str());
./Core/HLE/sceNet.cpp:	memcpy(netApctlInfo.bssid, "\1\1\2\2\3\3", sizeof(netApctlInfo.bssid)); // fake AP's mac address
./Core/HLE/sceNet.cpp:		DEBUG_LOG(Log::sceNet, "ApctlInfo - BSSID: %s", mac2str((SceNetEtherAddr*)&netApctlInfo.bssid).c_str());
./Core/HLE/sceNet.cpp:			// Generate a BSSID/MAC address
./Core/HLE/sceNet.cpp:			char dummyMAC[ETHER_ADDR_LEN];
./Core/HLE/sceNet.cpp:			memset(dummyMAC, entryId, sizeof(dummyMAC));
./Core/HLE/sceNet.cpp:			dummyMAC[0] &= 0xfc;
./Core/HLE/sceNet.cpp:			Memory::Memcpy(resultAddr, dummyMAC, sizeof(dummyMAC), "GetBSSDescEntryUser");
./Core/HLE/sceNet.cpp:static int sceNetApctl_lib2_C20A144C(int connIndex, u32 ps3MacAddressPtr) {
./Core/HLE/sceNet.cpp:	ERROR_LOG(Log::sceNet, "UNIMPL %s(%i, %08x)", __FUNCTION__, connIndex, ps3MacAddressPtr);
./Core/HLE/sceNetAdhoc.cpp:		if (replicaGameModeAreas.size() == (gameModeMacs.size() - 1)) {
./Core/HLE/sceNetAdhoc.cpp:			if (gameModeSocket < 0 && !isZeroMAC(&masterGameModeArea.mac)) {
./Core/HLE/sceNetAdhoc.cpp:				if ((gameModeSocket = sceNetAdhocPdpCreate((const char*)&masterGameModeArea.mac, ADHOC_GAMEMODE_PORT, gameModeBuffSize, 0)) < 0) {
./Core/HLE/sceNetAdhoc.cpp:						auto it = gameModePeerPorts.find(gma.mac);
./Core/HLE/sceNetAdhoc.cpp:						int sent = hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, gameModeSocket, (const char*)&gma.mac, port, masterGameModeArea.data, masterGameModeArea.size, 0, ADHOC_F_NONBLOCK);
./Core/HLE/sceNetAdhoc.cpp:							DEBUG_LOG(Log::sceNet, "GameMode: Master data Sent %d bytes to Area #%d [%s]", masterGameModeArea.size, gma.id, mac2str(&gma.mac).c_str());
./Core/HLE/sceNetAdhoc.cpp:								auto it = gameModePeerPorts.find(gma.mac);
./Core/HLE/sceNetAdhoc.cpp:								hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, gameModeSocket, (const char*)&gma.mac, port, masterGameModeArea.data, masterGameModeArea.size, 0, ADHOC_F_NONBLOCK);
./Core/HLE/sceNetAdhoc.cpp:				SceNetEtherAddr sendermac;
./Core/HLE/sceNetAdhoc.cpp:				int ret = sceNetAdhocPdpRecv(gameModeSocket, &sendermac, &senderport, gameModeBuffer, &bufsz, 0, ADHOC_F_NONBLOCK);
./Core/HLE/sceNetAdhoc.cpp:					if (senderport != ADHOC_GAMEMODE_PORT && senderport != gameModePeerPorts[sendermac]) {
./Core/HLE/sceNetAdhoc.cpp:						SceNetAdhocctlPeerInfo* peer = findFriend(&sendermac);
./Core/HLE/sceNetAdhoc.cpp:						WARN_LOG(Log::sceNet, "GameMode: Unknown Source Port from [%s][%s:%u -> %u] (Result=%i, Size=%i)", name, mac2str(&sendermac).c_str(), senderport, ADHOC_GAMEMODE_PORT, ret, bufsz);
./Core/HLE/sceNetAdhoc.cpp:					gameModePeerPorts[sendermac] = senderport;
./Core/HLE/sceNetAdhoc.cpp:						if (IsMatch(gma.mac, sendermac)) {
./Core/HLE/sceNetAdhoc.cpp:							DEBUG_LOG(Log::sceNet, "GameMode: Replica data Received %d bytes for Area #%d [%s]", bufsz, gma.id, mac2str(&sendermac).c_str());
./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr mac;
./Core/HLE/sceNetAdhoc.cpp:	// On Windows: MSG_TRUNC are not supported on recvfrom (socket error WSAEOPNOTSUPP), so we use dummy buffer as an alternative
./Core/HLE/sceNetAdhoc.cpp:	// Discard packets from IP that can't be translated into MAC address to prevent confusing the game, since the sender MAC won't be updated and may contains invalid/undefined value.
./Core/HLE/sceNetAdhoc.cpp:	// TODO: In order to discard packets from unresolvable IP (can't be translated into player's MAC) properly, we'll need to manage the socket buffer ourself,
./Core/HLE/sceNetAdhoc.cpp:	if (ret != SOCKET_ERROR && !resolveIP(sin.sin_addr.s_addr, &mac)) {
./Core/HLE/sceNetAdhoc.cpp:			// Find Peer MAC
./Core/HLE/sceNetAdhoc.cpp:			if (resolveIP(sin.sin_addr.s_addr, &mac)) {
./Core/HLE/sceNetAdhoc.cpp:				*req.remoteMAC = mac;
./Core/HLE/sceNetAdhoc.cpp:				auto peer = findFriend(&mac);
./Core/HLE/sceNetAdhoc.cpp:	// On Windows: recvfrom on UDP can get error WSAECONNRESET when previous sendto's destination is unreachable (or destination port is not bound yet), may need to disable SIO_UDP_CONNRESET error
./Core/HLE/sceNetAdhoc.cpp:		// Find Peer MAC
./Core/HLE/sceNetAdhoc.cpp:		if (resolveIP(sin.sin_addr.s_addr, &mac)) {
./Core/HLE/sceNetAdhoc.cpp:			*req.remoteMAC = mac;
./Core/HLE/sceNetAdhoc.cpp:			auto peer = findFriend(&mac);
./Core/HLE/sceNetAdhoc.cpp:		DEBUG_LOG(Log::sceNet, "sceNetAdhocPtpSend[%i:%u]: Sent %u bytes to %s:%u\n", req.id, ptpsocket.lport, ret, mac2str(&ptpsocket.paddr).c_str(), ptpsocket.pport);
./Core/HLE/sceNetAdhoc.cpp:		DEBUG_LOG(Log::sceNet, "sceNetAdhocPtpRecv[%i:%u]: Received %u bytes from %s:%u\n", req.id, ptpsocket.lport, ret, mac2str(&ptpsocket.paddr).c_str(), ptpsocket.pport);
./Core/HLE/sceNetAdhoc.cpp:		int newid = AcceptPtpSocket(req.id, ret, sin, req.remoteMAC, req.remotePort);
./Core/HLE/sceNetAdhoc.cpp:	// Note: On Linux "select" can return > 0 (with SO_ERROR = 0) even when the connection is not accepted yet, thus need "getpeername" to ensure
./Core/HLE/sceNetAdhoc.cpp:			ret = SOCKET_ERROR; // Ensure returned value from select to be negative when the socket is not ready yet, due to a possibility for "getpeername" to succeed on Windows even when "connect" hasn't been accepted yet
./Core/HLE/sceNetAdhoc.cpp:		// Note: "getpeername" shouldn't failed if the connection has been established, but on Windows it may succeed even when "connect" is still in-progress and not accepted yet (ie. "Tales of VS" on Windows)
./Core/HLE/sceNetAdhoc.cpp:	// On Windows you can call connect again using the same socket after ECONNREFUSED/ETIMEDOUT/ENETUNREACH error, but on non-Windows you'll need to recreate the socket first
./Core/HLE/sceNetAdhoc.cpp:int WaitBlockingAdhocSocket(u64 threadSocketId, int type, int pspSocketId, void* buffer, s32_le* len, u32 timeoutUS, SceNetEtherAddr* remoteMAC, u16_le* remotePort, const char* reason) {
./Core/HLE/sceNetAdhoc.cpp:	adhocSocketRequests[threadSocketId] = { type, pspSocketId, buffer, len, tmout, startTime, remoteMAC, remotePort };
./Core/HLE/sceNetAdhoc.cpp: * @param saddr Local MAC (Unused)
./Core/HLE/sceNetAdhoc.cpp:int sceNetAdhocPdpCreate(const char *mac, int port, int bufferSize, u32 flag) {
./Core/HLE/sceNetAdhoc.cpp:	INFO_LOG(Log::sceNet, "sceNetAdhocPdpCreate(%s, %u, %u, %u) at %08x", mac2str((SceNetEtherAddr*)mac).c_str(), port, bufferSize, flag, currentMIPS->pc);
./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr * saddr = (SceNetEtherAddr *)mac;
./Core/HLE/sceNetAdhoc.cpp:		if (mac != NULL && bufferSize > 0) {
./Core/HLE/sceNetAdhoc.cpp:			// Some games (ie. DBZ Shin Budokai 2) might be getting the saddr/srcmac content from SaveState and causing problems :( So we try to fix it here
./Core/HLE/sceNetAdhoc.cpp:				getLocalMac(saddr);
./Core/HLE/sceNetAdhoc.cpp:			// Valid MAC supplied. FIXME: MAC only valid after successful attempt to Create/Connect/Join a Group? (ie. adhocctlCurrentMode != ADHOCCTL_MODE_NONE)
./Core/HLE/sceNetAdhoc.cpp:			if ((adhocctlCurrentMode != ADHOCCTL_MODE_NONE) && isLocalMAC(saddr)) {
./Core/HLE/sceNetAdhoc.cpp:					// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./Core/HLE/sceNetAdhoc.cpp:					// Disable Connection Reset error on UDP to avoid strange behavior https://stackoverflow.com/questions/34242622/windows-udp-sockets-recvfrom-fails-with-error-10054
./Core/HLE/sceNetAdhoc.cpp:			// Invalid MAC supplied
./Core/HLE/sceNetAdhoc.cpp:	DEBUG_LOG(Log::sceNet, "sceNetAdhocctlGetParameter(%08x) [Ch=%i][Group=%s][BSSID=%s][name=%s]", paramAddr, parameter.channel, grpName, mac2str(&parameter.bssid.mac_addr).c_str(), parameter.nickname.data);
./Core/HLE/sceNetAdhoc.cpp: * @param daddr Target MAC Address
./Core/HLE/sceNetAdhoc.cpp:int sceNetAdhocPdpSend(int id, const char *mac, u32 port, void *data, int len, int timeout, int flag) {
./Core/HLE/sceNetAdhoc.cpp:		DEBUG_LOG(Log::sceNet, "sceNetAdhocPdpSend(%i, %s, %i, %p, %i, %i, %i) at %08x", id, mac2str((SceNetEtherAddr*)mac).c_str(), port, data, len, timeout, flag, currentMIPS->pc);
./Core/HLE/sceNetAdhoc.cpp:		VERBOSE_LOG(Log::sceNet, "sceNetAdhocPdpSend(%i, %s, %i, %p, %i, %i, %i) at %08x", id, mac2str((SceNetEtherAddr*)mac).c_str(), port, data, len, timeout, flag, currentMIPS->pc);
./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr * daddr = (SceNetEtherAddr *)mac;
./Core/HLE/sceNetAdhoc.cpp:						if (daddr != NULL && !isZeroMAC(daddr)) {
./Core/HLE/sceNetAdhoc.cpp:							if (!isBroadcastMAC(daddr)) {
./Core/HLE/sceNetAdhoc.cpp:								// Get Peer IP. Some games (ie. Vulcanus Seek and Destroy) seems to try to send to zero-MAC (ie. 00:00:00:00:00:00) first before sending to the actual destination MAC.. So may be sending to zero-MAC has a special meaning? (ie. to peek send buffer availability may be?)
./Core/HLE/sceNetAdhoc.cpp:								if (resolveMAC((SceNetEtherAddr *)daddr, (uint32_t *)&target.sin_addr.s_addr, &finalPortOffset)) {
./Core/HLE/sceNetAdhoc.cpp:								VERBOSE_LOG(Log::sceNet, "sceNetAdhocPdpSend[%i:%u]: Unknown Target Peer %s:%u (faking success)\n", id, getLocalPort(pdpsocket.id), mac2str(daddr).c_str(), ntohs(target.sin_port));
./Core/HLE/sceNetAdhoc.cpp: * @param saddr OUT: Source MAC Address
./Core/HLE/sceNetAdhoc.cpp:				SceNetEtherAddr mac;
./Core/HLE/sceNetAdhoc.cpp:					// On Windows: MSG_TRUNC are not supported on recvfrom (socket error WSAEOPNOTSUPP), so we use dummy buffer as an alternative
./Core/HLE/sceNetAdhoc.cpp:					// Discard packets from IP that can't be translated into MAC address to prevent confusing the game, since the sender MAC won't be updated and may contains invalid/undefined value.
./Core/HLE/sceNetAdhoc.cpp:					// TODO: In order to discard packets from unresolvable IP (can't be translated into player's MAC) properly, we'll need to manage the socket buffer ourself,
./Core/HLE/sceNetAdhoc.cpp:					if (received != SOCKET_ERROR && !resolveIP(sin.sin_addr.s_addr, &mac)) {
./Core/HLE/sceNetAdhoc.cpp:					*saddr = mac;
./Core/HLE/sceNetAdhoc.cpp:					auto peer = findFriend(&mac);
./Core/HLE/sceNetAdhoc.cpp:				// On Windows: Socket Error 10014 may happen when buffer size is less than the minimum allowed/required (ie. negative number on Vulcanus Seek and Destroy), the address is not a valid part of the user address space (ie. on the stack or when buffer overflow occurred), or the address is not properly aligned (ie. multiple of 4 on 32bit and multiple of 8 on 64bit) https://stackoverflow.com/questions/861154/winsock-error-code-10014
./Core/HLE/sceNetAdhoc.cpp:				// On Windows: recvfrom on UDP can get error WSAECONNRESET when previous sendto's destination is unreachable (or destination port is not bound), may need to disable SIO_UDP_CONNRESET
./Core/HLE/sceNetAdhoc.cpp:					// Find Peer MAC
./Core/HLE/sceNetAdhoc.cpp:					if (resolveIP(sin.sin_addr.s_addr, &mac)) {
./Core/HLE/sceNetAdhoc.cpp:						*saddr = mac;
./Core/HLE/sceNetAdhoc.cpp:						auto peer = findFriend(&mac);
./Core/HLE/sceNetAdhoc.cpp:	//WSAPoll only available for Vista or newer, so we'll use an alternative way for XP since Windows doesn't have poll function like *NIX
./Core/HLE/sceNetAdhoc.cpp:					for (; group != NULL && (!excludeSelf || !isLocalMAC(&group->bssid.mac_addr)) && discovered < requestcount; group = group->next) {
./Core/HLE/sceNetAdhoc.cpp:static int sceNetAdhocctlGetNameByAddr(const char *mac, u32 nameAddr) {
./Core/HLE/sceNetAdhoc.cpp:	DEBUG_LOG(Log::sceNet, "UNTESTED sceNetAdhocctlGetNameByAddr(%s, %08x) at %08x", mac2str((SceNetEtherAddr*)mac).c_str(), nameAddr, currentMIPS->pc);
./Core/HLE/sceNetAdhoc.cpp:		if (mac != NULL && Memory::IsValidAddress(nameAddr))
./Core/HLE/sceNetAdhoc.cpp:			// Get Local MAC Address
./Core/HLE/sceNetAdhoc.cpp:			SceNetEtherAddr localmac;
./Core/HLE/sceNetAdhoc.cpp:			getLocalMac(&localmac);
./Core/HLE/sceNetAdhoc.cpp:			// Local MAC Matches
./Core/HLE/sceNetAdhoc.cpp:			if (isMacMatch(&localmac, (const SceNetEtherAddr*)mac))
./Core/HLE/sceNetAdhoc.cpp:				if (peer->last_recv != 0 && isMacMatch(&peer->mac_addr, (const SceNetEtherAddr*)mac))
./Core/HLE/sceNetAdhoc.cpp:int sceNetAdhocctlGetPeerInfo(const char *mac, int size, u32 peerInfoAddr) {
./Core/HLE/sceNetAdhoc.cpp:	VERBOSE_LOG(Log::sceNet, "sceNetAdhocctlGetPeerInfo(%s, %i, %08x) at %08x", mac2str((SceNetEtherAddr*)mac).c_str(), size, peerInfoAddr, currentMIPS->pc);
./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr * maddr = (SceNetEtherAddr *)mac;
./Core/HLE/sceNetAdhoc.cpp:		// Local MAC
./Core/HLE/sceNetAdhoc.cpp:		if (isLocalMAC(maddr)) {
./Core/HLE/sceNetAdhoc.cpp:			buf->mac_addr = *maddr;
./Core/HLE/sceNetAdhoc.cpp:		// Find Peer by MAC
./Core/HLE/sceNetAdhoc.cpp:				buf->mac_addr = *maddr;
./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr* addrs = PSPPointer<SceNetEtherAddr>::Create(membersAddr); // List of participating MAC addresses (started from host)
./Core/HLE/sceNetAdhoc.cpp:		requiredGameModeMacs.push_back(*addrs);
./Core/HLE/sceNetAdhoc.cpp:		DEBUG_LOG(Log::sceNet, "GameMode macAddress#%d=%s", i, mac2str(addrs).c_str());
./Core/HLE/sceNetAdhoc.cpp:	// Add local MAC (Host) first
./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr localMac;
./Core/HLE/sceNetAdhoc.cpp:	getLocalMac(&localMac);
./Core/HLE/sceNetAdhoc.cpp:	gameModeMacs.push_back(localMac);
./Core/HLE/sceNetAdhoc.cpp:	// 1). PtpListen (srcMacAddress=0x09F20CB4, srcPort=0x8001, bufSize=0x2000, retryDelay=0x30D40, retryCount=0x33, queue=0x1, unk1=0x0)
./Core/HLE/sceNetAdhoc.cpp:	// 2). PtpAccpet (peerMacAddr=0x09FE2020, peerPortAddr=0x09FE2010, timeout=0x765BB0, nonblock=0x0) - probably for each clients
./Core/HLE/sceNetAdhoc.cpp:	// We have to wait for all the MACs to have joined to go into CONNECTED state
./Core/HLE/sceNetAdhoc.cpp:* @param membersmacAddr - A pointer to a list of the participating mac addresses, host first, then clients.
./Core/HLE/sceNetAdhoc.cpp:* @param hostmacAddr - The mac address of the host.
./Core/HLE/sceNetAdhoc.cpp:static int sceNetAdhocctlJoinEnterGameMode(const char * group_name, const char *hostMac, int timeout, int flag) {
./Core/HLE/sceNetAdhoc.cpp:	WARN_LOG_REPORT_ONCE(sceNetAdhocctlJoinEnterGameMode, Log::sceNet, "UNTESTED sceNetAdhocctlJoinEnterGameMode(%s, %s, %i, %i) at %08x", grpName, mac2str((SceNetEtherAddr*)hostMac).c_str(), timeout, flag, currentMIPS->pc);
./Core/HLE/sceNetAdhoc.cpp:	if (!hostMac)
./Core/HLE/sceNetAdhoc.cpp:	// Add host mac first
./Core/HLE/sceNetAdhoc.cpp:	gameModeMacs.push_back(*(SceNetEtherAddr*)hostMac);
./Core/HLE/sceNetAdhoc.cpp:	// 1). PtpOpen (srcMacAddress=0x09FE2080, srcPort=0x8001, destMacAddress=0x09F20CB4, destPort=0x8001, bufSize=0x2000, retryDelay=0x30D40, retryCount=0x33, unk1=0x0)
./Core/HLE/sceNetAdhoc.cpp:* @param members MAC Address List of Peers (own MAC at Index 0)
./Core/HLE/sceNetAdhoc.cpp:						// TODO: May need to filter out packets from an IP that can't be translated to MAC address
./Core/HLE/sceNetAdhoc.cpp:	// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./Core/HLE/sceNetAdhoc.cpp: * @param saddr Local MAC (Unused)
./Core/HLE/sceNetAdhoc.cpp: * @param daddr Target MAC
./Core/HLE/sceNetAdhoc.cpp:static int sceNetAdhocPtpOpen(const char *srcmac, int sport, const char *dstmac, int dport, int bufsize, int rexmt_int, int rexmt_cnt, int flag) {
./Core/HLE/sceNetAdhoc.cpp:	INFO_LOG(Log::sceNet, "sceNetAdhocPtpOpen(%s, %d, %s, %d, %d, %d, %d, %d) at %08x", mac2str((SceNetEtherAddr*)srcmac).c_str(), sport, mac2str((SceNetEtherAddr*)dstmac).c_str(),dport,bufsize, rexmt_int, rexmt_cnt, flag, currentMIPS->pc);
./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr* saddr = (SceNetEtherAddr*)srcmac;
./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr* daddr = (SceNetEtherAddr*)dstmac;
./Core/HLE/sceNetAdhoc.cpp:		// Some games (ie. DBZ Shin Budokai 2) might be getting the saddr/srcmac content from SaveState and causing problems if current MAC is different :( So we try to fix it here
./Core/HLE/sceNetAdhoc.cpp:			getLocalMac(saddr);
./Core/HLE/sceNetAdhoc.cpp:		// Valid Addresses. FIXME: MAC only valid after successful attempt to Create/Connect/Join a Group? (ie. adhocctlCurrentMode != ADHOCCTL_MODE_NONE)
./Core/HLE/sceNetAdhoc.cpp:		if ((adhocctlCurrentMode != ADHOCCTL_MODE_NONE) && saddr != NULL && isLocalMAC(saddr) && daddr != NULL && !isBroadcastMAC(daddr) && !isZeroMAC(daddr)) {
./Core/HLE/sceNetAdhoc.cpp:					// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./Core/HLE/sceNetAdhoc.cpp:								// TODO: Need to handle ECONNREFUSED better on non-Windows, if there are games that never called PtpConnect and only relies on [blocking?] PtpOpen to get connected
./Core/HLE/sceNetAdhoc.cpp:	// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./Core/HLE/sceNetAdhoc.cpp:		// Peer MAC
./Core/HLE/sceNetAdhoc.cpp:		SceNetEtherAddr mac;
./Core/HLE/sceNetAdhoc.cpp:		// Find Peer MAC
./Core/HLE/sceNetAdhoc.cpp:		if (resolveIP(peeraddr.sin_addr.s_addr, &mac)) {
./Core/HLE/sceNetAdhoc.cpp:					getLocalMac(&internal->data.ptp.laddr);
./Core/HLE/sceNetAdhoc.cpp:					internal->data.ptp.paddr = mac;
./Core/HLE/sceNetAdhoc.cpp: * @param addr OUT: Peer MAC Address
./Core/HLE/sceNetAdhoc.cpp:static int sceNetAdhocPtpAccept(int id, u32 peerMacAddrPtr, u32 peerPortPtr, int timeout, int flag) {
./Core/HLE/sceNetAdhoc.cpp:	if (Memory::IsValidAddress(peerMacAddrPtr)) {
./Core/HLE/sceNetAdhoc.cpp:		addr = PSPPointer<SceNetEtherAddr>::Create(peerMacAddrPtr);
./Core/HLE/sceNetAdhoc.cpp:		DEBUG_LOG(Log::sceNet, "sceNetAdhocPtpAccept(%d, [%08x]=%s, [%08x]=%u, %d, %u) at %08x", id, peerMacAddrPtr, mac2str(addr).c_str(), peerPortPtr, port ? *port : -1, timeout, flag, currentMIPS->pc);
./Core/HLE/sceNetAdhoc.cpp:		VERBOSE_LOG(Log::sceNet, "sceNetAdhocPtpAccept(%d, [%08x]=%s, [%08x]=%u, %d, %u) at %08x", id, peerMacAddrPtr, mac2str(addr).c_str(), peerPortPtr, port ? *port : -1, timeout, flag, currentMIPS->pc);
./Core/HLE/sceNetAdhoc.cpp:		// TODO: Validate Arguments. GTA:VCS seems to use 0/null for the peerPortPtr, and Bomberman Panic Bomber is using null/0 on both peerMacAddrPtr & peerPortPtr, so i guess it's optional.
./Core/HLE/sceNetAdhoc.cpp:				if (resolveMAC(&ptpsocket.paddr, (uint32_t*)&sin.sin_addr.s_addr, &finalPortOffset)) {
./Core/HLE/sceNetAdhoc.cpp:						// ECONNREFUSED = No connection could be made because the target device actively refused it (on Windows/Linux/Android), or no one listening on the remote address (on Linux/Android) thus should try to connect again later (treated similarly to ETIMEDOUT/ENETUNREACH).
./Core/HLE/sceNetAdhoc.cpp:							// On Windows you can call connect again using the same socket after ECONNREFUSED/ETIMEDOUT/ENETUNREACH error, but on non-Windows you'll need to recreate the socket first
./Core/HLE/sceNetAdhoc.cpp:								// Returning WOULD_BLOCK as Workaround for SCE_NET_ADHOC_ERROR_CONNECTION_REFUSED to be more cross-platform, since there is no way to simulate SCE_NET_ADHOC_ERROR_CONNECTION_REFUSED properly on Windows
./Core/HLE/sceNetAdhoc.cpp: * @param saddr Local MAC (Unused)
./Core/HLE/sceNetAdhoc.cpp:static int sceNetAdhocPtpListen(const char *srcmac, int sport, int bufsize, int rexmt_int, int rexmt_cnt, int backlog, int flag) {
./Core/HLE/sceNetAdhoc.cpp:	INFO_LOG(Log::sceNet, "sceNetAdhocPtpListen(%s, %d, %d, %d, %d, %d, %d) at %08x", mac2str((SceNetEtherAddr*)srcmac).c_str(), sport,bufsize,rexmt_int,rexmt_cnt,backlog,flag, currentMIPS->pc);
./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr * saddr = (SceNetEtherAddr *)srcmac;
./Core/HLE/sceNetAdhoc.cpp:		// Some games (ie. DBZ Shin Budokai 2) might be getting the saddr/srcmac content from SaveState and causing problems :( So we try to fix it here
./Core/HLE/sceNetAdhoc.cpp:			getLocalMac(saddr);
./Core/HLE/sceNetAdhoc.cpp:		// Valid Address. FIXME: MAC only valid after successful attempt to Create/Connect/Join a Group? (ie. adhocctlCurrentMode != ADHOCCTL_MODE_NONE)
./Core/HLE/sceNetAdhoc.cpp:		if ((adhocctlCurrentMode != ADHOCCTL_MODE_NONE) && saddr != NULL && isLocalMAC(saddr)) {
./Core/HLE/sceNetAdhoc.cpp:					// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./Core/HLE/sceNetAdhoc.cpp:						DEBUG_LOG(Log::sceNet, "sceNetAdhocPtpSend[%i:%u]: Sent %u bytes to %s:%u\n", id, ptpsocket.lport, sent, mac2str(&ptpsocket.paddr).c_str(), ptpsocket.pport);
./Core/HLE/sceNetAdhoc.cpp:					DEBUG_LOG(Log::sceNet, "sceNetAdhocPtpSend[%i:%u -> %s:%u]: Result:%i (Error:%i)", id, ptpsocket.lport, mac2str(&ptpsocket.paddr).c_str(), ptpsocket.pport, sent, error);
./Core/HLE/sceNetAdhoc.cpp:						DEBUG_LOG(Log::sceNet, "sceNetAdhocPtpRecv[%i:%u]: Received %u bytes from %s:%u\n", id, ptpsocket.lport, received, mac2str(&ptpsocket.paddr).c_str(), ptpsocket.pport);
./Core/HLE/sceNetAdhoc.cpp:					DEBUG_LOG(Log::sceNet, "sceNetAdhocPtpFlush[%i:%u -> %s:%u]: Error:%i", id, ptpsocket.lport, mac2str(&ptpsocket.paddr).c_str(), ptpsocket.pport, error);
./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr localMac;
./Core/HLE/sceNetAdhoc.cpp:	getLocalMac(&localMac);
./Core/HLE/sceNetAdhoc.cpp:		masterGameModeArea = { 0, size, dataAddr, CoreTiming::GetGlobalTimeUsScaled(), 1, 0, localMac, data };
./Core/HLE/sceNetAdhoc.cpp:		if (replicaGameModeAreas.size() == (gameModeMacs.size() - 1)) {
./Core/HLE/sceNetAdhoc.cpp:* @param mac - The mac address of the peer.
./Core/HLE/sceNetAdhoc.cpp:static int sceNetAdhocGameModeCreateReplica(const char *mac, u32 dataAddr, int size) {
./Core/HLE/sceNetAdhoc.cpp:	WARN_LOG(Log::sceNet, "UNTESTED sceNetAdhocGameModeCreateReplica(%s, %08x, %i) at %08x", mac2str((SceNetEtherAddr*)mac).c_str(), dataAddr, size, currentMIPS->pc);
./Core/HLE/sceNetAdhoc.cpp:	if (mac == nullptr || size < 0 || !Memory::IsValidAddress(dataAddr))
./Core/HLE/sceNetAdhoc.cpp:		[mac, &maxid](GameModeArea const& e) {
./Core/HLE/sceNetAdhoc.cpp:			return IsMatch(e.mac, mac);
./Core/HLE/sceNetAdhoc.cpp:	// MAC address already existed!
./Core/HLE/sceNetAdhoc.cpp:		WARN_LOG(Log::sceNet, "sceNetAdhocGameModeCreateReplica - [%s] is already existed (id: %d)", mac2str((SceNetEtherAddr*)mac).c_str(), it->id);
./Core/HLE/sceNetAdhoc.cpp:		//int sock = sceNetAdhocPdpCreate(mac, ADHOC_GAMEMODE_PORT, size, 0);
./Core/HLE/sceNetAdhoc.cpp:		GameModeArea gma = { maxid + 1, size, dataAddr, CoreTiming::GetGlobalTimeUsScaled(), 0, 0, *(SceNetEtherAddr*)mac, data };
./Core/HLE/sceNetAdhoc.cpp:		if (masterGameModeArea.data != NULL && replicaGameModeAreas.size() == (gameModeMacs.size() - 1)) {
./Core/HLE/sceNetAdhoc.cpp:	gameModePeerPorts.erase(masterGameModeArea.mac);
./Core/HLE/sceNetAdhoc.cpp:	if (isZeroMAC(&masterGameModeArea.mac))
./Core/HLE/sceNetAdhoc.cpp:	gameModePeerPorts.erase(it->mac);
./Core/HLE/sceNetAdhoc.cpp:	if (replicaGameModeAreas.size() <= 0 && isZeroMAC(&masterGameModeArea.mac)) {
./Core/HLE/sceNetAdhoc.cpp:				for (auto& mac : gameModeMacs) {
./Core/HLE/sceNetAdhoc.cpp:					INFO_LOG(Log::sceNet, "GameMode macAddress#%d=%s", i++, mac2str(&mac).c_str());
./Core/HLE/sceNetAdhoc.cpp:	// Writes number of participants and each participating MAC address into infoAddr/gmInfo
./Core/HLE/sceNetAdhoc.cpp:	gmInfo->num = static_cast<s32_le>(gameModeMacs.size());
./Core/HLE/sceNetAdhoc.cpp:	for (auto& mac : gameModeMacs) {
./Core/HLE/sceNetAdhoc.cpp:		VERBOSE_LOG(Log::sceNet, "GameMode macAddress#%d=%s", i, mac2str(&mac).c_str());
./Core/HLE/sceNetAdhoc.cpp:		gmInfo->members[i++] = mac;
./Core/HLE/sceNetAdhoc.cpp:							buf[discovered].mac_addr = peer->mac_addr;
./Core/HLE/sceNetAdhoc.cpp:							DEBUG_LOG(Log::sceNet, "Peer [%s][%s][%s][%llu]", mac2str(&peer->mac_addr).c_str(), ip2str(*(in_addr*)&ipaddr).c_str(), (const char*)&peer->nickname.data, peer->last_recv);
./Core/HLE/sceNetAdhoc.cpp:						SceNetEtherAddr mac;
./Core/HLE/sceNetAdhoc.cpp:						getLocalMac(&mac);
./Core/HLE/sceNetAdhoc.cpp:						buf[discovered].mac_addr = mac;
./Core/HLE/sceNetAdhoc.cpp:						DEBUG_LOG(Log::sceNet, "Peer [%s][%s][%s][%llu]", mac2str(&mac).c_str(), ip2str(addr.sin_addr).c_str(), nickName, lastrecv);
./Core/HLE/sceNetAdhoc.cpp:							buf[discovered].mac_addr = peer->mac_addr;
./Core/HLE/sceNetAdhoc.cpp:							DEBUG_LOG(Log::sceNet, "Peer [%s][%s][%s][%llu]", mac2str(&peer->mac_addr).c_str(), ip2str(*(in_addr*)&ipaddr).c_str(), (const char*)&peer->nickname.data, peer->last_recv);
./Core/HLE/sceNetAdhoc.h:	SceNetEtherAddr* remoteMAC;
./Core/HLE/sceNetAdhoc.h:int sceNetAdhocPdpSend(int id, const char* mac, u32 port, void* data, int len, int timeout, int flag);
./Core/HLE/sceNetAdhoc.h:int sceNetAdhocPdpCreate(const char* mac, int port, int bufferSize, u32 flag);
./Core/HLE/sceNetAdhocMatching.cpp:		memcpy(dataPtr, &msg->mac, sizeof(msg->mac));
./Core/HLE/sceNetAdhocMatching.cpp:		//argsNew.data[2] = dataBufAddr; // FIXME: Is the MAC address mandatory (ie. can't be null pointer) even for EVENT_ERROR? Where should we put this MAC data in the case we failed to allocate the memory? may be on the memory pool?
./Core/HLE/sceNetAdhocMatching.cpp:		auto it = (*context->peerPort).find(peer->mac_addr);
./Core/HLE/sceNetAdhocMatching.cpp:		hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)&peer->mac_addr, port, &ping, (u32)sizeof(ping), 0, ADHOC_F_NONBLOCK);
./Core/HLE/sceNetAdhocMatching.cpp:		auto it = (*context->peerPort).find(peer->mac_addr);
./Core/HLE/sceNetAdhocMatching.cpp:		hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)&peer->mac_addr, port, hello, 5 + context->hellolen, 0, ADHOC_F_NONBLOCK);
./Core/HLE/sceNetAdhocMatching.cpp:* @param mac Target Player MAC
./Core/HLE/sceNetAdhocMatching.cpp:void sendAcceptPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac, int optlen, void * opt) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, mac);
./Core/HLE/sceNetAdhocMatching.cpp:		// Create MAC Array Pointer
./Core/HLE/sceNetAdhocMatching.cpp:		uint8_t * siblingmacs = (uint8_t *)(accept + 9 + optlen);
./Core/HLE/sceNetAdhocMatching.cpp:		// MAC Writing Pointer
./Core/HLE/sceNetAdhocMatching.cpp:			// Copy Child MAC
./Core/HLE/sceNetAdhocMatching.cpp:				// Clone MAC the stupid memcpy way to shut up PSP CPU
./Core/HLE/sceNetAdhocMatching.cpp:				memcpy(siblingmacs + sizeof(SceNetEtherAddr) * i++, &item->mac, sizeof(SceNetEtherAddr));
./Core/HLE/sceNetAdhocMatching.cpp:	hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)mac, (*context->peerPort)[*mac], accept, 9 + optlen + siblingbuflen, 0, ADHOC_F_NONBLOCK);
./Core/HLE/sceNetAdhocMatching.cpp:	spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_ESTABLISHED, mac, 0, NULL);
./Core/HLE/sceNetAdhocMatching.cpp:* @param mac Target Player MAC
./Core/HLE/sceNetAdhocMatching.cpp:void sendJoinPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac, int optlen, void * opt) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, mac);
./Core/HLE/sceNetAdhocMatching.cpp:	hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)mac, (*context->peerPort)[*mac], join, 5 + optlen, 0, ADHOC_F_NONBLOCK);
./Core/HLE/sceNetAdhocMatching.cpp:* @param mac Target Player MAC
./Core/HLE/sceNetAdhocMatching.cpp:void sendCancelPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac, int optlen, void * opt) {
./Core/HLE/sceNetAdhocMatching.cpp:		hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)mac, (*context->peerPort)[*mac], cancel, 5 + optlen, 0, ADHOC_F_NONBLOCK);
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, mac);
./Core/HLE/sceNetAdhocMatching.cpp:* @param mac Target Player MAC
./Core/HLE/sceNetAdhocMatching.cpp:void sendBulkDataPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac, int datalen, void * data) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, mac);
./Core/HLE/sceNetAdhocMatching.cpp:	hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)mac, (*context->peerPort)[*mac], send, 5 + datalen, 0, ADHOC_F_NONBLOCK);
./Core/HLE/sceNetAdhocMatching.cpp:	spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_DATA_ACK, mac, 0, NULL);
./Core/HLE/sceNetAdhocMatching.cpp:* @param mac New Child's MAC
./Core/HLE/sceNetAdhocMatching.cpp:void sendBirthPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * newborn = findPeer(context, mac);
./Core/HLE/sceNetAdhocMatching.cpp:	// Set Newborn MAC
./Core/HLE/sceNetAdhocMatching.cpp:	memcpy(packet + 1, mac, sizeof(SceNetEtherAddr));
./Core/HLE/sceNetAdhocMatching.cpp:		int sent = hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)&peer->mac, (*context->peerPort)[peer->mac], packet, (u32)sizeof(packet), 0, ADHOC_F_NONBLOCK);
./Core/HLE/sceNetAdhocMatching.cpp:			INFO_LOG(Log::sceNet, "InputLoop: Sending BIRTH [%s] to %s", mac2str(mac).c_str(), mac2str(&peer->mac).c_str());
./Core/HLE/sceNetAdhocMatching.cpp:			WARN_LOG(Log::sceNet, "InputLoop: Failed to Send BIRTH [%s] to %s", mac2str(mac).c_str(), mac2str(&peer->mac).c_str());
./Core/HLE/sceNetAdhocMatching.cpp:* @param mac Dead Child's MAC
./Core/HLE/sceNetAdhocMatching.cpp:void sendDeathPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * deadkid = findPeer(context, mac);
./Core/HLE/sceNetAdhocMatching.cpp:	// Set abandoned Child MAC
./Core/HLE/sceNetAdhocMatching.cpp:	memcpy(packet + 1, mac, sizeof(SceNetEtherAddr));
./Core/HLE/sceNetAdhocMatching.cpp:			hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)&peer->mac, (*context->peerPort)[peer->mac], packet, (u32)sizeof(packet[0]), 0, ADHOC_F_NONBLOCK);
./Core/HLE/sceNetAdhocMatching.cpp:				hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)&peer->mac, (*context->peerPort)[peer->mac], packet, (u32)sizeof(packet), 0, ADHOC_F_NONBLOCK);
./Core/HLE/sceNetAdhocMatching.cpp:			hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)&peer->mac, (*context->peerPort)[peer->mac], &opcode, (u32)sizeof(opcode), 0, ADHOC_F_NONBLOCK);
./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./Core/HLE/sceNetAdhocMatching.cpp:void actOnPingPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./Core/HLE/sceNetAdhocMatching.cpp:void actOnHelloPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac, int32_t length) {
./Core/HLE/sceNetAdhocMatching.cpp:		SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./Core/HLE/sceNetAdhocMatching.cpp:				// Copy Sender MAC
./Core/HLE/sceNetAdhocMatching.cpp:				peer->mac = *sendermac;
./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_HELLO, sendermac, optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./Core/HLE/sceNetAdhocMatching.cpp:void actOnJoinPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac, int32_t length) {
./Core/HLE/sceNetAdhocMatching.cpp:				SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./Core/HLE/sceNetAdhocMatching.cpp:						// Copy Sender MAC
./Core/HLE/sceNetAdhocMatching.cpp:						peer->mac = *sendermac;
./Core/HLE/sceNetAdhocMatching.cpp:						spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_REQUEST, sendermac, optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:					spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_REQUEST, sendermac, optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:	sendCancelPacket(context, sendermac, 0, NULL);
./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./Core/HLE/sceNetAdhocMatching.cpp:void actOnAcceptPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac, uint32_t length) {
./Core/HLE/sceNetAdhocMatching.cpp:		// Sibling MAC Array Null Data
./Core/HLE/sceNetAdhocMatching.cpp:		// Extract Optional Sibling MAC Array
./Core/HLE/sceNetAdhocMatching.cpp:		SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./Core/HLE/sceNetAdhocMatching.cpp:			addMember(context, &context->mac);
./Core/HLE/sceNetAdhocMatching.cpp:		spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_ESTABLISHED, sendermac, 0, NULL);
./Core/HLE/sceNetAdhocMatching.cpp:		spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_ACCEPT, sendermac, optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./Core/HLE/sceNetAdhocMatching.cpp:void actOnCancelPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac, int32_t length) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_DENY, sendermac, optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:					spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_LEAVE, &item->mac, optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_CANCEL, sendermac, optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_LEAVE, sendermac, optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_DENY, sendermac, optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_LEAVE, sendermac, optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_CANCEL, sendermac, optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./Core/HLE/sceNetAdhocMatching.cpp:void actOnBulkDataPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac, int32_t length) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./Core/HLE/sceNetAdhocMatching.cpp:				spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_DATA, sendermac, datalen, data);
./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./Core/HLE/sceNetAdhocMatching.cpp:void actOnBirthPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac, uint32_t length) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./Core/HLE/sceNetAdhocMatching.cpp:	// Extract Child MAC
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetEtherAddr mac;
./Core/HLE/sceNetAdhocMatching.cpp:	memcpy(&mac, context->rxbuf + 1, sizeof(SceNetEtherAddr));
./Core/HLE/sceNetAdhocMatching.cpp:	// Save MAC Address
./Core/HLE/sceNetAdhocMatching.cpp:	sibling->mac = mac;
./Core/HLE/sceNetAdhocMatching.cpp:	//spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_ESTABLISHED, &sibling->mac, 0, NULL);
./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./Core/HLE/sceNetAdhocMatching.cpp:void actOnDeathPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac, uint32_t length) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./Core/HLE/sceNetAdhocMatching.cpp:	// Extract Child MAC
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetEtherAddr mac;
./Core/HLE/sceNetAdhocMatching.cpp:	memcpy(&mac, context->rxbuf + 1, sizeof(SceNetEtherAddr));
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * deadkid = findPeer(context, &mac);
./Core/HLE/sceNetAdhocMatching.cpp:	spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_LEAVE, &mac, 0, NULL);
./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./Core/HLE/sceNetAdhocMatching.cpp:void actOnByePacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_BYE, sendermac, 0, NULL);
./Core/HLE/sceNetAdhocMatching.cpp:		spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_BYE, sendermac, 0, NULL);
./Core/HLE/sceNetAdhocMatching.cpp:					INFO_LOG(Log::sceNet, "EventLoop[%d]: Matching Event [%d=%s][%s] OptSize=%d", matchingId, msg->opcode, getMatchingEventStr(msg->opcode), mac2str(&msg->mac).c_str(), msg->optlen);
./Core/HLE/sceNetAdhocMatching.cpp:					//context->handler(context->id, msg->opcode, &msg->mac, msg->optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:				//context->handler(context->id, msg->opcode, &msg->mac, msg->optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:	static SceNetEtherAddr sendermac;
./Core/HLE/sceNetAdhocMatching.cpp:						if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_ACCEPT) sendAcceptPacket(context, &msg->mac, msg->optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:						else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_JOIN) sendJoinPacket(context, &msg->mac, msg->optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:						else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_CANCEL) sendCancelPacket(context, &msg->mac, msg->optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:						else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_BULK) sendBulkDataPacket(context, &msg->mac, msg->optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:						else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_BIRTH) sendBirthPacket(context, &msg->mac);
./Core/HLE/sceNetAdhocMatching.cpp:						else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_DEATH) sendDeathPacket(context, &msg->mac);
./Core/HLE/sceNetAdhocMatching.cpp:						//else if(msg->opcode == PSP_ADHOC_MATCHING_PACKET_BULK_ABORT) sendAbortBulkDataPacket(context, &msg->mac, msg->optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:				int recvresult = sceNetAdhocPdpRecv(context->socket, &sendermac, &senderport, context->rxbuf, &rxbuflen, 0, ADHOC_F_NONBLOCK);
./Core/HLE/sceNetAdhocMatching.cpp:					SceNetAdhocctlPeerInfo* peer = findFriend(&sendermac);
./Core/HLE/sceNetAdhocMatching.cpp:						DEBUG_LOG(Log::sceNet, "Timestamp LastRecv Delta: %lld (%llu - %llu) from %s", delta, now, peer->last_recv, mac2str(&sendermac).c_str());
./Core/HLE/sceNetAdhocMatching.cpp:						WARN_LOG(Log::sceNet, "InputLoop[%d]: Unknown Peer[%s:%u] (Recved=%i, Length=%i)", matchingId, mac2str(&sendermac).c_str(), senderport, recvresult, rxbuflen);
./Core/HLE/sceNetAdhocMatching.cpp:					if (context->port != senderport && senderport != (*context->peerPort)[sendermac]) {
./Core/HLE/sceNetAdhocMatching.cpp:						WARN_LOG(Log::sceNet, "InputLoop[%d]: Unknown Source Port from [%s][%s:%u -> %u] (Recved=%i, Length=%i)", matchingId, name, mac2str(&sendermac).c_str(), senderport, context->port, recvresult, rxbuflen);
./Core/HLE/sceNetAdhocMatching.cpp:					(*context->peerPort)[sendermac] = senderport;
./Core/HLE/sceNetAdhocMatching.cpp:					if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_PING) actOnPingPacket(context, &sendermac);
./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_HELLO) actOnHelloPacket(context, &sendermac, rxbuflen);
./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_JOIN) actOnJoinPacket(context, &sendermac, rxbuflen);
./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_ACCEPT) actOnAcceptPacket(context, &sendermac, rxbuflen);
./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_CANCEL) actOnCancelPacket(context, &sendermac, rxbuflen);
./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_BULK) actOnBulkDataPacket(context, &sendermac, rxbuflen);
./Core/HLE/sceNetAdhocMatching.cpp:					//else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_BULK_ABORT) actOnAbortBulkDataPacket(context, &sendermac, rxbuflen);
./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_BIRTH) actOnBirthPacket(context, &sendermac, rxbuflen);
./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_DEATH) actOnDeathPacket(context, &sendermac, rxbuflen);
./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_BYE) actOnByePacket(context, &sendermac);
./Core/HLE/sceNetAdhocMatching.cpp:					if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_ACCEPT) sendAcceptPacket(context, &msg->mac, msg->optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:					else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_JOIN) sendJoinPacket(context, &msg->mac, msg->optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:					else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_CANCEL) sendCancelPacket(context, &msg->mac, msg->optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:					else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_BULK) sendBulkDataPacket(context, &msg->mac, msg->optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:					else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_BIRTH) sendBirthPacket(context, &msg->mac);
./Core/HLE/sceNetAdhocMatching.cpp:					else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_DEATH) sendDeathPacket(context, &msg->mac);
./Core/HLE/sceNetAdhocMatching.cpp:					//else if(msg->opcode == PSP_ADHOC_MATCHING_PACKET_BULK_ABORT) sendAbortBulkDataPacket(context, &msg->mac, msg->optlen, opt);
./Core/HLE/sceNetAdhocMatching.cpp:	// Remove your own MAC, or All members, or don't remove at all or we should do this on MatchingDelete ?
./Core/HLE/sceNetAdhocMatching.cpp:		SceNetEtherAddr localmac;
./Core/HLE/sceNetAdhocMatching.cpp:		getLocalMac(&localmac);
./Core/HLE/sceNetAdhocMatching.cpp:			context->mac = localmac;
./Core/HLE/sceNetAdhocMatching.cpp:	int sock = hleCall(sceNetAdhoc, int, sceNetAdhocPdpCreate, (const char*)&item->mac, static_cast<int>(item->port), item->rxbuflen, 0);
./Core/HLE/sceNetAdhocMatching.cpp:static int sceNetAdhocMatchingSelectTarget(int matchingId, const char *macAddress, int optLen, u32 optDataPtr) {
./Core/HLE/sceNetAdhocMatching.cpp:	WARN_LOG(Log::sceNet, "UNTESTED sceNetAdhocMatchingSelectTarget(%i, %s, %i, %08x) at %08x", matchingId, mac2str((SceNetEtherAddr*)macAddress).c_str(), optLen, optDataPtr, currentMIPS->pc);
./Core/HLE/sceNetAdhocMatching.cpp:	if (macAddress == NULL) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetEtherAddr * target = (SceNetEtherAddr *)macAddress;
./Core/HLE/sceNetAdhocMatching.cpp:int NetAdhocMatching_CancelTargetWithOpt(int matchingId, const char* macAddress, int optLen, u32 optDataPtr) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetEtherAddr* target = (SceNetEtherAddr*)macAddress;
./Core/HLE/sceNetAdhocMatching.cpp:int sceNetAdhocMatchingCancelTargetWithOpt(int matchingId, const char *macAddress, int optLen, u32 optDataPtr) {
./Core/HLE/sceNetAdhocMatching.cpp:	WARN_LOG(Log::sceNet, "UNTESTED sceNetAdhocMatchingCancelTargetWithOpt(%i, %s, %i, %08x) at %08x", matchingId, mac2str((SceNetEtherAddr*)macAddress).c_str(), optLen, optDataPtr, currentMIPS->pc);
./Core/HLE/sceNetAdhocMatching.cpp:	return NetAdhocMatching_CancelTargetWithOpt(matchingId, macAddress, optLen, optDataPtr);
./Core/HLE/sceNetAdhocMatching.cpp:int sceNetAdhocMatchingCancelTarget(int matchingId, const char *macAddress) {
./Core/HLE/sceNetAdhocMatching.cpp:	WARN_LOG(Log::sceNet, "UNTESTED sceNetAdhocMatchingCancelTarget(%i, %s)", matchingId, mac2str((SceNetEtherAddr*)macAddress).c_str());
./Core/HLE/sceNetAdhocMatching.cpp:	return NetAdhocMatching_CancelTargetWithOpt(matchingId, macAddress, 0, 0);
./Core/HLE/sceNetAdhocMatching.cpp:				// Add Local MAC
./Core/HLE/sceNetAdhocMatching.cpp:				buf2[filledpeers++].mac_addr = context->mac;
./Core/HLE/sceNetAdhocMatching.cpp:				DEBUG_LOG(Log::sceNet, "MemberSelf [%s]", mac2str(&context->mac).c_str());
./Core/HLE/sceNetAdhocMatching.cpp:						auto friendpeer = findFriend(&p2p->mac);
./Core/HLE/sceNetAdhocMatching.cpp:						// Add P2P Brother MAC
./Core/HLE/sceNetAdhocMatching.cpp:						buf2[filledpeers++].mac_addr = p2p->mac;
./Core/HLE/sceNetAdhocMatching.cpp:						DEBUG_LOG(Log::sceNet, "MemberP2P [%s]", mac2str(&p2p->mac).c_str());
./Core/HLE/sceNetAdhocMatching.cpp:						auto friendpeer = findFriend(&parentpeer->mac);
./Core/HLE/sceNetAdhocMatching.cpp:						// Add Parent MAC
./Core/HLE/sceNetAdhocMatching.cpp:						buf2[filledpeers++].mac_addr = parentpeer->mac;
./Core/HLE/sceNetAdhocMatching.cpp:						DEBUG_LOG(Log::sceNet, "MemberParent [%s]", mac2str(&parentpeer->mac).c_str());
./Core/HLE/sceNetAdhocMatching.cpp:							auto friendpeer = findFriend(&peer->mac);
./Core/HLE/sceNetAdhocMatching.cpp:							// Add Peer MAC
./Core/HLE/sceNetAdhocMatching.cpp:								// Add Child MAC
./Core/HLE/sceNetAdhocMatching.cpp:								buf2[filledpeers++].mac_addr = peer->mac;
./Core/HLE/sceNetAdhocMatching.cpp:								DEBUG_LOG(Log::sceNet, "MemberChild [%s]", mac2str(&peer->mac).c_str());
./Core/HLE/sceNetAdhocMatching.cpp:								// Add Peer MAC
./Core/HLE/sceNetAdhocMatching.cpp:								buf2[filledpeers++].mac_addr = peer->mac;
./Core/HLE/sceNetAdhocMatching.cpp:								DEBUG_LOG(Log::sceNet, "MemberSibling [%s]", mac2str(&peer->mac).c_str());
./Core/HLE/sceNetAdhocMatching.cpp:								// Add Local MAC
./Core/HLE/sceNetAdhocMatching.cpp:								buf2[filledpeers++].mac_addr = peer->mac;
./Core/HLE/sceNetAdhocMatching.cpp:								DEBUG_LOG(Log::sceNet, "MemberSelf [%s]", mac2str(&peer->mac).c_str());
./Core/HLE/sceNetAdhocMatching.cpp:// Gran Turismo may replace the 1st bit of the 1st byte of MAC address's OUI with 0 (unicast bit), or replace the whole 6-bytes of MAC address with all 00 (invalid mac) for unknown reason
./Core/HLE/sceNetAdhocMatching.cpp:int sceNetAdhocMatchingSendData(int matchingId, const char *mac, int dataLen, u32 dataAddr) {
./Core/HLE/sceNetAdhocMatching.cpp:	WARN_LOG(Log::sceNet, "UNTESTED sceNetAdhocMatchingSendData(%i, %s, %i, %08x) at %08x", matchingId, mac2str((SceNetEtherAddr*)mac).c_str(), dataLen, dataAddr, currentMIPS->pc);
./Core/HLE/sceNetAdhocMatching.cpp:	if (mac == NULL) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal* peer = findPeer(context, (SceNetEtherAddr*)mac);
./Core/HLE/sceNetAdhocMatching.cpp:	sendBulkDataPacket(context, &peer->mac, dataLen, data);
./Core/HLE/sceNetAdhocMatching.cpp:int sceNetAdhocMatchingAbortSendData(int matchingId, const char *mac) {
./Core/HLE/sceNetAdhocMatching.cpp:	WARN_LOG(Log::sceNet, "UNTESTED sceNetAdhocMatchingAbortSendData(%i, %s)", matchingId, mac2str((SceNetEtherAddr*)mac).c_str());
./Core/HLE/sceNetAdhocMatching.cpp:	if (mac == NULL) {
./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, (SceNetEtherAddr *)mac);
./Core/HLE/sceNetAdhocMatching.cpp:			DEBUG_LOG(Log::sceNet, "AdhocMatchingCallback: [ID=%i][EVENT=%i][%s]", args[0], args[1], mac2str((SceNetEtherAddr *)Memory::GetPointer(args[2])).c_str());
./Core/HLE/sceNetAdhocMatching.cpp:			DEBUG_LOG(Log::sceNet, "AdhocMatching - Discarding Callback: [ID=%i][EVENT=%i][%s]", args[0], args[1], mac2str((SceNetEtherAddr*)Memory::GetPointer(args[2])).c_str());
./Core/HLE/sceNetAdhocMatching.h:	u32_le data[6]; // ContextID, EventID, bufAddr[ to MAC], OptLen, OptAddr[, EntryPoint]
./Core/HLE/sceNetInet.cpp:				FD_SET(sock, &rdfds); // This might pointed to a non-existing socket or sockets belonged to other programs on Windows, because most of the time Windows socket have an id above 1k instead of 0-255
./Core/HLE/sceNetInet.cpp:	// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./Core/HLE/sceNetInet.cpp:	// FIXME: On non-Windows broadcast to INADDR_BROADCAST(255.255.255.255) might not be received by the sender itself when binded to specific IP (ie. 192.168.0.2) or INADDR_BROADCAST.
./Core/HLE/sceNetInet.cpp:	// Discard if it came from APIPA address (ie. self-received broadcasts from 169.254.x.x when broadcasting to INADDR_BROADCAST on Windows) on Untold Legends The Warrior's Code / Twisted Metal Head On
./Core/HLE/sceNetInet.cpp:		// FIXME: On non-Windows(including PSP too?) broadcast to INADDR_BROADCAST(255.255.255.255) might not be received by the sender itself when binded to specific IP (ie. 192.168.0.2) or INADDR_BROADCAST.
./Core/HLE/sceNetInet.cpp:			// Replace Limited Broadcast(255.255.255.255) with Direct Broadcast(ie. 192.168.0.255) for accurate targetting when there are multiple interfaces, to avoid receiving it's own broadcasted data through IP 169.254.x.x on Windows (which is not recognized as it's own IP by the game)
./Core/HLE/sceNetInet.cpp:			// TODO: Creates our own CMSG_* macros (32-bit version of it, similar to the one on PSP) to avoid alignment/size issue that can lead to memory corruption/out of bound issue.
./Core/HLE/sceNetInet.cpp:		// FIXME: On non-Windows(including PSP too?) broadcast to INADDR_BROADCAST(255.255.255.255) might not be received by the sender itself when binded to specific IP (ie. 192.168.0.2) or INADDR_BROADCAST.
./Core/HLE/sceNetInet.cpp:			// Replace Limited Broadcast(255.255.255.255) with Direct Broadcast(ie. 192.168.0.255) for accurate targetting when there are multiple interfaces, to avoid receiving it's own broadcasted data through IP 169.254.x.x on Windows (which is not recognized as it's own IP by the game)
./Core/HLE/sceNetInet.h:#define		PSP_NET_INET_FD_SETSIZE		256		// PSP can support upto 256 fd(s) while the default FD_SETSIZE on Windows is only 64 
./Core/HLE/sceNetInet.h:	s32_le nonblocking; // non-blocking flag (ie. FIONBIO) to keep track of the blocking mode since Windows doesn't have getter for this
./Core/HLE/sceNetResolver.cpp:#if __linux__ || __APPLE__ || defined(__OpenBSD__)
./Core/HLE/sceNetResolver.cpp:#include <iostream>
./Core/HLE/sceOpenPSID.cpp:	getLocalMac((SceNetEtherAddr*)&dummyOpenPSID);
./Core/HLE/scePsmf.cpp:static const int audioSamples = 2048;
./Core/HLE/scePsmf.cpp:static const int audioSamplesBytes = audioSamples * 4;
./Core/HLE/scePsmf.cpp:	s32_le audioStreamNum;
./Core/HLE/scePsmf.cpp:	s32_le numAudioStreams;
./Core/HLE/scePsmf.cpp:	int audioStreamNum;
./Core/HLE/scePsmf.cpp:	int totalAudioStreams;
./Core/HLE/scePsmf.cpp:	void readPrivateAudioStreamParams(const u8 *addr, Psmf *psmf) {
./Core/HLE/scePsmf.cpp:			stream->readPrivateAudioStreamParams(currentStreamAddr, this);
./Core/HLE/scePsmf.cpp:	audioStreamNum = -1;
./Core/HLE/scePsmf.cpp:	Do(p, audioStreamNum);
./Core/HLE/scePsmf.cpp:		Do(p, totalAudioStreams);
./Core/HLE/scePsmf.cpp:		totalAudioStreams = 1;
./Core/HLE/scePsmf.cpp:	psmfplayer->totalAudioStreams = 0;
./Core/HLE/scePsmf.cpp:			++psmfplayer->totalAudioStreams;
./Core/HLE/scePsmf.cpp:	return hleLogWarning(Log::ME, audioSamplesBytes);
./Core/HLE/scePsmf.cpp:	if (psmfplayer->totalAudioStreams > 0) {
./Core/HLE/scePsmf.cpp:		if (playerData->audioStreamNum >= psmfplayer->totalAudioStreams) {
./Core/HLE/scePsmf.cpp:			ERROR_LOG_REPORT(Log::ME, "scePsmfPlayerStart(%08x, %08x, %d): unable to change audio stream to %d", psmfPlayer, psmfPlayerData, initPts, playerData->audioStreamNum);
./Core/HLE/scePsmf.cpp:	if (psmfplayer->totalAudioStreams > 0) {
./Core/HLE/scePsmf.cpp:		psmfplayer->mediaengine->setAudioStream(playerData->audioStreamNum);
./Core/HLE/scePsmf.cpp:		psmfplayer->audioStreamNum = playerData->audioStreamNum;
./Core/HLE/scePsmf.cpp:	if (psmfplayer->mediaengine->getAudioSamples(audioDataAddr) == 0) {
./Core/HLE/scePsmf.cpp:		if (psmfplayer->totalAudioStreams > 0 && (s64)psmfplayer->psmfPlayerAvcAu.pts < (s64)psmfplayer->totalDurationTimestamp - VIDEO_FRAME_DURATION_TS) {
./Core/HLE/scePsmf.cpp:			Memory::Memset(audioDataAddr, 0, audioSamplesBytes, "PsmfAudioClear");
./Core/HLE/scePsmf.cpp:	info->numAudioStreams = psmfplayer->totalAudioStreams;
./Core/HLE/scePsmf.cpp:static u32 scePsmfPlayerGetCurrentAudioStream(u32 psmfPlayer, u32 audioCodecAddr, u32 audioStreamNumAddr)
./Core/HLE/scePsmf.cpp:	if (Memory::IsValidAddress(audioStreamNumAddr)) {
./Core/HLE/scePsmf.cpp:		Memory::WriteUnchecked_U32(psmfplayer->audioStreamNum, audioStreamNumAddr);
./Core/HLE/scePsmf.cpp:	int next = psmfplayer->audioStreamNum + 1;
./Core/HLE/scePsmf.cpp:	if (next >= psmfplayer->totalAudioStreams)
./Core/HLE/scePsmf.cpp:	if (next == psmfplayer->audioStreamNum || !psmfplayer->mediaengine->setAudioStream(next)) {
./Core/HLE/scePsmf.cpp:	psmfplayer->audioStreamNum = next;
./Core/HLE/scePsmf.cpp:static u32 scePsmfPlayerSelectSpecificAudio(u32 psmfPlayer, int audioCodec, int audioStreamNum)
./Core/HLE/scePsmf.cpp:	if (psmfplayer->totalAudioStreams < 2) {
./Core/HLE/scePsmf.cpp:	if (audioStreamNum < 0 || audioStreamNum >= psmfplayer->totalAudioStreams) {
./Core/HLE/scePsmf.cpp:	if (psmfplayer->totalAudioStreams < 2 || !psmfplayer->mediaengine->setAudioStream(audioStreamNum)) {
./Core/HLE/scePsmf.cpp:	if (psmfplayer->audioStreamNum != audioStreamNum) {
./Core/HLE/scePsmf.cpp:	psmfplayer->audioStreamNum = audioStreamNum;
./Core/HLE/scePsmf.cpp:	{0X68F07175, &WrapU_UUU<scePsmfPlayerGetCurrentAudioStream>,       "scePsmfPlayerGetCurrentAudioStream",       'x', "xxx"},
./Core/HLE/sceRtc.cpp:#include "Common/CommonWindows.h"
./Core/HLE/sceUsbCam.cpp:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./Core/HLE/sceUsbCam.cpp:#include "Common/CommonWindows.h"
./Core/HLE/sceUsbCam.cpp:#include "Windows/CaptureDevice.h"
./Core/HLE/sceUsbCam.cpp:#elif PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(IOS)
./Core/HLE/sceUsbCam.cpp:#elif PPSSPP_PLATFORM(MAC)
./Core/HLE/sceUsbCam.cpp:	return __mac_getDeviceList();
./Core/HLE/sceUsbCam.cpp:	#elif defined(USING_QT_UI) // Qt:macOS / Qt:Linux
./Core/HLE/sceUsbCam.cpp:		return __qt_getDeviceList();
./Core/HLE/sceUsbCam.cpp:	#elif PPSSPP_PLATFORM(LINUX) // SDL:Linux
./Core/HLE/sceUsbCam.cpp:				winCamera = new WindowsCaptureDevice(CAPTUREDEVIDE_TYPE::VIDEO);
./Core/HLE/sceUsbCam.cpp:	#elif PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(IOS) || defined(USING_QT_UI)
./Core/HLE/sceUsbCam.cpp:#elif PPSSPP_PLATFORM(MAC)
./Core/HLE/sceUsbCam.cpp:	__mac_startCapture(width, height);
./Core/HLE/sceUsbCam.cpp:	#elif PPSSPP_PLATFORM(LINUX)
./Core/HLE/sceUsbCam.cpp:#elif PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(IOS) || defined(USING_QT_UI)
./Core/HLE/sceUsbCam.cpp:#elif PPSSPP_PLATFORM(MAC)
./Core/HLE/sceUsbCam.cpp:		__mac_stopCapture();
./Core/HLE/sceUsbCam.cpp:	#elif PPSSPP_PLATFORM(LINUX)
./Core/HLE/sceUsbMic.cpp:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./Core/HLE/sceUsbMic.cpp:#include "Common/CommonWindows.h"
./Core/HLE/sceUsbMic.cpp:#include "Windows/CaptureDevice.h"
./Core/HLE/sceUtility.cpp:	// The windows aren't this regular, but close.
./Core/HLE/sceVaudio.cpp:	__AudioSetSRCFrequency(freq);
./Core/HLE/sceVaudio.cpp:static u32 sceVaudioSetEffectType(int effectType, int vol) {
./Core/HLE/sceVaudio.cpp:	ERROR_LOG_REPORT(Log::sceAudio, "UNIMPL sceVaudioSetEffectType(%i, %i)", effectType, vol);
./Core/HLE/sceVaudio.cpp:static u32 sceVaudioSetAlcMode(int alcMode) {
./Core/HLE/sceVaudio.cpp:	ERROR_LOG_REPORT(Log::sceAudio, "UNIMPL sceVaudioSetAlcMode(%i)", alcMode);
./Core/HLE/sceVaudio.cpp:	{0X346FBE94, &WrapU_II<sceVaudioSetEffectType>,  "sceVaudioSetEffectType",      'x', "ii" },
./Core/HLE/sceVaudio.cpp:	{0XCBD4AC51, &WrapU_I<sceVaudioSetAlcMode>,      "sceVaudioSetAlcMode",         'x', "i"  },
./Core/HW/Atrac3Standalone.cpp:			// We delay the codecOpen until the first decode, so the setChannels call from MediaEngine::getAudioSamples
./Core/HW/Atrac3Standalone.cpp:		// We just call the decode function directly without going through the whole packet machinery.
./Core/HW/Camera.cpp:#if defined(USING_QT_UI)
./Core/HW/Camera.cpp:std::vector<std::string> __qt_getDeviceList() {
./Core/HW/Camera.cpp:				qtc_ideal_width, qtc_ideal_height, &jpegData, &jpegLen);
./Core/HW/Camera.cpp:				qtc_ideal_width, qtc_ideal_height, &jpegData, &jpegLen);
./Core/HW/Camera.cpp:int __qt_startCapture(int width, int height) {
./Core/HW/Camera.cpp:	if (qt_camera != nullptr) {
./Core/HW/Camera.cpp:		delete qt_camera;
./Core/HW/Camera.cpp:		qt_camera = nullptr;
./Core/HW/Camera.cpp:			qt_camera = new QCamera(cameraInfo);
./Core/HW/Camera.cpp:	if (qt_camera == nullptr) {
./Core/HW/Camera.cpp:		qt_camera = new QCamera();
./Core/HW/Camera.cpp:		if (qt_camera == nullptr) {
./Core/HW/Camera.cpp:	qtc_ideal_width = width;
./Core/HW/Camera.cpp:	qtc_ideal_height = height;
./Core/HW/Camera.cpp:	qt_viewfinder = new MyViewfinder;
./Core/HW/Camera.cpp:	QCameraViewfinderSettings viewfinderSettings = qt_camera->viewfinderSettings();
./Core/HW/Camera.cpp:	qt_camera->setViewfinderSettings(viewfinderSettings);
./Core/HW/Camera.cpp:	qt_camera->setViewfinder(qt_viewfinder);
./Core/HW/Camera.cpp:	qt_camera->start();
./Core/HW/Camera.cpp:int __qt_stopCapture() {
./Core/HW/Camera.cpp:	if (qt_camera != nullptr) {
./Core/HW/Camera.cpp:		qt_camera->stop();
./Core/HW/Camera.cpp:		qt_camera->unload();
./Core/HW/Camera.cpp:		delete qt_camera;
./Core/HW/Camera.cpp:		delete qt_viewfinder;
./Core/HW/Camera.cpp:		qt_camera = nullptr;
./Core/HW/Camera.cpp://endif defined(USING_QT_UI)
./Core/HW/Camera.cpp:#elif PPSSPP_PLATFORM(LINUX) && !PPSSPP_PLATFORM(ANDROID)
./Core/HW/Camera.cpp:#endif // PPSSPP_PLATFORM(LINUX) && !PPSSPP_PLATFORM(ANDROID)
./Core/HW/Camera.h:#if defined(USING_QT_UI)
./Core/HW/Camera.h:	static int        qtc_ideal_width;
./Core/HW/Camera.h:	static int        qtc_ideal_height;
./Core/HW/Camera.h:	static QCamera *qt_camera;
./Core/HW/Camera.h:	static QAbstractVideoSurface *qt_viewfinder;
./Core/HW/Camera.h:	std::vector<std::string> __qt_getDeviceList();
./Core/HW/Camera.h:	int __qt_startCapture(int width, int height);
./Core/HW/Camera.h:	int __qt_stopCapture();
./Core/HW/Camera.h:#elif PPSSPP_PLATFORM(MAC)
./Core/HW/Camera.h:std::vector<std::string> __mac_getDeviceList();
./Core/HW/Camera.h:int __mac_startCapture(int width, int height);
./Core/HW/Camera.h:int __mac_stopCapture();
./Core/HW/Camera.h:#elif PPSSPP_PLATFORM(LINUX) && !PPSSPP_PLATFORM(ANDROID)
./Core/HW/Camera.h:#include <linux/videodev2.h>
./Core/HW/MediaEngine.cpp:	Do(p, m_audioStream);
./Core/HW/MediaEngine.cpp:	m_demux->demux(m_audioStream);
./Core/HW/MediaEngine.cpp:int MediaEngine::getAudioSamples(u32 bufferPtr) {
./Core/HW/MediaEngine.cpp:	m_demux->demux(m_audioStream);
./Core/HW/MediaEngine.h:	bool setAudioStream(int streamNum) { m_audioStream = streamNum; return true; }
./Core/HW/MediaEngine.h:	int getAudioSamples(u32 bufferPtr);
./Core/HW/MediaEngine.h:	int m_audioStream = -1;
./Core/HW/MpegDemux.cpp:MpegDemux::MpegDemux(int size, int offset) : m_audioStream(size) {
./Core/HW/MpegDemux.cpp:	DoClass(p, m_audioStream);
./Core/HW/MpegDemux.cpp:			m_audioStream.push(m_buf + m_index, length, pesHeader.pts);
./Core/HW/MpegDemux.cpp:static bool isHeader(const u8 *audioStream, int offset)
./Core/HW/MpegDemux.cpp:	return (audioStream[offset] == header1) && (audioStream[offset+1] == header2);
./Core/HW/MpegDemux.cpp:static int getNextHeaderPosition(u8* audioStream, int curpos, int limit, int frameSize)
./Core/HW/MpegDemux.cpp:	if (offset < endScan && isHeader(audioStream, offset))
./Core/HW/MpegDemux.cpp:		if (isHeader(audioStream, scan))
./Core/HW/MpegDemux.cpp:	m_audioStream.pop_front(0, audioPos, pts);
./Core/HW/MpegDemux.cpp:	int gotsize = m_audioStream.get_front(m_audioFrame, 0x2000);
./Core/HW/MpegDemux.h:	BufferQueue m_audioStream;
./Core/HW/SimpleAudioDec.h:	// NOTE: This can come late (MediaEngine::getAudioSample)! But it will come before the first Decode.
./Core/Instance.cpp:#if !PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(ANDROID) && !defined(__LIBRETRO__) && !PPSSPP_PLATFORM(SWITCH)
./Core/Instance.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Core/Instance.cpp:#include "Common/CommonWindows.h"
./Core/Instance.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Core/Instance.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Core/Instance.cpp:#elif PPSSPP_PLATFORM(ANDROID) || defined(__LIBRETRO__) || PPSSPP_PLATFORM(SWITCH)
./Core/Instance.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Core/Instance.cpp:#elif PPSSPP_PLATFORM(ANDROID) || defined(__LIBRETRO__) || PPSSPP_PLATFORM(SWITCH)
./Core/Instance.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Core/Instance.cpp:#elif PPSSPP_PLATFORM(ANDROID) || defined(__LIBRETRO__) || PPSSPP_PLATFORM(SWITCH)
./Core/KeyMap.cpp:	{NKCODE_WINDOW, "Windows"},
./Core/KeyMap.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Core/KeyMap.cpp:#elif PPSSPP_PLATFORM(IOS)
./Core/KeyMap.cpp:	SetDefaultKeyMap(DEFAULT_MAPPING_IOS_PAD, false);
./Core/KeyMap.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Core/KeyMapDefaults.cpp:static const DefMappingStruct defaultPadMapIOS[] = {
./Core/KeyMapDefaults.cpp:	case DEFAULT_MAPPING_IOS_PAD:
./Core/KeyMapDefaults.cpp:		SetDefaultKeyMap(DEVICE_ID_PAD_0, defaultPadMapIOS, ARRAY_SIZE(defaultPadMapIOS), replace);
./Core/KeyMapDefaults.h:	DEFAULT_MAPPING_IOS_PAD,
./Core/Loaders.cpp:		// Ignore macos metadata stuff
./Core/Loaders.cpp:		if (startsWith(zippedName, "__macosx/")) {
./Core/MIPS/ARM/ArmAsm.cpp:#if PPSSPP_PLATFORM(IOS)
./Core/MIPS/ARM/ArmAsm.cpp:				// On iOS, R9 (JITBASEREG) is volatile.  We have to reload it.
./Core/MIPS/ARM/ArmJit.cpp:	// TODO: Not used by anything yet (except the modified VerySleepy on Windows)
./Core/MIPS/ARM/ArmRegCacheFPU.cpp:	qTime_++;
./Core/MIPS/ARM/ArmRegCacheFPU.h:	int qTime_;
./Core/MIPS/ARM64/Arm64Asm.cpp:// Apple: https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARM64FunctionCallingConventions.html
./Core/MIPS/ARM64/Arm64Asm.cpp:// x18: unavailable (reserved for use by the OS or linker or whatever - iOS, for example, uses it)
./Core/MIPS/ARM64/Arm64IRAsm.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./Core/MIPS/ARM64/Arm64IRCompALU.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./Core/MIPS/ARM64/Arm64IRCompBranch.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./Core/MIPS/ARM64/Arm64IRCompFPU.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./Core/MIPS/ARM64/Arm64IRCompLoadStore.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./Core/MIPS/ARM64/Arm64IRCompSystem.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./Core/MIPS/ARM64/Arm64IRCompVec.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./Core/MIPS/ARM64/Arm64IRJit.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./Core/MIPS/ARM64/Arm64IRJit.h:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./Core/MIPS/ARM64/Arm64IRRegCache.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./Core/MIPS/ARM64/Arm64IRRegCache.h:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./Core/MIPS/IR/IRInst.h:// But this gets rid of a lot of MIPS idiosyncrasies that makes it tricky, like
./Core/MIPS/IR/IRInterpreter.cpp:#if PPSSPP_PLATFORM(WINDOWS) && PPSSPP_ARCH(ARM64)
./Core/MIPS/IR/IRInterpreter.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Core/MIPS/IR/IRInterpreter.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./Core/MIPS/JitCommon/JitBlockCache.cpp:#include "Common/CommonWindows.h"
./Core/MIPS/JitCommon/JitCommon.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__)
./Core/MIPS/JitCommon/JitState.cpp:		// iOS/etc. may disable at runtime if Memory::base is not nicely aligned.
./Core/MIPS/MIPSAnalyst.cpp:#if !PPSSPP_PLATFORM(IOS)
./Core/MIPS/MIPSInt.cpp:			// Will cause garbage on the real machine so we just ignore it, the app will overwrite the cacheline.
./Core/MIPS/MIPSVFPUFallbacks.cpp:// Was measured to be around 0x68, but GTA on Mac is somehow super sensitive
./Core/MIPS/MIPSVFPUFallbacks.cpp:#if defined(__linux__)
./Core/MIPS/RiscV/RiscVJit.cpp:#if PPSSPP_ARCH(RISCV64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./Core/MIPS/x86/CompVFPU.cpp:		mask_nosign_arg = MAccessibleDisp(TEMPREG, &mask_nosign[0], &mask_nosign[0]);
./Core/MIPS/x86/CompVFPU.cpp:		nan_mantissa_arg = MAccessibleDisp(TEMPREG, &mask_nosign[0], &nan_mantissa[0]);
./Core/MIPS/x86/CompVFPU.cpp:		magic_arg = MAccessibleDisp(TEMPREG, &mask_nosign[0], &magic[0]);
./Core/MIPS/x86/CompVFPU.cpp:		was_infnan_arg = MAccessibleDisp(TEMPREG, &mask_nosign[0], &was_infnan[0]);
./Core/MIPS/x86/CompVFPU.cpp:		exp_infnan_arg = MAccessibleDisp(TEMPREG, &mask_nosign[0], &exp_infnan[0]);
./Core/MIPS/x86/CompVFPU.cpp:		// TODO: This reg might be different on Linux...
./Core/MIPS/x86/JitSafeMem.cpp:	if (!g_Config.bIgnoreBadMemAccess) {
./Core/MIPS/x86/JitSafeMem.cpp:		if (!g_Config.bIgnoreBadMemAccess) {
./Core/MIPS/x86/JitSafeMem.cpp:	if (!g_Config.bIgnoreBadMemAccess) {
./Core/MIPS/x86/JitSafeMem.cpp:	if (needsCheck_ && !g_Config.bIgnoreBadMemAccess)
./Core/MIPS/x86/X64IRJit.h:#if PPSSPP_PLATFORM(WINDOWS) && (defined(_MSC_VER) || defined(__clang__) || defined(__INTEL_COMPILER))
./Core/MemFault.cpp:#include "Common/MachineContext.h"
./Core/MemFault.cpp:#ifdef MACHINE_CONTEXT_SUPPORTED
./Core/MemFault.cpp:#if PPSSPP_ARCH(AMD64) && PPSSPP_PLATFORM(WINDOWS)
./Core/MemFault.cpp:	if (success && (g_Config.bIgnoreBadMemAccess || g_ignoredAddresses.find(codePtr) != g_ignoredAddresses.end())) {
./Core/MemFault.cpp:		// Either bIgnoreBadMemAccess is off, or we failed recovery analysis.
./Core/MemMap.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/MemMap.cpp:#include "Common/CommonWindows.h"
./Core/MemMap.cpp:#if PPSSPP_PLATFORM(IOS) && PPSSPP_ARCH(64BIT)
./Core/MemMap.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/MemMap.cpp:#if PPSSPP_PLATFORM(WINDOWS) && PPSSPP_ARCH(32BIT)
./Core/MemMap.cpp:#elif PPSSPP_ARCH(ARM64) && PPSSPP_PLATFORM(IOS)
./Core/MemMap.cpp:		// iOS
./Core/MemMap.cpp:#if !PPSSPP_PLATFORM(UWP)
./Core/MemMap.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/MemMap.cpp:	// On some 32 bit platforms (like Android, iOS, etc.), you can only map < 32 megs at a time.
./Core/MemMap.h:// UWP has such limited memory management that we need to mask
./Core/MemMap.h:#if PPSSPP_ARCH(32BIT) || PPSSPP_PLATFORM(UWP) || USE_ASAN || PPSSPP_PLATFORM(IOS) || defined(__EMSCRIPTEN__)
./Core/PSPLoaders.cpp:#include "Common/CommonWindows.h"
./Core/Reporting.cpp:		return "Windows ARM64";
./Core/Reporting.cpp:		return "Windows 64";
./Core/Reporting.cpp:		return "Windows ARM32";
./Core/Reporting.cpp:		return "Windows";
./Core/Reporting.cpp:#elif PPSSPP_PLATFORM(IOS)
./Core/Reporting.cpp:		return "iOS";
./Core/Reporting.cpp:		return "Mac";
./Core/Reporting.cpp:#elif defined(__linux__)
./Core/Reporting.cpp:		return "Linux";
./Core/RetroAchievements.cpp:#include "Windows/MainWindow.h"
./Core/Screenshot.cpp:// Technically only needed on Windows.
./Core/System.cpp:#include "Common/CommonWindows.h"
./Core/System.cpp:#if !PPSSPP_PLATFORM(UWP)
./Core/System.cpp:#include "Windows/W32Util/ShellUtil.h"
./Core/System.cpp:#ifndef __LIBRETRO__
./Core/System.cpp:#ifdef __LIBRETRO__
./Core/System.cpp:// while repeatedly calling PSP_InitUpdate. This is basically just for libretro convenience.
./Core/System.cpp:	// Reduce the risk for weird races with the Windows GE debugger.
./Core/TiltEventProcessor.cpp:	const double oldPollInterval = 1.0 / 250.0;  // See Windows "PollControllers".
./Core/Util/GameManager.cpp:#include "Common/CommonWindows.h"
./Core/Util/MemStick.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/Util/MemStick.cpp:#if PPSSPP_PLATFORM(UWP)
./Core/Util/PPGeDraw.cpp:	// Should we pass a draw_? Yes! UWP requires it.
./Core/Util/PPGeDraw.cpp:	// If the atlas is larger than 512x512, need to use windows into it.
./Core/Util/PathUtil.cpp:// On iOS, the path to the app documents directory changes on each launch.
./Core/Util/PathUtil.cpp:#if PPSSPP_PLATFORM(IOS)
./Core/Util/PathUtil.cpp:#if !PPSSPP_PLATFORM(ANDROID) && (PPSSPP_PLATFORM(LINUX) || PPSSPP_PLATFORM(MAC))
./Core/Util/PortManager.cpp:	// FIXME: On Windows it seems using any UPnP functions in this destructor that gets triggered when exiting PPSSPP will resulting to UPNPCOMMAND_HTTP_ERROR due to early WSACleanup (miniupnpc was getting WSANOTINITIALISED internally)
./Core/Util/PortManager.cpp:	// Windows: Assuming WSAStartup already called beforehand
./Core/Util/RecentFiles.cpp:				// iOS only stuff
./Core/WaveFile.h:	uint32_t GetAudioSize() const { return audio_size; }
./Core/WebServer.cpp:		// First reject backslashes, in case of any Windows shenanigans.
./Dockerfile:RUN apk add build-base wget git bash cmake python3 glu-dev sdl2-dev
./Dockerfile:RUN cd src/ffmpeg && ./linux_x86-64.sh
./Dockerfile:RUN apk add --no-cache sdl2 libstdc++ glu-dev
./GPU/Common/DepalettizeShaderCommon.cpp:		// TODO: I think we can handle most scenarios here, but texturing from depth buffers requires an extension on ES 2.0 anyway.
./GPU/Common/SoftwareTransformCommon.h:enum SoftwareTransformAction {
./GPU/Common/SoftwareTransformCommon.h:	SoftwareTransformAction action;
./GPU/Common/TextureCacheCommon.cpp:		// Do the computation in bytes so that it's valid even in case of weird reinterpret scenarios.
./GPU/Common/TextureCacheCommon.h:// Texture replacement state machine:
./GPU/Common/TextureDecoder.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_ARCH(ARM64) || defined(_MSC_VER) || !PPSSPP_ARCH(ARMV7)
./GPU/Common/TextureDecoder.cpp:		// TODO: Why does this crash on iOS, but only certain devices?
./GPU/Common/TextureReplacer.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./GPU/Common/VertexDecoderArm.cpp:// NOTE: Avoid R9, it's dangerous on iOS.
./GPU/Common/VertexDecoderCommon.cpp:		// We've compiled the steps into optimized machine code, so just jump!
./GPU/Common/VertexDecoderX86.cpp:// XMM0-XMM5 are volatile on Windows X64
./GPU/Common/VertexShaderGenerator.cpp:// Now, the regular machinery will take over and do the calculation again.
./GPU/D3D11/D3D11Util.cpp:#if PPSSPP_PLATFORM(UWP)
./GPU/D3D11/StateMappingD3D11.cpp:	// we go through Draw here because it automatically handles screen rotation, as needed in UWP on mobiles.
./GPU/D3D11/TextureCacheD3D11.h:#include "Common/CommonWindows.h"
./GPU/Debugger/Playback.cpp:#if !defined(__LIBRETRO__)
./GPU/GLES/GPU_GLES.cpp:#include "Windows/GPU/WindowsGLContext.h"
./GPU/GLES/GPU_GLES.cpp:	// If we're here during app shutdown (exiting the Windows app in-game, for example)
./GPU/GLES/ShaderManagerGLES.cpp:#include "Common/CommonWindows.h"
./GPU/GLES/StateMappingGLES.cpp:#elif !PPSSPP_PLATFORM(IOS)
./GPU/GPU.cpp:#if PPSSPP_PLATFORM(UWP)
./GPU/GPU.cpp:		// Disable GLES on ARM Windows (but leave it enabled on other ARM platforms).
./GPU/GPU.vcxproj:    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
./GPU/GPU.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./GPU/GPU.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./GPU/GPU.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./GPU/GPU.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./GPU/GPU.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./GPU/GPU.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./GPU/GPU.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./GPU/GPU.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./GPU/GPU.vcxproj:  <PropertyGroup Label="UserMacros" />
./GPU/GPU.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./GPU/GPU.vcxproj:    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSdk_LibraryPath_x86);</LibraryPath>
./GPU/GPU.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./GPU/GPU.vcxproj:    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSdk_LibraryPath_x64);</LibraryPath>
./GPU/GPU.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./GPU/GPU.vcxproj:    <LibraryPath>$(VC_LibraryPath_ARM64);$(WindowsSdk_LibraryPath_ARM64);</LibraryPath>
./GPU/GPU.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./GPU/GPU.vcxproj:    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSdk_LibraryPath_x64);</LibraryPath>
./GPU/GPU.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./GPU/GPU.vcxproj:    <LibraryPath>$(VC_LibraryPath_ARM64);$(WindowsSdk_LibraryPath_ARM64);</LibraryPath>
./GPU/GPU.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./GPU/GPU.vcxproj:    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSdk_LibraryPath_x86);</LibraryPath>
./GPU/GPUCommon.cpp:	// you'd expect due to the int64 field, but the Linux ABI apparently does not require that.
./GPU/GPUCommon.cpp:DLResult GPUCommon::ProcessDLQueue() {
./GPU/GPUCommon.cpp:		if (g_Config.bIgnoreBadMemAccess) {
./GPU/GPUCommon.h:	DLResult ProcessDLQueue();
./GPU/Math3D.h:#if PPSSPP_PLATFORM(WINDOWS) && (defined(_MSC_VER) || defined(__clang__) || defined(__INTEL_COMPILER))
./GPU/Math3D.h:// There's probably a better place to define these macros.
./GPU/Math3D.h:// spills, but that, hopefully, does not affect PPSSPP (modern GCC+Linux
./GPU/Software/DrawPixel.cpp:#if PPSSPP_ARCH(AMD64) && !PPSSPP_PLATFORM(UWP)
./GPU/Software/DrawPixelX86.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./GPU/Software/DrawPixelX86.cpp:	// RET + Windows reserves space to save args, half of 1 xmm + 4 ints before the id.
./GPU/Software/DrawPixelX86.cpp:					MOV(PTRBITS, R(depthTemp), MAccessibleDisp(depthTemp, &fb.data, &depthbuf.data));
./GPU/Software/Lighting.cpp:	Vec4<int> mac = state.colorForAmbient ? colorFactor : state.material.ambientColorFactor;
./GPU/Software/Lighting.cpp:	Vec4<int> ambient = (mac * state.baseAmbientColorFactor) >> 10;
./GPU/Software/Lighting.cpp:			Vec4<int> lambient = LightColorScaleBy512<useSSE4>(lstate.ambientColorFactor, mac, attspot512);
./GPU/Software/RasterizerRectangle.cpp:			// We might be able to compare ratios, but let's expect 1:1.
./GPU/Software/RasterizerRegCache.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./GPU/Software/RasterizerRegCache.cpp:	// The Windows convention is annoying, as it wastes registers and keeps to "positions."
./GPU/Software/RasterizerRegCache.cpp:#if defined(_WIN32) && (PPSSPP_ARCH(X86) || PPSSPP_ARCH(AMD64)) && !PPSSPP_PLATFORM(UWP)
./GPU/Software/RasterizerRegCache.h:#if PPSSPP_ARCH(AMD64) && PPSSPP_PLATFORM(WINDOWS) && (defined(_MSC_VER) || defined(__clang__) || defined(__INTEL_COMPILER))
./GPU/Software/RasterizerRegCache.h:	// Note: Assumes __vectorcall on Windows.
./GPU/Software/Sampler.cpp:#if PPSSPP_ARCH(AMD64) && !PPSSPP_PLATFORM(UWP)
./GPU/Software/SamplerX86.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./GPU/Software/SamplerX86.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./GPU/Software/SamplerX86.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./GPU/Software/SamplerX86.cpp:		// On Linux, RCX is currently levelFrac, but we'll need it for other things.
./GPU/Software/SamplerX86.cpp:#if !PPSSPP_PLATFORM(WINDOWS)
./GPU/Software/SamplerX86.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./GPU/Software/SamplerX86.cpp:	// Free up some more vector regs on Windows too, where we're a bit tight.
./GPU/Software/SamplerX86.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./GPU/Software/SamplerX86.cpp:		// Leave level/levelFrac, we just always load from RAM on Windows and lock on POSIX.
./GPU/Software/SamplerX86.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./GPU/Software/SoftGpu.cpp:		if (g_Config.bIgnoreBadMemAccess) {
./GPU/Vulkan/DebugVisVulkan.cpp:		vmaCalculateStatistics(vulkan->Allocator(), &vmaStats);
./GPU/Vulkan/ShaderManagerVulkan.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./LICENSE.TXT:    a) Accompany it with the complete corresponding machine-readable
./LICENSE.TXT:    machine-readable copy of the corresponding source code, to be
./README.md:No BIOS file required to play, PPSSPP is an "HLE" emulator.  Default settings balance good compatibility and speed.
./README.md:To download fresh development builds for Android, Windows and Mac, [go to the /devbuilds page](https://www.ppsspp.org/devbuilds)
./README.md:- Fix exiting not functioning correctly on Windows in some circumstances ([#20607])
./README.md:- Fix bug in Mac/Linux builds where the mouse got hidden and stuck if you enabled mouse input mapping ([#20612])
./README.md:- Fixed some hangs in the Windows debugger ([#20510])
./README.md:- Possible fix for Mac audio device selection issue ([#20482])
./README.md:	- More precise sleep function on Windows ([#20054])
./README.md:	- Minor features: Asks for confirmation on exit in most scenarios ([#19996], [#20023]), DPI scaling ([#20013]), can pause without menu ([#19883])
./README.md:	- Allow picking a background image on iOS ([#20370])
./README.md:	- Exclude older Macs from using Vulkan (too many black screens, hangs) ([#20236])
./README.md:	- Use portable-file-dialogs to provide file-open dialogs on Linux ([#20175])
./README.md:	- Now rendering at proper resolution on newer Macs ([#20011])
./README.md:	- Use the correct font again on Mac/iOS ([#19874])
./README.md:	- Improved iOS/Mac support, Game Mode support ([#19287], [#19281], [#19269], [#19270], [#19257], [#19254], [#19244], [#19227], [#19224], [#19213], [#19200], [#19187], [#19184], [#19161], [#19118])
./README.md:	- SDL fixes: ([#19131])
./README.md:	- Android and Windows shortcuts - add icons and bugfixes: ([#19139], [#19142], [#19138])
./README.md:[#19287]: https://github.com/hrydgard/ppsspp/issues/19287 "iOS: Enable \"double-swipe\" to switch apps"
./README.md:[#19281]: https://github.com/hrydgard/ppsspp/issues/19281 "iOS: Disable the swipe-back gesture in-game, to maximize touch responsiveness"
./README.md:[#19269]: https://github.com/hrydgard/ppsspp/issues/19269 "Set the games category in plists for Mac and iOS."
./README.md:[#19270]: https://github.com/hrydgard/ppsspp/issues/19270 "Set GCSupportsGameMode in info.plist files for iOS and Mac"
./README.md:[#19257]: https://github.com/hrydgard/ppsspp/issues/19257 "iOS: Implement basic physical keyboard support"
./README.md:[#19254]: https://github.com/hrydgard/ppsspp/issues/19254 "iOS: Fix \"Home\" button on controllers (like the PS logo button on a PS4 controller)"
./README.md:[#19227]: https://github.com/hrydgard/ppsspp/issues/19227 "More text fixes on iOS/Mac"
./README.md:[#19224]: https://github.com/hrydgard/ppsspp/issues/19224 "More iOS fixes"
./README.md:[#19213]: https://github.com/hrydgard/ppsspp/issues/19213 "iOS: Prevent the Recents list from disappearing a lot"
./README.md:[#19200]: https://github.com/hrydgard/ppsspp/issues/19200 "iOS: Add audio session mode controls"
./README.md:[#19187]: https://github.com/hrydgard/ppsspp/issues/19187 "iOS: Fix issue with keyboard popping up after file picker."
./README.md:[#19184]: https://github.com/hrydgard/ppsspp/issues/19184 "Native text drawing on macOS/iOS"
./README.md:[#19161]: https://github.com/hrydgard/ppsspp/issues/19161 "Add basic soft-keyboard support on iOS"
./README.md:[#19118]: https://github.com/hrydgard/ppsspp/issues/19118 "macOS: Update VulkanLoader for MoltenVK 1.2.8-style framework finding"
./README.md:[#19243]: https://github.com/hrydgard/ppsspp/issues/19243 "iOS: Implement accelerometer support"
./README.md:[#19131]: https://github.com/hrydgard/ppsspp/issues/19131 "CPU at 100% in menu in Vulkan on Linux"
./README.md:[#19138]: https://github.com/hrydgard/ppsspp/issues/19138 "Windows: When using \"Create shortcut\", use the game's icon instead of PPSSPP's"
./README.md:[#19505]: https://github.com/hrydgard/ppsspp/issues/19505 "iOS: Chat input fix, Mac text input fix"
./README.md:[#20023]: https://github.com/hrydgard/ppsspp/issues/20023 "Add confirmation popup support on Exit App key, libretro buildfix"
./README.md:[#20230]: https://github.com/hrydgard/ppsspp/issues/20230 "Move to trash instead of deleting important files like savedata (Windows only so far)"
./README.md:[#19973]: https://github.com/hrydgard/ppsspp/issues/19973 "Add support for displaying the battery percentage on Windows."
./README.md:[#19967]: https://github.com/hrydgard/ppsspp/issues/19967 "Support battery percentage display on SDL"
./README.md:[#20370]: https://github.com/hrydgard/ppsspp/issues/20370 "iOS: Implement a background image picker"
./README.md:[#20236]: https://github.com/hrydgard/ppsspp/issues/20236 "Blacklist older Intel GPUs from using Vulkan on Mac"
./README.md:[#20175]: https://github.com/hrydgard/ppsspp/issues/20175 "Add Linux file dialog support through \"portable-file-dialogs\""
./README.md:[#20011]: https://github.com/hrydgard/ppsspp/issues/20011 "macOS SDL: Set the metal layer resolution properly, remove DPI hacks."
./README.md:[#19874]: https://github.com/hrydgard/ppsspp/issues/19874 "macOS/iOS: register font with CoreText"
./README.md:[#20482]: https://github.com/hrydgard/ppsspp/issues/20482 "SDL audio: Improve logging, don't auto-switch device during the first 3 seconds of execution"
./README.md:[#20612]: https://github.com/hrydgard/ppsspp/issues/20612 "SDL: Fix bug where the mouse got stuck in relative mode when mapping mouse inputs"
./Tools/SaveTool/main.c:	SceIoStat fileStat;
./Tools/SaveTool/main.c:	SceIoStat fileStat;
./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./Tools/langtool/Cargo.lock: "windows-registry",
./Tools/langtool/Cargo.lock:name = "linux-raw-sys"
./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./Tools/langtool/Cargo.lock: "openssl-macros",
./Tools/langtool/Cargo.lock:name = "openssl-macros"
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./Tools/langtool/Cargo.lock:name = "proc-macro2"
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/Cargo.lock: "windows-sys 0.52.0",
./Tools/langtool/Cargo.lock: "linux-raw-sys",
./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/Cargo.lock: "windows-sys 0.60.2",
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./Tools/langtool/Cargo.lock: "wasm-bindgen-macro",
./Tools/langtool/Cargo.lock:name = "wasm-bindgen-macro"
./Tools/langtool/Cargo.lock: "wasm-bindgen-macro-support",
./Tools/langtool/Cargo.lock:name = "wasm-bindgen-macro-support"
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/Cargo.lock: "winapi-i686-pc-windows-gnu",
./Tools/langtool/Cargo.lock: "winapi-x86_64-pc-windows-gnu",
./Tools/langtool/Cargo.lock:name = "winapi-i686-pc-windows-gnu"
./Tools/langtool/Cargo.lock:name = "winapi-x86_64-pc-windows-gnu"
./Tools/langtool/Cargo.lock:name = "windows-link"
./Tools/langtool/Cargo.lock:name = "windows-registry"
./Tools/langtool/Cargo.lock: "windows-link",
./Tools/langtool/Cargo.lock: "windows-result",
./Tools/langtool/Cargo.lock: "windows-strings",
./Tools/langtool/Cargo.lock:name = "windows-result"
./Tools/langtool/Cargo.lock: "windows-link",
./Tools/langtool/Cargo.lock:name = "windows-strings"
./Tools/langtool/Cargo.lock: "windows-link",
./Tools/langtool/Cargo.lock:name = "windows-sys"
./Tools/langtool/Cargo.lock: "windows-targets 0.52.6",
./Tools/langtool/Cargo.lock:name = "windows-sys"
./Tools/langtool/Cargo.lock: "windows-targets 0.53.5",
./Tools/langtool/Cargo.lock:name = "windows-sys"
./Tools/langtool/Cargo.lock: "windows-link",
./Tools/langtool/Cargo.lock:name = "windows-targets"
./Tools/langtool/Cargo.lock: "windows_aarch64_gnullvm 0.52.6",
./Tools/langtool/Cargo.lock: "windows_aarch64_msvc 0.52.6",
./Tools/langtool/Cargo.lock: "windows_i686_gnu 0.52.6",
./Tools/langtool/Cargo.lock: "windows_i686_gnullvm 0.52.6",
./Tools/langtool/Cargo.lock: "windows_i686_msvc 0.52.6",
./Tools/langtool/Cargo.lock: "windows_x86_64_gnu 0.52.6",
./Tools/langtool/Cargo.lock: "windows_x86_64_gnullvm 0.52.6",
./Tools/langtool/Cargo.lock: "windows_x86_64_msvc 0.52.6",
./Tools/langtool/Cargo.lock:name = "windows-targets"
./Tools/langtool/Cargo.lock: "windows-link",
./Tools/langtool/Cargo.lock: "windows_aarch64_gnullvm 0.53.1",
./Tools/langtool/Cargo.lock: "windows_aarch64_msvc 0.53.1",
./Tools/langtool/Cargo.lock: "windows_i686_gnu 0.53.1",
./Tools/langtool/Cargo.lock: "windows_i686_gnullvm 0.53.1",
./Tools/langtool/Cargo.lock: "windows_i686_msvc 0.53.1",
./Tools/langtool/Cargo.lock: "windows_x86_64_gnu 0.53.1",
./Tools/langtool/Cargo.lock: "windows_x86_64_gnullvm 0.53.1",
./Tools/langtool/Cargo.lock: "windows_x86_64_msvc 0.53.1",
./Tools/langtool/Cargo.lock:name = "windows_aarch64_gnullvm"
./Tools/langtool/Cargo.lock:name = "windows_aarch64_gnullvm"
./Tools/langtool/Cargo.lock:name = "windows_aarch64_msvc"
./Tools/langtool/Cargo.lock:name = "windows_aarch64_msvc"
./Tools/langtool/Cargo.lock:name = "windows_i686_gnu"
./Tools/langtool/Cargo.lock:name = "windows_i686_gnu"
./Tools/langtool/Cargo.lock:name = "windows_i686_gnullvm"
./Tools/langtool/Cargo.lock:name = "windows_i686_gnullvm"
./Tools/langtool/Cargo.lock:name = "windows_i686_msvc"
./Tools/langtool/Cargo.lock:name = "windows_i686_msvc"
./Tools/langtool/Cargo.lock:name = "windows_x86_64_gnu"
./Tools/langtool/Cargo.lock:name = "windows_x86_64_gnu"
./Tools/langtool/Cargo.lock:name = "windows_x86_64_gnullvm"
./Tools/langtool/Cargo.lock:name = "windows_x86_64_gnullvm"
./Tools/langtool/Cargo.lock:name = "windows_x86_64_msvc"
./Tools/langtool/Cargo.lock:name = "windows_x86_64_msvc"
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/Cargo.lock: "proc-macro2",
./Tools/langtool/unused-heuristic.sh:folders=('../../UI/' '../../Core/' '../../Common/' '../../GPU/' '../../Windows/' '../../assets/shaders' '../../assets/themes')
./UI/AudioCommon.cpp:	if (g_Config.iAudioPlaybackMode == (int)AudioSyncMode::GRANULAR) {
./UI/AudioCommon.cpp:		if (g_Config.iAudioPlaybackMode == (int)AudioSyncMode::GRANULAR) {
./UI/AudioCommon.cpp:		if (g_Config.iAudioPlaybackMode == (int)AudioSyncMode::GRANULAR) {
./UI/Background.cpp:#if PPSSPP_PLATFORM(IOS)
./UI/Background.cpp:	// iOS uses an old screenshot when restoring the task, so to avoid an ugly
./UI/DarwinFileSystemServices.h:#if PPSSPP_PLATFORM(IOS)
./UI/DarwinFileSystemServices.h:	// iOS only, needed for UIDocumentPickerViewController
./UI/DarwinFileSystemServices.h:#endif // PPSSPP_PLATFORM(IOS)
./UI/DarwinFileSystemServices.h:void RestartMacApp();
./UI/DarwinFileSystemServices.mm:#include "../ios/ViewControllerCommon.h"
./UI/DarwinFileSystemServices.mm:#if PPSSPP_PLATFORM(MAC)
./UI/DarwinFileSystemServices.mm:			INFO_LOG(Log::System, "Mac: Received OK response from modal");
./UI/DarwinFileSystemServices.mm:			INFO_LOG(Log::System, "Mac: Received Cancel response from modal");
./UI/DarwinFileSystemServices.mm:			WARN_LOG(Log::System, "Mac: Received unknown responsde from modal");
./UI/DarwinFileSystemServices.mm:#elif PPSSPP_PLATFORM(IOS)
./UI/DarwinFileSystemServices.mm:#if PPSSPP_PLATFORM(IOS)
./UI/DarwinFileSystemServices.mm:#elif PPSSPP_PLATFORM(MAC)
./UI/DarwinFileSystemServices.mm:void RestartMacApp() {
./UI/DarwinFileSystemServices.mm:#if PPSSPP_PLATFORM(MAC)
./UI/DebugOverlay.cpp:#if !PPSSPP_PLATFORM(UWP) && !PPSSPP_PLATFORM(SWITCH)
./UI/DevScreens.cpp:#if !PPSSPP_PLATFORM(UWP)
./UI/DeveloperToolsScreen.cpp:	// iOS can now use JIT on all modes, apparently.
./UI/DeveloperToolsScreen.cpp:	// The bool may come in handy for future non-jit platforms though (UWP XB1?)
./UI/DeveloperToolsScreen.cpp:	// In iOS App Store builds, we disable the JIT.
./UI/DeveloperToolsScreen.cpp:#if PPSSPP_PLATFORM(IOS)
./UI/DeveloperToolsScreen.cpp:	list->Add(new NoticeView(NoticeLevel::WARN, ms->T("Moving the memstick directory is NOT recommended on iOS"), ""));
./UI/DeveloperToolsScreen.cpp:	// Makes it easy to get savestates out of an iOS device. The file listing shown in MacOS doesn't allow
./UI/DeveloperToolsScreen.cpp:#if PPSSPP_PLATFORM(IOS)
./UI/DeveloperToolsScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./UI/DeveloperToolsScreen.cpp:#if !PPSSPP_PLATFORM(ANDROID) && !PPSSPP_PLATFORM(IOS) && !PPSSPP_PLATFORM(SWITCH)
./UI/DiscordIntegration.cpp:#if (PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(LINUX)) && !PPSSPP_PLATFORM(ANDROID) && !PPSSPP_PLATFORM(UWP)
./UI/DisplayLayoutScreen.cpp:#elif PPSSPP_PLATFORM(IOS)
./UI/EmuScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./UI/EmuScreen.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./UI/EmuScreen.cpp:#include "Windows/MainWindow.h"
./UI/EmuScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./UI/EmuScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./UI/EmuScreen.cpp:	// External commands, like from the Windows UI.
./UI/EmuScreen.cpp:#if PPSSPP_PLATFORM(WINDOWS) || defined(USING_QT_UI) || defined(SDL)
./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./UI/GameSettingsScreen.cpp:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP)
./UI/GameSettingsScreen.cpp:#include "Windows/MainWindow.h"
./UI/GameSettingsScreen.cpp:#include "Windows/W32Util/ShellUtil.h"
./UI/GameSettingsScreen.cpp:extern AndroidAudioState *g_audioState;
./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(UWP)
./UI/GameSettingsScreen.cpp:		CreateAudioSettings(parent);
./UI/GameSettingsScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./UI/GameSettingsScreen.cpp:	// If only one mode is supported (like FIFO on iOS), no need to show the options.
./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(IOS)
./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./UI/GameSettingsScreen.cpp:void GameSettingsScreen::CreateAudioSettings(UI::ViewGroup *audioSettings) {
./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(IOS)
./UI/GameSettingsScreen.cpp:	CheckBox *respectSilentMode = audioSettings->Add(new CheckBox(&g_Config.bAudioRespectSilentMode, a->T("Respect silent mode")));
./UI/GameSettingsScreen.cpp:	CheckBox *mixWithOthers = audioSettings->Add(new CheckBox(&g_Config.bAudioMixWithOthers, a->T("Mix audio with other apps")));
./UI/GameSettingsScreen.cpp:	audioSettings->Add(new ItemHeader(a->T("Audio playback")));
./UI/GameSettingsScreen.cpp:	audioSettings->Add(new PopupMultiChoice(&g_Config.iAudioPlaybackMode, a->T("Playback mode"), syncModes, 0, ARRAY_SIZE(syncModes), I18NCat::AUDIO, screenManager()));
./UI/GameSettingsScreen.cpp:	audioSettings->Add(new CheckBox(&g_Config.bFillAudioGaps, a->T("Fill audio gaps")))->SetEnabledFunc([]() {
./UI/GameSettingsScreen.cpp:		return g_Config.iAudioPlaybackMode == (int)AudioSyncMode::GRANULAR;
./UI/GameSettingsScreen.cpp:	audioSettings->Add(new ItemHeader(a->T("Game volume")));
./UI/GameSettingsScreen.cpp:	CheckBox *enableSound = audioSettings->Add(new CheckBox(&g_Config.bEnableSound, a->T("Enable Sound")));
./UI/GameSettingsScreen.cpp:	PopupSliderChoice *volume = audioSettings->Add(new PopupSliderChoice(&g_Config.iGameVolume, VOLUME_OFF, VOLUMEHI_FULL, VOLUMEHI_FULL, a->T("Game volume"), screenManager()));
./UI/GameSettingsScreen.cpp:	PopupSliderChoice *reverbVolume = audioSettings->Add(new PopupSliderChoice(&g_Config.iReverbVolume, VOLUME_OFF, 2 * VOLUMEHI_FULL, VOLUMEHI_FULL, a->T("Reverb volume"), screenManager()));
./UI/GameSettingsScreen.cpp:	PopupSliderChoice *altVolume = audioSettings->Add(new PopupSliderChoice(&g_Config.iAltSpeedVolume, VOLUME_OFF, VOLUMEHI_FULL, NO_DEFAULT_INT, a->T("Alternate speed volume"), screenManager()));
./UI/GameSettingsScreen.cpp:	PopupSliderChoice *achievementVolume = audioSettings->Add(new PopupSliderChoice(&g_Config.iAchievementVolume, VOLUME_OFF, VOLUMEHI_FULL, MultiplierToVolume100(0.6f), ac->T("Achievement sound volume"), screenManager()));
./UI/GameSettingsScreen.cpp:	audioSettings->Add(new ItemHeader(a->T("UI sound")));
./UI/GameSettingsScreen.cpp:	audioSettings->Add(new CheckBox(&g_Config.bUISound, a->T("UI sound")));
./UI/GameSettingsScreen.cpp:	PopupSliderChoice *uiVolume = audioSettings->Add(new PopupSliderChoice(&g_Config.iUIVolume, 0, VOLUMEHI_FULL, VOLUMEHI_FULL, a->T("UI volume"), screenManager()));
./UI/GameSettingsScreen.cpp:	PopupSliderChoice *gamePreviewVolume = audioSettings->Add(new PopupSliderChoice(&g_Config.iGamePreviewVolume, VOLUME_OFF, VOLUMEHI_FULL, 75, a->T("Game preview volume"), screenManager()));
./UI/GameSettingsScreen.cpp:	bool sdlAudio = false;
./UI/GameSettingsScreen.cpp:#if defined(SDL)
./UI/GameSettingsScreen.cpp:	audioSettings->Add(new ItemHeader(a->T("Audio backend")));
./UI/GameSettingsScreen.cpp:	PopupMultiChoiceDynamic *audioDevice = audioSettings->Add(new PopupMultiChoiceDynamic(&g_Config.sAudioDevice, a->T("Device"), audioDeviceList, I18NCat::NONE, screenManager()));
./UI/GameSettingsScreen.cpp:	sdlAudio = true;
./UI/GameSettingsScreen.cpp:	PopupSliderChoice *bufferSize = audioSettings->Add(new PopupSliderChoice(&g_Config.iSDLAudioBufferSize, 0, 2048, 256, a->T("Buffer size"), screenManager()));
./UI/GameSettingsScreen.cpp:	audioSettings->Add(new SettingHint(di->T("This change will not take effect until PPSSPP is restarted.")));
./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./UI/GameSettingsScreen.cpp:		audioSettings->Add(new ItemHeader(a->T("Audio backend")));
./UI/GameSettingsScreen.cpp:		PopupMultiChoiceDynamic *audioDevice = audioSettings->Add(new PopupMultiChoiceDynamic(&g_Config.sAudioDevice, a->T("Device"), audioDeviceNames, I18NCat::NONE, screenManager(), &audioDeviceIds));
./UI/GameSettingsScreen.cpp:		CheckBox *autoAudio = audioSettings->Add(new CheckBox(&g_Config.bAutoAudioDevice, a->T("Use new audio devices automatically")));
./UI/GameSettingsScreen.cpp:	const bool isWindows = true;
./UI/GameSettingsScreen.cpp:	const bool isWindows = false;
./UI/GameSettingsScreen.cpp:	audioSettings->Add(new ItemHeader(a->T("Audio backend")));
./UI/GameSettingsScreen.cpp:	if (sdlAudio) {
./UI/GameSettingsScreen.cpp:		audioSettings->Add(new CheckBox(&g_Config.bAutoAudioDevice, a->T("Use new audio devices automatically")));
./UI/GameSettingsScreen.cpp:	CheckBox *extraAudio = audioSettings->Add(new CheckBox(&g_Config.bExtraAudioBuffering, a->T("AudioBufferingForBluetooth", "Bluetooth-friendly buffer (slower)")));
./UI/GameSettingsScreen.cpp:	const std::string audioErrorStr = AndroidAudio_GetErrorString(g_audioState);
./UI/GameSettingsScreen.cpp:		audioSettings->Add(new InfoItem(a->T("Audio Error"), audioErrorStr));
./UI/GameSettingsScreen.cpp:		audioSettings->Add(new ItemHeader(a->T("Microphone")));
./UI/GameSettingsScreen.cpp:		PopupMultiChoiceDynamic *MicChoice = audioSettings->Add(new PopupMultiChoiceDynamic(&g_Config.sMicDevice, a->T("Microphone Device"), micList, I18NCat::NONE, screenManager()));
./UI/GameSettingsScreen.cpp:#if defined(USING_WIN_UI) || (PPSSPP_PLATFORM(LINUX) && !PPSSPP_PLATFORM(ANDROID))
./UI/GameSettingsScreen.cpp:		controlsSettings->Add(new CheckBox(&g_Config.bIgnoreWindowsKey, co->T("Ignore Windows Key")));
./UI/GameSettingsScreen.cpp:#if defined(USING_WIN_UI) || defined(SDL) || PPSSPP_PLATFORM(ANDROID)
./UI/GameSettingsScreen.cpp:class MacAddressChooser : public UI::LinearLayout {
./UI/GameSettingsScreen.cpp:	MacAddressChooser(RequesterToken token, Path gamePath, std::string *value, std::string_view title, ScreenManager *screenManager, UI::LayoutParams *layoutParams = nullptr);
./UI/GameSettingsScreen.cpp:MacAddressChooser::MacAddressChooser(RequesterToken token, Path gamePath, std::string *value, std::string_view title, ScreenManager *screenManager, UI::LayoutParams *layoutParams) : UI::LinearLayout(ORIENT_HORIZONTAL, layoutParams) {
./UI/GameSettingsScreen.cpp:	Add(new PopupTextInputChoice(token, value, title, g_Config.sMACAddress, 17, screenManager, new LinearLayoutParams(1.0f)))->OnChange.Add([=](UI::EventParams &e) {
./UI/GameSettingsScreen.cpp:		if (g_Config.sMACAddress.size() != 17) {
./UI/GameSettingsScreen.cpp:		std::string_view confirmMessage = n->T("ChangeMacSaveConfirm", "Generate a new MAC address?");
./UI/GameSettingsScreen.cpp:		std::string_view warningMessage = n->T("ChangeMacSaveWarning", "Some games verify the MAC address when loading savedata, so this may break old saves.");
./UI/GameSettingsScreen.cpp:		std::string combined = g_Config.sMACAddress + "\n\n" + std::string(confirmMessage) + "\n\n" + std::string(warningMessage);
./UI/GameSettingsScreen.cpp:					g_Config.sMACAddress = CreateRandMAC();
./UI/GameSettingsScreen.cpp:	networkingSettings->Add(new MacAddressChooser(GetRequesterToken(), gamePath_, &g_Config.sMACAddress, n->T("Change Mac Address"), screenManager()));
./UI/GameSettingsScreen.cpp:#if (!defined(MOBILE_DEVICE) && !defined(USING_QT_UI)) || defined(USING_QT_UI) || PPSSPP_PLATFORM(ANDROID) // Missing only iOS?
./UI/GameSettingsScreen.cpp:#if !defined(MOBILE_DEVICE) && !defined(USING_QT_UI)  // TODO: Add all platforms where KEY_CHAR support is added
./UI/GameSettingsScreen.cpp:#elif defined(USING_QT_UI)
./UI/GameSettingsScreen.cpp:#if (!defined(MOBILE_DEVICE) && !defined(USING_QT_UI)) || defined(USING_QT_UI) || PPSSPP_PLATFORM(ANDROID)
./UI/GameSettingsScreen.cpp:#if defined(USING_QT_UI) || PPSSPP_PLATFORM(ANDROID)
./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(IOS)
./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(UWP)
./UI/GameSettingsScreen.cpp:	systemSettings->Add(new CheckBox(&g_Config.bIgnoreBadMemAccess, sy->T("Ignore bad memory accesses")));
./UI/GameSettingsScreen.cpp:	// TODO: Make this setting available on Mac too.
./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./UI/GameSettingsScreen.cpp:#if defined(_WIN32) || (defined(USING_QT_UI) && !defined(MOBILE_DEVICE))
./UI/GameSettingsScreen.cpp:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP)
./UI/GameSettingsScreen.h:	void CreateAudioSettings(UI::ViewGroup *audioSettings);
./UI/GameSettingsScreen.h:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP)
./UI/GameSettingsScreen.h:#if PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./UI/GamepadEmu.cpp:// On IOS, nudge the bottom button up a little to avoid the task switcher.
./UI/GamepadEmu.cpp:#if PPSSPP_PLATFORM(IOS)
./UI/IAPScreen.cpp:// NOTE: This currently only used on iOS, to present the availablility of getting PPSSPP Gold through IAP.
./UI/IAPScreen.cpp:#elif PPSSPP_PLATFORM(IOS)
./UI/IAPScreen.cpp:		System_LaunchUrl(LaunchUrlType::BROWSER_URL, "https://www.ppsspp.org/buygold_ios");
./UI/IAPScreen.h:// NOTE: This is only used on iOS, to present the availablility of getting PPSSPP Gold through IAP.
./UI/ImDebugger/ImConsole.cpp:	ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(420, 300), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(420, 300), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(320, 600), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(320, 600), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(320, 600), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(420, 300), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(420, 300), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(420, 500), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImDebugger.cpp:	if (g_Config.iAudioPlaybackMode == (int)AudioSyncMode::GRANULAR) {
./UI/ImDebugger/ImDebugger.cpp:	if (ImGui::BeginTable("audios", 7, ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersH)) {
./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(500, 400), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImDebugger.cpp:		"On a real PSP, these would be loaded from the BIOS.\n");
./UI/ImDebugger/ImDebugger.cpp:	reqToken_ = g_requestManager.GenerateRequesterToken();
./UI/ImDebugger/ImDebugger.cpp:			ImGui::MenuItem("Ignore bad memory accesses", nullptr, &g_Config.bIgnoreBadMemAccess);
./UI/ImDebugger/ImDebugger.cpp:				System_BrowseForFile(reqToken_, "Load PPSSPP symbol map", BrowseFileType::SYMBOL_MAP, [&](const char *responseString, int) {
./UI/ImDebugger/ImDebugger.cpp:				System_BrowseForFileSave(reqToken_, "Save PPSSPP symbol map", "symbols.ppmap", BrowseFileType::SYMBOL_MAP, [](const char *responseString, int) {
./UI/ImDebugger/ImDebugger.cpp:				System_BrowseForFile(reqToken_, "Load No$ symbol map", BrowseFileType::SYMBOL_MAP, [&](const char *responseString, int) {
./UI/ImDebugger/ImDebugger.cpp:				System_BrowseForFileSave(reqToken_, "Save No$ symbol map", "symbols.sym", BrowseFileType::SYMBOL_MAP, [](const char *responseString, int) {
./UI/ImDebugger/ImDebugger.cpp:	sync.SetSection(ini->GetOrCreateSection("Windows"));
./UI/ImDebugger/ImDebugger.h:// * If windows/objects need state, prefix the class name with Im and just store straight in parent struct
./UI/ImDebugger/ImDebugger.h:	RequesterToken reqToken_;
./UI/ImDebugger/ImDisasmView.cpp:	windowStart_ = curAddress_;
./UI/ImDebugger/ImDisasmView.cpp:	g_disassemblyManager.analyze(windowStart_, g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_) - windowStart_);
./UI/ImDebugger/ImDisasmView.cpp:	u32 windowEnd = g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_);
./UI/ImDebugger/ImDisasmView.cpp:	if (line.first < windowStart_) {
./UI/ImDebugger/ImDisasmView.cpp:	if (line.second < windowStart_) {
./UI/ImDebugger/ImDisasmView.cpp:	const bool is_active = ImGui::IsItemActive();   // Held
./UI/ImDebugger/ImDisasmView.cpp:	unsigned int address = windowStart_;
./UI/ImDebugger/ImDisasmView.cpp:	std::vector<BranchLine> branchLines = g_disassemblyManager.getBranchLines(windowStart_, address - windowStart_);
./UI/ImDebugger/ImDisasmView.cpp:			windowStart_ = g_disassemblyManager.getNthPreviousAddress(windowStart_, 4);
./UI/ImDebugger/ImDisasmView.cpp:			windowStart_ = g_disassemblyManager.getNthNextAddress(windowStart_, 4);
./UI/ImDebugger/ImDisasmView.cpp:		windowStart_ = g_disassemblyManager.getNthNextAddress(windowStart_, amount);
./UI/ImDebugger/ImDisasmView.cpp:		windowStart_ = g_disassemblyManager.getNthPreviousAddress(windowStart_, amount);
./UI/ImDebugger/ImDisasmView.cpp:	if (line.type == DISTYPE_OPCODE || line.type == DISTYPE_MACRO) {
./UI/ImDebugger/ImDisasmView.cpp:	u32 windowEnd = g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_);
./UI/ImDebugger/ImDisasmView.cpp:			setCurAddress(windowStart_, ImGui::IsKeyDown(ImGuiKey_LeftShift));
./UI/ImDebugger/ImDisasmView.cpp:			windowStart_ = g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_);
./UI/ImDebugger/ImDisasmView.cpp:			windowStart_ = g_disassemblyManager.getNthPreviousAddress(windowStart_, visibleRows_);
./UI/ImDebugger/ImDisasmView.cpp:			if (curAddress_ != windowStart_ && curAddressIsVisible()) {
./UI/ImDebugger/ImDisasmView.cpp:				setCurAddress(windowStart_, KeyDownAsync(VK_SHIFT));
./UI/ImDebugger/ImDisasmView.cpp:				setCurAddress(g_disassemblyManager.getNthPreviousAddress(windowStart_, visibleRows_), KeyDownAsync(VK_SHIFT));
./UI/ImDebugger/ImDisasmView.cpp:	u32 windowEnd = g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_);
./UI/ImDebugger/ImDisasmView.cpp:	if (curAddress_ < windowStart_)
./UI/ImDebugger/ImDisasmView.cpp:		windowStart_ = curAddress_;
./UI/ImDebugger/ImDisasmView.cpp:		windowStart_ = g_disassemblyManager.getNthPreviousAddress(curAddress_, visibleRows_ - 1);
./UI/ImDebugger/ImDisasmView.cpp:	u32 windowEnd = g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_);
./UI/ImDebugger/ImDisasmView.cpp:	return curAddress_ >= windowStart_ && curAddress_ < windowEnd;
./UI/ImDebugger/ImDisasmView.cpp:	if (line.type == DISTYPE_OPCODE || line.type == DISTYPE_MACRO) {
./UI/ImDebugger/ImDisasmView.cpp:	return g_disassemblyManager.getNthNextAddress(windowStart_, line);
./UI/ImDebugger/ImDisasmView.cpp:	u32 windowEnd = g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_);
./UI/ImDebugger/ImDisasmView.cpp:		windowStart_ = g_disassemblyManager.getNthPreviousAddress(newPc, visibleRows_ - 2);
./UI/ImDebugger/ImDisasmView.cpp:	ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImDisasmView.h:		u32 windowEnd = g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_);
./UI/ImDebugger/ImDisasmView.h:		if (newAddress < windowStart_ || newAddress >= windowEnd) {
./UI/ImDebugger/ImDisasmView.h:			windowStart_ = g_disassemblyManager.getNthPreviousAddress(newAddress, visibleRows_ / 2);
./UI/ImDebugger/ImDisasmView.h:	u32 windowStart_ = 0;
./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(300, 500), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(600, 500), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImGe.cpp:	u32 windowStartAddr = selectedAddr_ - (numLines / 2) * instrWidth;
./UI/ImDebugger/ImGe.cpp:	float pcY = canvas_p0.y + ((pc - windowStartAddr) / instrWidth) * lineHeight;
./UI/ImDebugger/ImGe.cpp:	float stallY = canvas_p0.y + ((stallAddr - windowStartAddr) / instrWidth) * lineHeight;
./UI/ImDebugger/ImGe.cpp:	u32 addr = windowStartAddr;
./UI/ImDebugger/ImGe.cpp:	int selectedY = canvas_p0.y + ((selectedAddr_ - windowStartAddr) / instrWidth) * lineHeight;
./UI/ImDebugger/ImGe.cpp:		int dragY = canvas_p0.y + ((dragAddr_ - windowStartAddr) / instrWidth) * lineHeight;
./UI/ImDebugger/ImGe.cpp:	const bool is_active = ImGui::IsItemActive();   // Held
./UI/ImDebugger/ImGe.cpp:		dragAddr_ = windowStartAddr + ((int)mouse_pos_in_canvas.y / lineHeight) * instrWidth;
./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(300, 500), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(300, 500), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImGe.h:// GE-related windows of the ImDebugger
./UI/ImDebugger/ImJitViewer.cpp:	ImGui::SetNextWindowSize(ImVec2(500, 400), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImMemView.cpp:	windowStart_ = curAddress_;
./UI/ImDebugger/ImMemView.cpp:	const bool is_active = ImGui::IsItemActive();   // Held
./UI/ImDebugger/ImMemView.cpp:	std::vector<MemBlockInfo> memRangeInfo = FindMemInfoByFlag(highlightFlags_, windowStart_, (visibleRows_ + 1) * rowSize_);
./UI/ImDebugger/ImMemView.cpp:	_assert_msg_(((windowStart_ | rowSize_) & 3) == 0, "readMemory() can't handle unaligned reads");
./UI/ImDebugger/ImMemView.cpp:		uint32_t address = windowStart_ + i * rowSize_;
./UI/ImDebugger/ImMemView.cpp:			windowStart_ -= rowSize_ * 4;
./UI/ImDebugger/ImMemView.cpp:			windowStart_ += rowSize_ * 4;
./UI/ImDebugger/ImMemView.cpp:	int lineAddress = windowStart_ + line * rowSize_;
./UI/ImDebugger/ImMemView.cpp:	u32 windowEnd = windowStart_ + lines * rowSize_;
./UI/ImDebugger/ImMemView.cpp:	if (curAddress_ < windowStart_ || curAddress_ >= windowEnd) {
./UI/ImDebugger/ImMemView.cpp:		windowStart_ = curAddress_ & ~15;
./UI/ImDebugger/ImMemView.cpp:	windowStart_ += lines * rowSize_;
./UI/ImDebugger/ImMemView.cpp:	u32 windowEnd = windowStart_ + visibleRows_ * rowSize_;
./UI/ImDebugger/ImMemView.cpp:	if (curAddress_ < windowStart_) {
./UI/ImDebugger/ImMemView.cpp:		windowStart_ = curAddress_ & ~15;
./UI/ImDebugger/ImMemView.cpp:		windowStart_ = (curAddress_ - (visibleRows_ - 1) * rowSize_) & ~15;
./UI/ImDebugger/ImMemView.cpp:	ImGui::SetNextWindowSize(ImVec2(200, 300), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImMemView.cpp:		// SDL/SDLMain.cpp
./UI/ImDebugger/ImMemView.cpp:	ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
./UI/ImDebugger/ImMemView.h:	uint32_t windowStart_ = 0x08800000;
./UI/ImDebugger/ImStructViewer.cpp:	ImGui::SetNextWindowSize(ImVec2(750, 550), ImGuiCond_FirstUseEver);
./UI/MainScreen.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./UI/MainScreen.cpp:#if PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(SWITCH) || defined(USING_WIN_UI) || PPSSPP_PLATFORM(UWP) || PPSSPP_PLATFORM(IOS)
./UI/MainScreen.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./UI/MainScreen.cpp:#elif PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./UI/MainScreen.cpp:#if PPSSPP_PLATFORM(IOS)
./UI/MainScreen.cpp:constexpr std::string_view getGamesUri = "https://www.ppsspp.org/getgames_ios";
./UI/MainScreen.cpp:constexpr std::string_view getHomebrewUri = "https://www.ppsspp.org/gethomebrew_ios";
./UI/MainScreen.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE) && !PPSSPP_PLATFORM(ANDROID)
./UI/MainScreen.cpp:	// Officially, iOS apps should not have exit buttons. Remove it to maximize app store review chances.
./UI/MainScreen.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./UI/MainScreen.cpp:		System_LaunchUrl(LaunchUrlType::BROWSER_URL, "https://www.ppsspp.org/buygold_ios");
./UI/MemStickScreen.cpp:#if PPSSPP_PLATFORM(UWP)
./UI/MemStickScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./UI/MemStickScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./UI/MemStickScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./UI/MemStickScreen.cpp:#if PPSSPP_PLATFORM(UWP)
./UI/MemStickScreen.h:#if PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./UI/MemStickScreen.h:#if PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./UI/MiscScreens.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./UI/MiscScreens.cpp:		// On Windows, we put the yes button on the left.
./UI/MiscScreens.cpp:#if !(defined(USING_QT_UI) || PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(ANDROID))
./UI/MiscScreens.cpp:#if !PPSSPP_PLATFORM(UWP) || defined(_DEBUG)
./UI/MiscScreens.cpp:	// Draw the graphics API, except on UWP where it's always D3D11
./UI/MiscScreens.cpp:	specialthanksangelxwind += cr->T("iOS builds");
./UI/MiscScreens.cpp:	specialthanksW_MS += cr->T("iOS builds");
./UI/MiscScreens.cpp:#if defined(USING_QT_UI)
./UI/MiscScreens.cpp:		"Qt",
./UI/MiscScreens.cpp:#if defined(SDL)
./UI/MiscScreens.cpp:		"SDL",
./UI/NativeApp.cpp:// Android, Linux, MacOSX.
./UI/NativeApp.cpp:// Windows has its own code that bypasses the framework entirely.
./UI/NativeApp.cpp:#include "Windows/WindowsAudio.h"
./UI/NativeApp.cpp:#include "Windows/MainWindow.h"
./UI/NativeApp.cpp:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP)
./UI/NativeApp.cpp:#include "Windows/CaptureDevice.h"
./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(UWP)
./UI/NativeApp.cpp:#include "UWP/UWPHelpers/InputHelpers.h"
./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(IOS)
./UI/NativeApp.cpp:#include "ios/iOSCoreAudio.h"
./UI/NativeApp.cpp:#include <mach-o/dyld.h>
./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./UI/NativeApp.cpp:#if !defined(__LIBRETRO__)
./UI/NativeApp.cpp:#if defined(USING_WIN_UI) && !PPSSPP_PLATFORM(UWP)
./UI/NativeApp.cpp:#if !PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(UWP)
./UI/NativeApp.cpp:	net::Init();  // This needs to happen before we load the config. So on Windows we also run it in Main. It's fine to call multiple times.
./UI/NativeApp.cpp:	// on iOS it's even the path to bundled app assets. It's a mess.
./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(MAC)
./UI/NativeApp.cpp:#if !PPSSPP_PLATFORM(UWP)
./UI/NativeApp.cpp:#elif PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./UI/NativeApp.cpp:#elif PPSSPP_PLATFORM(IOS)
./UI/NativeApp.cpp:#elif PPSSPP_PLATFORM(MAC)
./UI/NativeApp.cpp:#elif !PPSSPP_PLATFORM(WINDOWS)
./UI/NativeApp.cpp:#if !PPSSPP_PLATFORM(WINDOWS)
./UI/NativeApp.cpp:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP)
./UI/NativeApp.cpp:		winCamera = new WindowsCaptureDevice(CAPTUREDEVIDE_TYPE::VIDEO);
./UI/NativeApp.cpp:		winMic = new WindowsCaptureDevice(CAPTUREDEVIDE_TYPE::Audio);
./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(MAC)
./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./UI/NativeApp.cpp:	// This can only be accessed from Windows currently, and causes linking errors with headless etc.
./UI/NativeApp.cpp:			// OSX 10.6 and SDL 1.2 bug.
./UI/NativeApp.cpp:#if defined(__APPLE__) && !defined(USING_QT_UI)
./UI/NativeApp.cpp:#if !PPSSPP_PLATFORM(WINDOWS) && !defined(ANDROID)
./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(UWP)
./UI/NativeApp.cpp:#if !PPSSPP_PLATFORM(IOS)
./UI/NativeApp.cpp:// name should be simple alphanumerics to avoid problems on Windows.
./UI/NativeApp.cpp:static bool IsWindowSmall(int pixelWidth, int pixelHeight) {
./UI/NativeApp.cpp:	if (!g_Config.bShrinkIfWindowSmall) {
./UI/NativeApp.cpp:	// Can't take this from config as it will not be set if windows is maximized.
./UI/NativeApp.cpp:	bool smallWindow = IsWindowSmall(pixel_width, pixel_height);
./UI/RemoteISOScreen.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./UI/RemoteISOScreen.cpp:#include "Common/CommonWindows.h"
./UI/RemoteISOScreen.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./UI/RemoteISOScreen.cpp:	firewallWarning_ = tab->Add(new TextView(ri->T("RemoteISOWinFirewall", "WARNING: Windows Firewall is blocking sharing"), new LinearLayoutParams(Margins(12, 5, 0, 5))));
./UI/Store.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./UI/Store.h:	int contentRating;  // 100 means to hide it on iOS. No other values defined yet.
./UI/SystemInfoScreen.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./UI/SystemInfoScreen.cpp:#if PPSSPP_PLATFORM(IOS)
./UI/SystemInfoScreen.cpp:#if PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(UWP)
./UI/SystemInfoScreen.cpp:	// Don't show on Windows, since it's always treated as 60 there.
./UI/UI.vcxproj:    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
./UI/UI.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./UI/UI.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./UI/UI.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./UI/UI.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./UI/UI.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./UI/UI.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./UI/UI.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./UI/UI.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./UI/UI.vcxproj:  <PropertyGroup Label="UserMacros" />
./UI/UI.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/zlib;../ext</AdditionalIncludeDirectories>
./UI/UI.vcxproj:      <SubSystem>Windows</SubSystem>
./UI/UI.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/zlib;../ext</AdditionalIncludeDirectories>
./UI/UI.vcxproj:      <SubSystem>Windows</SubSystem>
./UI/UI.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/zlib;../ext</AdditionalIncludeDirectories>
./UI/UI.vcxproj:      <SubSystem>Windows</SubSystem>
./UI/UI.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/zlib;../ext</AdditionalIncludeDirectories>
./UI/UI.vcxproj:      <SubSystem>Windows</SubSystem>
./UI/UI.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/zlib;../ext</AdditionalIncludeDirectories>
./UI/UI.vcxproj:      <SubSystem>Windows</SubSystem>
./UI/UI.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/zlib;../ext</AdditionalIncludeDirectories>
./UI/UI.vcxproj:      <SubSystem>Windows</SubSystem>
./UI/UIAtlas.cpp:#if PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./.editorconfig:[libretro/**.{cpp,h}]
./platform_references_code.txt:./.editorconfig:[SDL/SDLMain.mm]
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/bug.yml:        Upload logs if possible (use DebugLog.bat on Windows or [adb logcat][] on Android.)
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/bug.yml:        - Windows
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/bug.yml:        - libretro / Retroarch
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/bug.yml:        - iOS
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/bug.yml:        - Linux / BSD
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/bug.yml:        - macOS
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/bug.yml:        - UWP / Xbox
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/build.yml:        - Windows
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/build.yml:        - libretro / Retroarch
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/build.yml:        - iOS
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/build.yml:        - Linux / BSD
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/build.yml:        - macOS
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/build.yml:        - UWP / Xbox
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/build.yml:      placeholder: Arch Linux 2021.08.01
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/feature.yml:        - Windows
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/feature.yml:        - libretro / Retroarch
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/feature.yml:        - iOS
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/feature.yml:        - Linux / BSD
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/feature.yml:        - macOS
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/feature.yml:        - UWP / Xbox
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/graphics.yml:        - Windows
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/graphics.yml:        - libretro / Retroarch
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/graphics.yml:        - iOS
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/graphics.yml:        - Linux / BSD
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/graphics.yml:        - macOS
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/graphics.yml:        - UWP / Xbox
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/performance.yml:        - Windows
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/performance.yml:        - libretro / Retroarch
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/performance.yml:        - iOS
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/performance.yml:        - Linux / BSD
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/performance.yml:        - macOS
./platform_references_code.txt:./.github/ISSUE_TEMPLATE/performance.yml:        - UWP / Xbox
./platform_references_code.txt:./.github/workflows/appimage.yml:name: Generate Linux AppImage
./platform_references_code.txt:./.github/workflows/appimage.yml:  SDL_AUDIODRIVER: "dummy" #"disk"
./platform_references_code.txt:./.github/workflows/appimage.yml:  #SDL_VIDEODRIVER: "dummy"
./platform_references_code.txt:./.github/workflows/appimage.yml:    container: ghcr.io/pkgforge-dev/archlinux:latest
./platform_references_code.txt:./.github/workflows/appimage.yml:      CCACHE_SLOPPINESS: time_macros
./platform_references_code.txt:./.github/workflows/appimage.yml:          #sudo apt-get install -q -y libstdc++6 ffmpeg libvulkan-dev libglew-dev libsdl2-ttf-dev libsdl2-dev libasound2-dev alsa-base alsa-utils libglu1-mesa pulseaudio linux-modules-extra-$(uname -r) #build-essential #plocate
./platform_references_code.txt:./.github/workflows/appimage.yml:          # Archlinux
./platform_references_code.txt:./.github/workflows/appimage.yml:          EXTRA_PACKAGES="https://raw.githubusercontent.com/pkgforge-dev/Anylinux-AppImages/refs/heads/main/useful-tools/get-debloated-pkgs.sh"
./platform_references_code.txt:./.github/workflows/appimage.yml:            sdl2_ttf \
./platform_references_code.txt:./.github/workflows/appimage.yml:          export CCACHE_SLOPPINESS=clang_index_store,ivfsoverlay,include_file_ctime,include_file_mtime,modules,system_headers,time_macros
./platform_references_code.txt:./.github/workflows/appimage.yml:          # Install SDL2 from AUR
./platform_references_code.txt:./.github/workflows/appimage.yml:          #git clone https://aur.archlinux.org/sdl2.git
./platform_references_code.txt:./.github/workflows/appimage.yml:          mkdir sdl2
./platform_references_code.txt:./.github/workflows/appimage.yml:          pushd sdl2
./platform_references_code.txt:./.github/workflows/appimage.yml:          # Contributor: Sven-Hendrik Haase <svenstaro@archlinux.org>
./platform_references_code.txt:./.github/workflows/appimage.yml:          pkgname=sdl2
./platform_references_code.txt:./.github/workflows/appimage.yml:          url="https://www.libsdl.org"
./platform_references_code.txt:./.github/workflows/appimage.yml:          provides=('sdl2-compat')
./platform_references_code.txt:./.github/workflows/appimage.yml:          conflicts=('sdl2-compat')
./platform_references_code.txt:./.github/workflows/appimage.yml:          source=("https://github.com/libsdl-org/SDL/releases/download/release-${pkgver}/SDL2-${pkgver}.tar.gz")
./platform_references_code.txt:./.github/workflows/appimage.yml:            cd "$srcdir/SDL2-$pkgver"
./platform_references_code.txt:./.github/workflows/appimage.yml:            cmake -S SDL2-${pkgver} -B build -G Ninja \
./platform_references_code.txt:./.github/workflows/appimage.yml:              -D SDL_STATIC=OFF \
./platform_references_code.txt:./.github/workflows/appimage.yml:              -D SDL_RPATH=OFF
./platform_references_code.txt:./.github/workflows/appimage.yml:            sed -i "s/libSDL2\.a/libSDL2main.a/g" "$pkgdir"/usr/lib/cmake/SDL2/SDL2Targets-noconfig.cmake
./platform_references_code.txt:./.github/workflows/appimage.yml:            install -Dm644 SDL2-${pkgver}/LICENSE.txt "$pkgdir/usr/share/licenses/$pkgname/LICENSE"
./platform_references_code.txt:./.github/workflows/appimage.yml:          pacman --noconfirm -Rsndd sdl2-compat
./platform_references_code.txt:./.github/workflows/appimage.yml:          # End of Install SDL2 from AUR
./platform_references_code.txt:./.github/workflows/appimage.yml:          #./b.sh --release --no-sdl2 --no-png
./platform_references_code.txt:./.github/workflows/appimage.yml:          cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DUSE_SYSTEM_LIBSDL2=OFF -DUSE_SYSTEM_LIBPNG=OFF -DUSE_SYSTEM_FFMPEG=OFF -DCMAKE_C_COMPILER_LAUNCHER=ccache -DCMAKE_CXX_COMPILER_LAUNCHER=ccache .. 
./platform_references_code.txt:./.github/workflows/appimage.yml:          ldd ./build/PPSSPPSDL
./platform_references_code.txt:./.github/workflows/appimage.yml:          chmod +x ./build/PPSSPPSDL
./platform_references_code.txt:./.github/workflows/appimage.yml:          find . -name "PPSSPPSDL"
./platform_references_code.txt:./.github/workflows/appimage.yml:          name: linux-${{ steps.version.outputs.tag }}-${{ matrix.id }} AppImage
./platform_references_code.txt:./.github/workflows/build.yml:  build-windows:
./platform_references_code.txt:./.github/workflows/build.yml:    runs-on: windows-latest
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Create git-version.cpp for Windows # Not sure why the one at git-version-gen.cmd couldn't get the version properly.
./platform_references_code.txt:./.github/workflows/build.yml:        # Generate Windows/win-version.h too.
./platform_references_code.txt:./.github/workflows/build.yml:          echo "#define PPSSPP_WIN_VERSION_STRING `"$GIT_VERSION`"" > Windows/win-version.h
./platform_references_code.txt:./.github/workflows/build.yml:          echo "#define PPSSPP_WIN_VERSION_COMMA $WIN_VERSION_COMMA" >> Windows/win-version.h
./platform_references_code.txt:./.github/workflows/build.yml:          echo "#define PPSSPP_WIN_VERSION_NO_UPDATE 1" >> Windows/win-version.h
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Build Windows
./platform_references_code.txt:./.github/workflows/build.yml:      run: msbuild /m /p:TrackFileAccess=false /p:Configuration=${{ env.BUILD_CONFIGURATION }} /p:Platform=${{ matrix.platform }} Windows/PPSSPP.sln
./platform_references_code.txt:./.github/workflows/build.yml:        cp Windows/*.bat ppsspp/
./platform_references_code.txt:./.github/workflows/build.yml:      run: cp Windows/${{ matrix.platform }}/Release/*.exe ppsspp/
./platform_references_code.txt:./.github/workflows/build.yml:      run: cp Windows/Release/*.exe ppsspp/
./platform_references_code.txt:./.github/workflows/build.yml:        name: Windows ${{ matrix.platform }} build
./platform_references_code.txt:./.github/workflows/build.yml:        Compress-Archive -Path "ppsspp/*" -Update -DestinationPath "releases/PPSSPP-${{ github.ref_name }}-Windows-${{ matrix.platform }}.zip"
./platform_references_code.txt:./.github/workflows/build.yml:  build-uwp:
./platform_references_code.txt:./.github/workflows/build.yml:    runs-on: windows-latest
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Build UWP
./platform_references_code.txt:./.github/workflows/build.yml:      run: msbuild /m /p:TrackFileAccess=false /p:Configuration=${{ env.BUILD_CONFIGURATION }} /p:Platform=x64 /p:AppxPackageSigningEnabled=false UWP/PPSSPP_UWP.sln
./platform_references_code.txt:./.github/workflows/build.yml:  test-windows:
./platform_references_code.txt:./.github/workflows/build.yml:    runs-on: windows-latest
./platform_references_code.txt:./.github/workflows/build.yml:    needs: build-windows
./platform_references_code.txt:./.github/workflows/build.yml:        name: Windows x64 build
./platform_references_code.txt:./.github/workflows/build.yml:          args: ./b.sh --libretro_android ppsspp_libretro
./platform_references_code.txt:./.github/workflows/build.yml:          id: android-libretro
./platform_references_code.txt:./.github/workflows/build.yml:          extra: qt
./platform_references_code.txt:./.github/workflows/build.yml:          args: ./b.sh --qt
./platform_references_code.txt:./.github/workflows/build.yml:          id: qt
./platform_references_code.txt:./.github/workflows/build.yml:          extra: libretro
./platform_references_code.txt:./.github/workflows/build.yml:          args: make -C libretro -f Makefile -j2
./platform_references_code.txt:./.github/workflows/build.yml:          id: gcc-libretro
./platform_references_code.txt:./.github/workflows/build.yml:          extra: libretro
./platform_references_code.txt:./.github/workflows/build.yml:          args: make -C libretro -f Makefile -j2
./platform_references_code.txt:./.github/workflows/build.yml:          id: clang-libretro
./platform_references_code.txt:./.github/workflows/build.yml:        - os: macos-latest
./platform_references_code.txt:./.github/workflows/build.yml:          args: ./b.sh --headless --unittest --fat --no-png --no-sdl2
./platform_references_code.txt:./.github/workflows/build.yml:          id: macos
./platform_references_code.txt:./.github/workflows/build.yml:        - os: macos-latest
./platform_references_code.txt:./.github/workflows/build.yml:          extra: libretro_mac
./platform_references_code.txt:./.github/workflows/build.yml:          args: ./b.sh --libretro
./platform_references_code.txt:./.github/workflows/build.yml:          id: macos-libretro
./platform_references_code.txt:./.github/workflows/build.yml:        - os: macos-latest
./platform_references_code.txt:./.github/workflows/build.yml:          extra: ios
./platform_references_code.txt:./.github/workflows/build.yml:          args: ./b-ios.sh
./platform_references_code.txt:./.github/workflows/build.yml:          id: ios
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Fetch tags for macOS releases
./platform_references_code.txt:./.github/workflows/build.yml:      if: runner.os == 'macOS'
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Install Qt
./platform_references_code.txt:./.github/workflows/build.yml:      uses: jurplel/install-qt-action@d325aaf2a8baeeda41ad0b5d39f84a6af9bcf005 # v4.3.0
./platform_references_code.txt:./.github/workflows/build.yml:      if: matrix.extra == 'qt'
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Install Linux dependencies
./platform_references_code.txt:./.github/workflows/build.yml:      if: runner.os == 'Linux' && matrix.extra != 'android'
./platform_references_code.txt:./.github/workflows/build.yml:        sudo apt-get install libsdl2-dev libgl1-mesa-dev libglu1-mesa-dev libsdl2-ttf-dev libfontconfig1-dev
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Install iOS dependencies
./platform_references_code.txt:./.github/workflows/build.yml:      if: matrix.id == 'ios'
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Create iOS Version.txt file
./platform_references_code.txt:./.github/workflows/build.yml:      if: matrix.id == 'ios'
./platform_references_code.txt:./.github/workflows/build.yml:        mkdir -p build-ios/PPSSPP.app
./platform_references_code.txt:./.github/workflows/build.yml:        echo ${GIT_VERSION#v} > build-ios/PPSSPP.app/Version.txt
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Create macOS & iOS git-version.cpp for tagged release
./platform_references_code.txt:./.github/workflows/build.yml:      if: github.ref_type == 'tag' && (matrix.id == 'macos' || matrix.id == 'ios')
./platform_references_code.txt:./.github/workflows/build.yml:      # Disable ccache on macos for now, it's become buggy for some reason.
./platform_references_code.txt:./.github/workflows/build.yml:      if: matrix.id != 'macos'
./platform_references_code.txt:./.github/workflows/build.yml:        export CCACHE_SLOPPINESS=clang_index_store,ivfsoverlay,include_file_ctime,include_file_mtime,modules,system_headers,time_macros
./platform_references_code.txt:./.github/workflows/build.yml:        elif [ "$RUNNER_OS" == "macOS" ]; then
./platform_references_code.txt:./.github/workflows/build.yml:      if: matrix.extra == 'test' || matrix.id == 'ios'
./platform_references_code.txt:./.github/workflows/build.yml:        if [ -e build*/$BUILD_CONFIGURATION/PPSSPPSDL ]; then
./platform_references_code.txt:./.github/workflows/build.yml:          cp build*/$BUILD_CONFIGURATION/PPSSPPSDL ppsspp/
./platform_references_code.txt:./.github/workflows/build.yml:        elif [ -e build*/PPSSPPSDL.app ]; then
./platform_references_code.txt:./.github/workflows/build.yml:          cp -a build*/PPSSPPSDL.app ppsspp/
./platform_references_code.txt:./.github/workflows/build.yml:          zip -qry PPSSPPSDL.zip PPSSPPSDL.app
./platform_references_code.txt:./.github/workflows/build.yml:          rm -rf PPSSPPSDL.app
./platform_references_code.txt:./.github/workflows/build.yml:        elif [ -e build-ios/PPSSPP.app ]; then
./platform_references_code.txt:./.github/workflows/build.yml:          # Get the final files generated by b-ios.h script
./platform_references_code.txt:./.github/workflows/build.yml:        elif [ -e build*/PPSSPPSDL ]; then
./platform_references_code.txt:./.github/workflows/build.yml:          cp build*/PPSSPPSDL ppsspp/
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Upload iOS build
./platform_references_code.txt:./.github/workflows/build.yml:      if: matrix.id == 'ios'
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Create macOS release
./platform_references_code.txt:./.github/workflows/build.yml:      if: github.ref_type == 'tag' && matrix.id == 'macos'
./platform_references_code.txt:./.github/workflows/build.yml:      run: mv PPSSPPSDL.zip PPSSPPSDL-macOS-${GITHUB_REF_NAME}.zip
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Upload macOS & iOS release
./platform_references_code.txt:./.github/workflows/build.yml:      if: github.ref_type == 'tag' && (matrix.id == 'macos' || matrix.id == 'ios')
./platform_references_code.txt:./.github/workflows/build.yml:        os: [ubuntu-latest, macos-latest]
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Install Linux dependencies
./platform_references_code.txt:./.github/workflows/build.yml:      if: runner.os == 'Linux'
./platform_references_code.txt:./.github/workflows/build.yml:        sudo apt-get install libsdl2-dev libgl1-mesa-dev libglu1-mesa-dev libsdl2-ttf-dev libfontconfig1-dev
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Install macOS dependencies
./platform_references_code.txt:./.github/workflows/build.yml:      if: runner.os == 'macOS'
./platform_references_code.txt:./.github/workflows/build.yml:        git submodule update --init SDL/macOS
./platform_references_code.txt:./.github/workflows/build.yml:    - name: Install Linux dependencies (Alpine)
./platform_references_code.txt:./.github/workflows/build.yml:        apk add build-base wget git bash cmake python3 glu-dev sdl2-dev
./platform_references_code.txt:./.github/workflows/build.yml:        cd ffmpeg && ./linux_x86-64.sh
./platform_references_code.txt:./.github/workflows/manual_generate_ipa.yml:name: Manual Generate iOS IPA/DEB
./platform_references_code.txt:./.github/workflows/manual_generate_ipa.yml:  ios:
./platform_references_code.txt:./.github/workflows/manual_generate_ipa.yml:    runs-on: macos-latest
./platform_references_code.txt:./.github/workflows/manual_generate_ipa.yml:      - name: Install iOS dependencies
./platform_references_code.txt:./.github/workflows/manual_generate_ipa.yml:          mkdir -p build-ios/PPSSPP.app
./platform_references_code.txt:./.github/workflows/manual_generate_ipa.yml:          echo ${GIT_VERSION#v} > build-ios/PPSSPP.app/Version.txt
./platform_references_code.txt:./.github/workflows/manual_generate_ipa.yml:          key: ios
./platform_references_code.txt:./.github/workflows/manual_generate_ipa.yml:          export CCACHE_SLOPPINESS=pch_defines,clang_index_store,ivfsoverlay,include_file_ctime,include_file_mtime,modules,system_headers,time_macros
./platform_references_code.txt:./.github/workflows/manual_generate_ipa.yml:          ./b-ios.sh
./platform_references_code.txt:./.github/workflows/manual_generate_ipa.yml:          if [ -e build-ios/PPSSPP.app ]; then
./platform_references_code.txt:./.github/workflows/manual_generate_ipa.yml:            # Get the final files generated by b-ios.h script
./platform_references_code.txt:./.github/workflows/manual_generate_ipa.yml:          name: iOS-IPA build
./platform_references_code.txt:./.github/workflows/manual_generate_ipa.yml:          name: iOS-DEB build
./platform_references_code.txt:./.github/workflows/manual_generate_uwp.yml:name: Manual Generate UWP MSIX/MSIXBundle
./platform_references_code.txt:./.github/workflows/manual_generate_uwp.yml:  build-uwp:
./platform_references_code.txt:./.github/workflows/manual_generate_uwp.yml:    name: Generate ${{ github.event.inputs.buildConfiguration }} ${{ github.event.inputs.buildPlatform }} UWP
./platform_references_code.txt:./.github/workflows/manual_generate_uwp.yml:    runs-on: windows-latest
./platform_references_code.txt:./.github/workflows/manual_generate_uwp.yml:      #  id: cache-uwp
./platform_references_code.txt:./.github/workflows/manual_generate_uwp.yml:      #      UWP/${{ github.event.inputs.buildPlatform }}/${{ github.event.inputs.buildConfiguration }}/**
./platform_references_code.txt:./.github/workflows/manual_generate_uwp.yml:      #    key: uwp-${{ github.event.inputs.buildConfiguration }}-${{ github.event.inputs.buildPlatform }}
./platform_references_code.txt:./.github/workflows/manual_generate_uwp.yml:          msbuild UWP/PPSSPP_UWP.sln /m /p:TrackFileAccess=false /p:Configuration=${{ github.event.inputs.buildConfiguration }} /p:Platform=${{ github.event.inputs.buildPlatform }} /p:IncludeSymbols=${{ env.INCLUDE_SYMBOLS }} /p:AppxSymbolPackageEnabled=${{ env.INCLUDE_SYMBOLS }} /p:AppxPackageSigningEnabled=${{ github.event.inputs.signedPackage }} /p:PackageCertificateKeyFile=PPSSPP_UWP_TemporaryKey.pfx /p:AppxBundle=Never /p:UapAppxPackageBuildMode=SideloadOnly /p:AppxBundlePlatforms="${{ github.event.inputs.buildPlatform }}"
./platform_references_code.txt:./.github/workflows/manual_generate_uwp.yml:          msbuild UWP/PPSSPP_UWP.sln /m /p:TrackFileAccess=false /p:Configuration=${{ github.event.inputs.buildConfiguration }} /p:Platform=x64 /p:IncludeSymbols=${{ env.INCLUDE_SYMBOLS }} /p:AppxSymbolPackageEnabled=${{ env.INCLUDE_SYMBOLS }} /p:AppxPackageSigningEnabled=${{ github.event.inputs.signedPackage }} /p:PackageCertificateKeyFile=PPSSPP_UWP_TemporaryKey.pfx /p:AppxBundle=Always /p:UapAppxPackageBuildMode=SideloadOnly /p:AppxBundlePlatforms="x64|ARM64|ARM"
./platform_references_code.txt:./.github/workflows/manual_generate_uwp.yml:          #ls UWP/AppPackages/PPSSPP_UWP
./platform_references_code.txt:./.github/workflows/manual_generate_uwp.yml:          cp -r UWP/AppPackages/PPSSPP_UWP/*.* ppsspp/
./platform_references_code.txt:./.github/workflows/manual_generate_uwp.yml:          name: UWP-${{ github.event.inputs.buildConfiguration }}-${{ github.event.inputs.buildPlatform }} build
./platform_references_code.txt:./.gitignore:Windows/.vs
./platform_references_code.txt:./.gitignore:Windows/x64
./platform_references_code.txt:./.gitignore:Windows/ARM
./platform_references_code.txt:./.gitignore:Windows/ARM64
./platform_references_code.txt:./.gitignore:Windows/ipch
./platform_references_code.txt:./.gitignore:Windows/bin-release
./platform_references_code.txt:./.gitignore:Windows/win-version.h
./platform_references_code.txt:./.gitignore:Windows/win-version-*.tmp
./platform_references_code.txt:./.gitignore:PPSSPPWindows64.exe.manifest
./platform_references_code.txt:./.gitignore:PPSSPPWindows.exe.manifest
./platform_references_code.txt:./.gitignore:PPSSPPWindowsARM64.exe.manifest
./platform_references_code.txt:./.gitignore:PPSSPPWindowsARM.exe.manifest
./platform_references_code.txt:./.gitignore:UWP/icph
./platform_references_code.txt:./.gitignore:UWP/*.ipch
./platform_references_code.txt:./.gitignore:UWP/Content/*
./platform_references_code.txt:./.gitignore:!UWP/Content/.empty
./platform_references_code.txt:./.gitignore:UWP/.vs
./platform_references_code.txt:./.gitignore:# For Mac
./platform_references_code.txt:./.gitignore:PPSSPPSDL.app
./platform_references_code.txt:./.gitignore:# Qt Linguist files
./platform_references_code.txt:./.gitignore:# Temp file used by jenkins windows build (TODO: remove)
./platform_references_code.txt:./.gitignore:Windows/compileData*
./platform_references_code.txt:./.gitignore:Windows/*.ipch
./platform_references_code.txt:./.gitignore:Windows/imgui.ini
./platform_references_code.txt:./.gitignore:# Libretro build
./platform_references_code.txt:./.gitignore:libretro/obj/local
./platform_references_code.txt:./.gitlab-ci.yml:# DESCRIPTION: GitLab CI/CD for libRetro (NOT FOR GitLab-proper)
./platform_references_code.txt:./.gitlab-ci.yml:    CORE_ARGS: -DLIBRETRO=ON
./platform_references_code.txt:./.gitlab-ci.yml:    MAKEFILE_PATH: libretro
./platform_references_code.txt:./.gitlab-ci.yml:  # Windows 64bit
./platform_references_code.txt:./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./platform_references_code.txt:./.gitlab-ci.yml:    file: '/windows-x64-msvc19-msys2.yml'
./platform_references_code.txt:./.gitlab-ci.yml:  # Windows 32bit
./platform_references_code.txt:./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./platform_references_code.txt:./.gitlab-ci.yml:    file: '/windows-i686-msvc19-msys2.yml'
./platform_references_code.txt:./.gitlab-ci.yml:  # Linux
./platform_references_code.txt:./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./platform_references_code.txt:./.gitlab-ci.yml:    file: '/linux-cmake.yml'
./platform_references_code.txt:./.gitlab-ci.yml:  # MacOS 64-bit
./platform_references_code.txt:./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./platform_references_code.txt:./.gitlab-ci.yml:  # MacOS arm64
./platform_references_code.txt:./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./platform_references_code.txt:./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./platform_references_code.txt:./.gitlab-ci.yml:  # iOS
./platform_references_code.txt:./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./platform_references_code.txt:./.gitlab-ci.yml:    file: '/ios-cmake.yml'
./platform_references_code.txt:./.gitlab-ci.yml:  - project: 'libretro-infrastructure/ci-templates'
./platform_references_code.txt:./.gitlab-ci.yml:# Windows 64-bit
./platform_references_code.txt:./.gitlab-ci.yml:libretro-build-windows-x64:
./platform_references_code.txt:./.gitlab-ci.yml:    - .libretro-windows-x64-msvc19-msys2-make-default
./platform_references_code.txt:./.gitlab-ci.yml:# Windows 32-bit
./platform_references_code.txt:./.gitlab-ci.yml:libretro-build-windows-i686:
./platform_references_code.txt:./.gitlab-ci.yml:    - .libretro-windows-i686-msvc19-msys2-make-default
./platform_references_code.txt:./.gitlab-ci.yml:# Linux 64-bit
./platform_references_code.txt:./.gitlab-ci.yml:libretro-build-linux-x64:
./platform_references_code.txt:./.gitlab-ci.yml:    - .libretro-linux-cmake-x86_64
./platform_references_code.txt:./.gitlab-ci.yml:# Linux 32-bit
./platform_references_code.txt:./.gitlab-ci.yml:libretro-build-linux-i686:
./platform_references_code.txt:./.gitlab-ci.yml:    - .libretro-linux-cmake-x86
./platform_references_code.txt:./.gitlab-ci.yml:# MacOS 64-bit
./platform_references_code.txt:./.gitlab-ci.yml:libretro-build-osx-x64:
./platform_references_code.txt:./.gitlab-ci.yml:    CORE_ARGS: -DLIBRETRO=ON -DUSE_SYSTEM_LIBPNG=OFF
./platform_references_code.txt:./.gitlab-ci.yml:    - .libretro-osx-cmake-x86_64
./platform_references_code.txt:./.gitlab-ci.yml:# MacOS 64-bit
./platform_references_code.txt:./.gitlab-ci.yml:libretro-build-osx-arm64:
./platform_references_code.txt:./.gitlab-ci.yml:    - .libretro-osx-cmake-arm64
./platform_references_code.txt:./.gitlab-ci.yml:libretro-build-android-armeabi-v7a:
./platform_references_code.txt:./.gitlab-ci.yml:    - .libretro-android-cmake-armeabi-v7a
./platform_references_code.txt:./.gitlab-ci.yml:libretro-build-android-arm64-v8a:
./platform_references_code.txt:./.gitlab-ci.yml:    - .libretro-android-cmake-arm64-v8a
./platform_references_code.txt:./.gitlab-ci.yml:libretro-build-android-x86_64:
./platform_references_code.txt:./.gitlab-ci.yml:    - .libretro-android-cmake-x86_64
./platform_references_code.txt:./.gitlab-ci.yml:libretro-build-android-x86:
./platform_references_code.txt:./.gitlab-ci.yml:    - .libretro-android-cmake-x86
./platform_references_code.txt:./.gitlab-ci.yml:# iOS arm64
./platform_references_code.txt:./.gitlab-ci.yml:libretro-build-ios-arm64:
./platform_references_code.txt:./.gitlab-ci.yml:    - .libretro-ios-cmake-arm64
./platform_references_code.txt:./.gitlab-ci.yml:    CORE_ARGS: -DCMAKE_TOOLCHAIN_FILE=cmake/Toolchains/ios.cmake -DLIBRETRO=ON
./platform_references_code.txt:./.gitlab-ci.yml:libretro-build-tvos-arm64:
./platform_references_code.txt:./.gitlab-ci.yml:    - .libretro-tvos-cmake-arm64
./platform_references_code.txt:./.gitlab-ci.yml:    CORE_ARGS: -DIOS_PLATFORM=TVOS -DCMAKE_TOOLCHAIN_FILE=cmake/Toolchains/ios.cmake -DLIBRETRO=ON
./platform_references_code.txt:./.ycm_extra_conf.py:'-Wno-variadic-macros',
./platform_references_code.txt:./CMakeLists.txt:add_compile_definitions(__STDC_CONSTANT_MACROS)
./platform_references_code.txt:./CMakeLists.txt:		# M1 Mac
./platform_references_code.txt:./CMakeLists.txt:				set(CMAKE_ASM_FLAGS "${CMAKE_ASM_FLAGS} -target armv7a-none-linux-android")
./platform_references_code.txt:./CMakeLists.txt:if(NOT ANDROID AND NOT IOS)
./platform_references_code.txt:./CMakeLists.txt:if(${CMAKE_SYSTEM_NAME} MATCHES "Linux" AND NOT USE_LIBNX)
./platform_references_code.txt:./CMakeLists.txt:	set(LINUX ON)
./platform_references_code.txt:./CMakeLists.txt:	add_compile_definitions(__STDC_CONSTANT_MACROS)
./platform_references_code.txt:./CMakeLists.txt:	set(MACOSX ON)
./platform_references_code.txt:./CMakeLists.txt:# We only support Vulkan on Unix, macOS (by MoltenVK), Android and Windows.
./platform_references_code.txt:./CMakeLists.txt:# Default to bundled SDL2 on macOS, system SDL2 elsewhere.
./platform_references_code.txt:./CMakeLists.txt:if(APPLE AND NOT IOS)
./platform_references_code.txt:./CMakeLists.txt:	set(DEFAULT_USE_SYSTEM_LIBSDL2 OFF)
./platform_references_code.txt:./CMakeLists.txt:	set(DEFAULT_USE_SYSTEM_LIBSDL2 ON)
./platform_references_code.txt:./CMakeLists.txt:if(NOT IOS)
./platform_references_code.txt:./CMakeLists.txt:	list(APPEND CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/sdl)
./platform_references_code.txt:./CMakeLists.txt:	if(IOS_APP_STORE)
./platform_references_code.txt:./CMakeLists.txt:		message("WARNING: Gold build for iOS is deprecated")
./platform_references_code.txt:./CMakeLists.txt:	if(NOT IOS_APP_STORE)
./platform_references_code.txt:./CMakeLists.txt:	message("USE_IAP for iOS enabled")
./platform_references_code.txt:./CMakeLists.txt:if(IOS_APP_STORE)
./platform_references_code.txt:./CMakeLists.txt:	add_compile_definitions(PPSSPP_PLATFORM_IOS_APP_STORE)
./platform_references_code.txt:./CMakeLists.txt:	message("iOS App Store build")
./platform_references_code.txt:./CMakeLists.txt:elseif(IOS)
./platform_references_code.txt:./CMakeLists.txt:	message("iOS sideload build")
./platform_references_code.txt:./CMakeLists.txt:option(USING_QT_UI "Set to ON if you wish to use the Qt frontend wrapper" ${USING_QT_UI})
./platform_references_code.txt:./CMakeLists.txt:option(LIBRETRO "Set to ON to generate the libretro target" OFF)
./platform_references_code.txt:./CMakeLists.txt:option(USE_SYSTEM_LIBSDL2 "Dynamically link against system SDL2" ${DEFAULT_USE_SYSTEM_LIBSDL2})
./platform_references_code.txt:./CMakeLists.txt:if(LIBRETRO)
./platform_references_code.txt:./CMakeLists.txt:	add_compile_definitions(__LIBRETRO__)
./platform_references_code.txt:./CMakeLists.txt:if(ANDROID AND NOT LIBRETRO)
./platform_references_code.txt:./CMakeLists.txt:if(NOT ANDROID AND NOT WIN32 AND (NOT APPLE OR IOS))
./platform_references_code.txt:./CMakeLists.txt:if(NOT LIBRETRO AND NOT IOS AND NOT MACOSX)
./platform_references_code.txt:./CMakeLists.txt:	find_package(SDL2)
./platform_references_code.txt:./CMakeLists.txt:	find_package(SDL2_ttf)
./platform_references_code.txt:./CMakeLists.txt:	# TODO: this can be removed once CI supports newer SDL2_ttf
./platform_references_code.txt:./CMakeLists.txt:	if (NOT SDL2_ttf_FOUND)
./platform_references_code.txt:./CMakeLists.txt:			pkg_check_modules(SDL2_ttf_PKGCONFIG IMPORTED_TARGET SDL2_ttf)
./platform_references_code.txt:./CMakeLists.txt:if(MACOSX AND NOT IOS)
./platform_references_code.txt:./CMakeLists.txt:	if(USE_SYSTEM_LIBSDL2)
./platform_references_code.txt:./CMakeLists.txt:		find_package(SDL2)
./platform_references_code.txt:./CMakeLists.txt:		find_package(SDL2_ttf)
./platform_references_code.txt:./CMakeLists.txt:		find_library(SDL2Fwk SDL2 REQUIRED PATHS SDL/macOS)
./platform_references_code.txt:./CMakeLists.txt:		message(STATUS "found SDL2Fwk=${SDL2Fwk}")
./platform_references_code.txt:./CMakeLists.txt:		add_compile_options("$<$<COMPILE_LANGUAGE:CXX>:-Wno-class-memaccess>")
./platform_references_code.txt:./CMakeLists.txt:		if(MACOSX OR IOS)
./platform_references_code.txt:./CMakeLists.txt:			# Hack around a bad check for __GNUC__ in basis_universal that makes it use old stuff on iOS
./platform_references_code.txt:./CMakeLists.txt:		if(NOT MACOSX)
./platform_references_code.txt:./CMakeLists.txt:	if(IOS)
./platform_references_code.txt:./CMakeLists.txt:		if(LIBRETRO AND ARM64)
./platform_references_code.txt:./CMakeLists.txt:		if(CMAKE_SYSTEM_NAME MATCHES "Linux|SunOS" OR MINGW)
./platform_references_code.txt:./CMakeLists.txt:macro(setup_target_project TargetName ProjectDir)
./platform_references_code.txt:./CMakeLists.txt:endmacro()
./platform_references_code.txt:./CMakeLists.txt:	Common/Render/Text/draw_text_sdl.cpp
./platform_references_code.txt:./CMakeLists.txt:	Common/Render/Text/draw_text_sdl.h
./platform_references_code.txt:./CMakeLists.txt:	Common/Render/Text/draw_text_uwp.cpp
./platform_references_code.txt:./CMakeLists.txt:	Common/Render/Text/draw_text_uwp.h
./platform_references_code.txt:./CMakeLists.txt:if(IOS)
./platform_references_code.txt:./CMakeLists.txt:if(NOT LIBRETRO)
./platform_references_code.txt:./CMakeLists.txt:			elseif(IOS)
./platform_references_code.txt:./CMakeLists.txt:				if(IOS_PLATFORM STREQUAL "TVOS")
./platform_references_code.txt:./CMakeLists.txt:					set(PLATFORM_ARCH "ios/universal")
./platform_references_code.txt:./CMakeLists.txt:			elseif(MACOSX)
./platform_references_code.txt:./CMakeLists.txt:				set(PLATFORM_ARCH "macosx/universal")
./platform_references_code.txt:./CMakeLists.txt:			elseif(LINUX)
./platform_references_code.txt:./CMakeLists.txt:					set(PLATFORM_ARCH "linux/armv7")
./platform_references_code.txt:./CMakeLists.txt:					set(PLATFORM_ARCH "linux/aarch64")
./platform_references_code.txt:./CMakeLists.txt:					set(PLATFORM_ARCH "linux/arm")
./platform_references_code.txt:./CMakeLists.txt:					set(PLATFORM_ARCH "linux/mips32")
./platform_references_code.txt:./CMakeLists.txt:					set(PLATFORM_ARCH "linux/riscv64")
./platform_references_code.txt:./CMakeLists.txt:					set(PLATFORM_ARCH "linux/loongarch64")
./platform_references_code.txt:./CMakeLists.txt:					set(PLATFORM_ARCH "linux/x86_64")
./platform_references_code.txt:./CMakeLists.txt:					set(PLATFORM_ARCH "linux/x86")
./platform_references_code.txt:./CMakeLists.txt:					set(PLATFORM_ARCH "Windows/x86_64")
./platform_references_code.txt:./CMakeLists.txt:					set(PLATFORM_ARCH "Windows/x86")
./platform_references_code.txt:./CMakeLists.txt:		if(CMAKE_SYSTEM_NAME MATCHES WindowsPhone OR CMAKE_SYSTEM_NAME MATCHES WindowsStore)
./platform_references_code.txt:./CMakeLists.txt:			target_sources(libzip PRIVATE ext/libzip/zip_random_uwp.c)
./platform_references_code.txt:./CMakeLists.txt:if(ANDROID OR ARMV7 OR ARM64 OR ARM OR IOS)
./platform_references_code.txt:./CMakeLists.txt:if(IOS OR MACOSX)
./platform_references_code.txt:./CMakeLists.txt:elseif(IOS AND NOT LIBRETRO)
./platform_references_code.txt:./CMakeLists.txt:		ios/main.mm
./platform_references_code.txt:./CMakeLists.txt:		ios/AppDelegate.mm
./platform_references_code.txt:./CMakeLists.txt:		ios/AppDelegate.h
./platform_references_code.txt:./CMakeLists.txt:		ios/SceneDelegate.mm
./platform_references_code.txt:./CMakeLists.txt:		ios/SceneDelegate.h
./platform_references_code.txt:./CMakeLists.txt:		ios/DisplayManager.h
./platform_references_code.txt:./CMakeLists.txt:		ios/DisplayManager.mm
./platform_references_code.txt:./CMakeLists.txt:		ios/Controls.h
./platform_references_code.txt:./CMakeLists.txt:		ios/Controls.mm
./platform_references_code.txt:./CMakeLists.txt:		ios/ViewControllerCommon.h
./platform_references_code.txt:./CMakeLists.txt:		ios/ViewControllerCommon.mm
./platform_references_code.txt:./CMakeLists.txt:		ios/ViewController.mm
./platform_references_code.txt:./CMakeLists.txt:		ios/ViewController.h
./platform_references_code.txt:./CMakeLists.txt:		ios/ViewControllerMetal.mm
./platform_references_code.txt:./CMakeLists.txt:		ios/ViewControllerMetal.h
./platform_references_code.txt:./CMakeLists.txt:		ios/iOSCoreAudio.mm
./platform_references_code.txt:./CMakeLists.txt:		ios/iOSCoreAudio.h
./platform_references_code.txt:./CMakeLists.txt:		ios/IAPManager.mm
./platform_references_code.txt:./CMakeLists.txt:		ios/IAPManager.h
./platform_references_code.txt:./CMakeLists.txt:		ios/CameraHelper.mm
./platform_references_code.txt:./CMakeLists.txt:		ios/CameraHelper.h
./platform_references_code.txt:./CMakeLists.txt:		ios/LocationHelper.mm
./platform_references_code.txt:./CMakeLists.txt:		ios/LocationHelper.h
./platform_references_code.txt:./CMakeLists.txt:		ios/PPSSPPUIApplication.h
./platform_references_code.txt:./CMakeLists.txt:		ios/PPSSPPUIApplication.mm
./platform_references_code.txt:./CMakeLists.txt:		ios/SmartKeyboardMap.cpp
./platform_references_code.txt:./CMakeLists.txt:		ios/SmartKeyboardMap.hpp
./platform_references_code.txt:./CMakeLists.txt:		ios/iCade/iCadeReaderView.h
./platform_references_code.txt:./CMakeLists.txt:		ios/iCade/iCadeReaderView.m
./platform_references_code.txt:./CMakeLists.txt:		ios/iCade/iCadeState.h
./platform_references_code.txt:./CMakeLists.txt:	set(nativeExtraLibs ${nativeExtraLibs} "-framework Foundation -framework MediaPlayer -framework AudioToolbox -framework CoreGraphics -framework CoreMotion -framework QuartzCore -framework UIKit -framework GLKit -framework OpenAL -framework AVFoundation -framework CoreLocation -framework CoreText -framework CoreVideo -framework CoreMedia -framework CoreServices -framework Metal -framework IOSurface" )
./platform_references_code.txt:./CMakeLists.txt:	if(EXISTS "${CMAKE_IOS_SDK_ROOT}/System/Library/Frameworks/GameController.framework")
./platform_references_code.txt:./CMakeLists.txt:	set_source_files_properties(ios/AppDelegate.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:	set_source_files_properties(ios/ViewController.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:	set_source_files_properties(ios/ViewControllerMetal.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:	set_source_files_properties(ios/iOSCoreAudio.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:	set_source_files_properties(ios/PPSSPPUIApplication.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:	set_source_files_properties(ios/iCade/iCadeReaderView.m PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:	set_source_files_properties(ios/main.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:	set_source_files_properties(ios/CameraHelper.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:	set_source_files_properties(ios/AudioEngine.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:	set_source_files_properties(ios/LocationHelper.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:	set_source_files_properties(ios/DisplayManager.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:	set_source_files_properties(ios/Controls.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:elseif(IOS AND LIBRETRO)
./platform_references_code.txt:./CMakeLists.txt:elseif(USING_QT_UI)
./platform_references_code.txt:./CMakeLists.txt:	find_package(Qt5 COMPONENTS OpenGL Gui Core Multimedia)
./platform_references_code.txt:./CMakeLists.txt:		Qt/QtMain.cpp
./platform_references_code.txt:./CMakeLists.txt:		Qt/QtMain.h
./platform_references_code.txt:./CMakeLists.txt:		Qt/mainwindow.cpp
./platform_references_code.txt:./CMakeLists.txt:		Qt/mainwindow.h
./platform_references_code.txt:./CMakeLists.txt:	add_compile_definitions(USING_QT_UI)
./platform_references_code.txt:./CMakeLists.txt:		add_compile_definitions(QT_OPENGL_ES QT_OPENGL_ES_2)
./platform_references_code.txt:./CMakeLists.txt:	include_directories(Qt)
./platform_references_code.txt:./CMakeLists.txt:	set(nativeExtraLibs ${nativeExtraLibs} Qt5::OpenGL Qt5::Gui Qt5::Core Qt5::Multimedia)
./platform_references_code.txt:./CMakeLists.txt:	set(TargetBin PPSSPPQt)
./platform_references_code.txt:./CMakeLists.txt:	# Enable SDL joystick if SDL is found
./platform_references_code.txt:./CMakeLists.txt:	if(SDL2_FOUND)
./platform_references_code.txt:./CMakeLists.txt:		add_compile_definitions(SDL)
./platform_references_code.txt:./CMakeLists.txt:			SDL/SDLJoystick.h
./platform_references_code.txt:./CMakeLists.txt:			SDL/SDLJoystick.cpp
./platform_references_code.txt:./CMakeLists.txt:		set(nativeExtraLibs ${nativeExtraLibs} SDL2::SDL2)
./platform_references_code.txt:./CMakeLists.txt:	# Don't care about SDL.
./platform_references_code.txt:./CMakeLists.txt:	set(TargetBin PPSSPPWindows)
./platform_references_code.txt:./CMakeLists.txt:elseif(LIBRETRO)
./platform_references_code.txt:./CMakeLists.txt:		set(TargetBin PPSSPPSDL)
./platform_references_code.txt:./CMakeLists.txt:	# Require SDL
./platform_references_code.txt:./CMakeLists.txt:	add_compile_definitions(SDL)
./platform_references_code.txt:./CMakeLists.txt:		SDL/SDLJoystick.h
./platform_references_code.txt:./CMakeLists.txt:		SDL/SDLJoystick.cpp
./platform_references_code.txt:./CMakeLists.txt:		SDL/SDLMain.cpp
./platform_references_code.txt:./CMakeLists.txt:		SDL/SDLGLGraphicsContext.cpp
./platform_references_code.txt:./CMakeLists.txt:			SDL/SDLVulkanGraphicsContext.cpp
./platform_references_code.txt:./CMakeLists.txt:	if(SDL2_ttf_FOUND OR
./platform_references_code.txt:./CMakeLists.txt:		(SDL2_ttf_PKGCONFIG_FOUND AND
./platform_references_code.txt:./CMakeLists.txt:			SDL2_ttf_PKGCONFIG_VERSION VERSION_GREATER_EQUAL "2.0.18"))
./platform_references_code.txt:./CMakeLists.txt:		add_compile_definitions(USE_SDL2_TTF)
./platform_references_code.txt:./CMakeLists.txt:			add_compile_definitions(USE_SDL2_TTF_FONTCONFIG)
./platform_references_code.txt:./CMakeLists.txt:	elseif(SDL2_ttf_PKGCONFIG_FOUND)
./platform_references_code.txt:./CMakeLists.txt:		message(WARNING "Found SDL2_ttf <2.0.18 - this is too old, falling back to atlas")
./platform_references_code.txt:./CMakeLists.txt:	if(SDL2_ttf_FOUND)
./platform_references_code.txt:./CMakeLists.txt:		set(nativeExtraLibs ${nativeExtraLibs} SDL2_ttf::SDL2_ttf)
./platform_references_code.txt:./CMakeLists.txt:	elseif(SDL2_ttf_PKGCONFIG_FOUND)
./platform_references_code.txt:./CMakeLists.txt:		set(nativeExtraLibs ${nativeExtraLibs} PkgConfig::SDL2_ttf_PKGCONFIG)
./platform_references_code.txt:./CMakeLists.txt:		SDL/SDLMain.h
./platform_references_code.txt:./CMakeLists.txt:		SDL/SDLMain.mm
./platform_references_code.txt:./CMakeLists.txt:		SDL/SDLCocoaMetalLayer.h
./platform_references_code.txt:./CMakeLists.txt:		SDL/SDLCocoaMetalLayer.mm
./platform_references_code.txt:./CMakeLists.txt:		SDL/CocoaBarItems.mm
./platform_references_code.txt:./CMakeLists.txt:		SDL/CocoaBarItems.h
./platform_references_code.txt:./CMakeLists.txt:		SDL/PPSSPPAboutViewController.m
./platform_references_code.txt:./CMakeLists.txt:		SDL/PPSSPPAboutViewController.h
./platform_references_code.txt:./CMakeLists.txt:		SDL/MacCameraHelper.mm
./platform_references_code.txt:./CMakeLists.txt:		# set_source_files_properties(SDL/SDLMain.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:		set_source_files_properties(SDL/CocoaMetalLayer.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:		set_source_files_properties(SDL/CocoaBarItems.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:		set_source_files_properties(SDL/PPSSPPAboutViewController.m PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:		set_source_files_properties(SDL/MacCameraHelper.mm PROPERTIES COMPILE_FLAGS -fobjc-arc)
./platform_references_code.txt:./CMakeLists.txt:		if(USE_SYSTEM_LIBSDL2)
./platform_references_code.txt:./CMakeLists.txt:			set(nativeExtraLibs ${nativeExtraLibs} SDL2::SDL2)
./platform_references_code.txt:./CMakeLists.txt:			set(nativeExtraLibs ${nativeExtraLibs} ${SDL2Fwk})
./platform_references_code.txt:./CMakeLists.txt:		set(nativeExtraLibs ${nativeExtraLibs} pthread SDL2::SDL2)
./platform_references_code.txt:./CMakeLists.txt:		set(nativeExtraLibs ${nativeExtraLibs} SDL2::SDL2)
./platform_references_code.txt:./CMakeLists.txt:if(NOT LIBRETRO)
./platform_references_code.txt:./CMakeLists.txt:	if (NOT LIBRETRO)
./platform_references_code.txt:./CMakeLists.txt:if (IOS)
./platform_references_code.txt:./CMakeLists.txt:	Common/Render/Text/draw_text_qt.cpp
./platform_references_code.txt:./CMakeLists.txt:	Common/Render/Text/draw_text_qt.h
./platform_references_code.txt:./CMakeLists.txt:if(LINUX AND NOT ANDROID)
./platform_references_code.txt:./CMakeLists.txt:if(ANDROID OR (LINUX AND ARM_DEVICE) OR (LINUX AND RISCV64) OR (LINUX AND LOONGARCH64))
./platform_references_code.txt:./CMakeLists.txt:	Core/HLE/sceDmac.cpp
./platform_references_code.txt:./CMakeLists.txt:	Core/HLE/sceDmac.h
./platform_references_code.txt:./CMakeLists.txt:if(USE_DISCORD AND NOT IOS AND NOT LIBRETRO)
./platform_references_code.txt:./CMakeLists.txt:		if (MACOSX)
./platform_references_code.txt:./CMakeLists.txt:	set(WIN_VERSION_CMD COMMAND ${CMAKE_SOURCE_DIR}/Windows/git-version-gen.cmd PPSSPPWindows)
./platform_references_code.txt:./CMakeLists.txt:set(WindowsFiles
./platform_references_code.txt:./CMakeLists.txt:	Windows/WindowsAudio.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/WindowsAudio.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/WASAPIContext.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/WASAPIContext.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/BreakpointWindow.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/BreakpointWindow.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/DumpMemoryWindow.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/DumpMemoryWindow.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/CtrlDisAsmView.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/CtrlDisAsmView.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/CtrlMemView.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/CtrlMemView.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/CtrlRegisterList.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/CtrlRegisterList.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/DebuggerShared.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/DebuggerShared.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/Debugger_Disasm.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/Debugger_Disasm.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/Debugger_MemoryDlg.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/Debugger_MemoryDlg.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/Debugger_Lists.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/Debugger_Lists.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/Debugger_VFPUDlg.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/Debugger_VFPUDlg.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/WatchItemWindow.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/WatchItemWindow.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/EditSymbolsWindow.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/Debugger/EditSymbolsWindow.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/GEDebugger/CtrlDisplayListView.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/GEDebugger/SimpleGLWindow.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/GEDebugger/TabState.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/GEDebugger/VertexPreview.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/GEDebugger/CtrlDisplayListView.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/GEDebugger/SimpleGLWindow.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/GEDebugger/TabState.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/GEDebugger/GEDebugger.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/GEDebugger/TabDisplayLists.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/GEDebugger/TabVertices.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/GEDebugger/GEDebugger.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/GEDebugger/TabDisplayLists.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/GEDebugger/TabVertices.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/BufferLock.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/CaptureDevice.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/CaptureDevice.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/DinputDevice.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/DinputDevice.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/HidInputDevice.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/HidInputDevice.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/EmuThread.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/EmuThread.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/GPU/D3D11Context.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/GPU/D3D11Context.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/GPU/WindowsGLContext.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/GPU/WindowsVulkanContext.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/InputBox.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/InputBox.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/InputDevice.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/InputDevice.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/ContextMenu.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/ContextMenu.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/DialogManager.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/DialogManager.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/Misc.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/Misc.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/ShellUtil.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/ShellUtil.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/TabControl.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/TabControl.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/IatHook.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/ContextMenu.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/ContextMenu.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/DarkMode.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/DarkMode.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/UAHMenuBar.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/W32Util/UAHMenuBar.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/MainWindow.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/MainWindow.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/MainWindowMenu.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/MainWindowMenu.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/RawInput.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/RawInput.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/TouchInputHandler.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/TouchInputHandler.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/XinputDevice.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/XinputDevice.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/main.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/main.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/ppsspp.rc
./platform_references_code.txt:./CMakeLists.txt:	Windows/resource.h
./platform_references_code.txt:./CMakeLists.txt:	Windows/stdafx.cpp
./platform_references_code.txt:./CMakeLists.txt:	Windows/stdafx.h
./platform_references_code.txt:./CMakeLists.txt:	#setup_target_project(${TargetBin} Windows)
./platform_references_code.txt:./CMakeLists.txt:	list(APPEND NativeAppSource ${WindowsFiles})
./platform_references_code.txt:./CMakeLists.txt:		headless/SDLHeadlessHost.cpp
./platform_references_code.txt:./CMakeLists.txt:		headless/SDLHeadlessHost.h
./platform_references_code.txt:./CMakeLists.txt:			headless/WindowsHeadlessHost.cpp
./platform_references_code.txt:./CMakeLists.txt:			headless/WindowsHeadlessHost.h
./platform_references_code.txt:./CMakeLists.txt:			Windows/GPU/D3D11Context.cpp
./platform_references_code.txt:./CMakeLists.txt:			Windows/GPU/D3D11Context.h
./platform_references_code.txt:./CMakeLists.txt:			Windows/GPU/WindowsGLContext.cpp
./platform_references_code.txt:./CMakeLists.txt:			Windows/GPU/WindowsVulkanContext.cpp
./platform_references_code.txt:./CMakeLists.txt:			Windows/W32Util/ShellUtil.cpp
./platform_references_code.txt:./CMakeLists.txt:			Windows/W32Util/ShellUtil.h
./platform_references_code.txt:./CMakeLists.txt:			Windows/CaptureDevice.cpp
./platform_references_code.txt:./CMakeLists.txt:			Windows/CaptureDevice.h
./platform_references_code.txt:./CMakeLists.txt:			Windows/W32Util/Misc.cpp
./platform_references_code.txt:./CMakeLists.txt:			Windows/W32Util/Misc.h
./platform_references_code.txt:./CMakeLists.txt:			Windows/CaptureDevice.cpp
./platform_references_code.txt:./CMakeLists.txt:			Windows/CaptureDevice.h
./platform_references_code.txt:./CMakeLists.txt:if(LIBRETRO)
./platform_references_code.txt:./CMakeLists.txt:	add_subdirectory(libretro)
./platform_references_code.txt:./CMakeLists.txt:		if(NOT IOS)
./platform_references_code.txt:./CMakeLists.txt:				set(MACOSX_BUNDLE_ICON_FILE ppsspp_gold.icns)
./platform_references_code.txt:./CMakeLists.txt:				set(MACOSX_BUNDLE_BUNDLE_NAME "PPSSPP Gold")
./platform_references_code.txt:./CMakeLists.txt:				set(MACOSX_BUNDLE_GUI_IDENTIFIER org.ppsspp.ppssppgold)
./platform_references_code.txt:./CMakeLists.txt:				set(MACOSX_BUNDLE_ICON_FILE ppsspp.icns)
./platform_references_code.txt:./CMakeLists.txt:				set(MACOSX_BUNDLE_BUNDLE_NAME "PPSSPP")
./platform_references_code.txt:./CMakeLists.txt:				set(MACOSX_BUNDLE_GUI_IDENTIFIER org.ppsspp.ppsspp)
./platform_references_code.txt:./CMakeLists.txt:			set_source_files_properties(${ICON_PATH_ABS} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources")
./platform_references_code.txt:./CMakeLists.txt:		if(NOT IOS)
./platform_references_code.txt:./CMakeLists.txt:			set_source_files_properties(${BigFontAssets} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets")
./platform_references_code.txt:./CMakeLists.txt:			set_source_files_properties(${NativeAssets} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets")
./platform_references_code.txt:./CMakeLists.txt:			set_source_files_properties(${UIImages} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/ui_images")
./platform_references_code.txt:./CMakeLists.txt:			set_source_files_properties(${FLASH0_FILES} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/flash0/font")
./platform_references_code.txt:./CMakeLists.txt:			set_source_files_properties(${LANG_FILES} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/lang")
./platform_references_code.txt:./CMakeLists.txt:			set_source_files_properties(${SHADER_FILES} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/shaders")
./platform_references_code.txt:./CMakeLists.txt:			set_source_files_properties(${THEME_FILE} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/themes")
./platform_references_code.txt:./CMakeLists.txt:			set_source_files_properties(${DEBUGGER_FILES} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/debugger")
./platform_references_code.txt:./CMakeLists.txt:			set_source_files_properties(${WEB_UPLOAD_FILES} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/upload")
./platform_references_code.txt:./CMakeLists.txt:			set_source_files_properties(${VFPU_FILES} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources/assets/vfpu")
./platform_references_code.txt:./CMakeLists.txt:		if(IOS)
./platform_references_code.txt:./CMakeLists.txt:			set(AssetCatalog "${CMAKE_SOURCE_DIR}/ios/assets.xcassets")
./platform_references_code.txt:./CMakeLists.txt:			add_executable(${TargetBin} MACOSX_BUNDLE ${NativeAssets} ${BigFontAssets} ${UIImages} ${AssetCatalog} ${SHADER_FILES} ${THEME_FILE} ${DEBUGGER_FILES} ${WEB_UPLOAD_FILES} ${FLASH0_FILES} ${LANG_FILES} ${NativeAppSource} "ios/Settings.bundle" "ios/Launch Screen.storyboard")
./platform_references_code.txt:./CMakeLists.txt:			if(NOT IOS_APP_STORE)
./platform_references_code.txt:./CMakeLists.txt:				file(INSTALL "${CMAKE_SOURCE_DIR}/ext/vulkan/iOS/Frameworks/libMoltenVK.dylib" DESTINATION "${CMAKE_BINARY_DIR}/PPSSPP.app/Frameworks/")
./platform_references_code.txt:./CMakeLists.txt:			add_executable(${TargetBin} MACOSX_BUNDLE ${ICON_PATH_ABS} ${NativeAssets} ${BigFontAssets} ${UIImages} ${SHADER_FILES} ${THEME_FILE} ${DEBUGGER_FILES} ${WEB_UPLOAD_FILES} ${FLASH0_FILES} ${LANG_FILES} ${NativeAppSource})
./platform_references_code.txt:./CMakeLists.txt:			file(INSTALL "${CMAKE_SOURCE_DIR}/ext/vulkan/macOS/Frameworks/libMoltenVK.dylib" DESTINATION "${CMAKE_BINARY_DIR}/${TargetBin}.app/Contents/Frameworks/")
./platform_references_code.txt:./CMakeLists.txt:			if(USING_QT_UI)
./platform_references_code.txt:./CMakeLists.txt:				add_custom_command(TARGET ${TargetBin} POST_BUILD COMMAND /bin/bash "${CMAKE_SOURCE_DIR}/Qt/macbundle.sh" "${CMAKE_BINARY_DIR}/PPSSPPQt.app")
./platform_references_code.txt:./CMakeLists.txt:			elseif(NOT USE_SYSTEM_LIBSDL2)
./platform_references_code.txt:./CMakeLists.txt:				add_custom_command(TARGET ${TargetBin} POST_BUILD COMMAND /bin/bash "${CMAKE_SOURCE_DIR}/SDL/macbundle.sh" "${CMAKE_BINARY_DIR}/${TargetBin}.app" "${TargetBin}")
./platform_references_code.txt:./CMakeLists.txt:if(IOS AND NOT LIBRETRO)
./platform_references_code.txt:./CMakeLists.txt:	if(IOS_APP_STORE)
./platform_references_code.txt:./CMakeLists.txt:	file(GLOB IOSAssets ios/assets/*.png)
./platform_references_code.txt:./CMakeLists.txt:	list(REMOVE_ITEM IOSAssets ${CMAKE_CURRENT_SOURCE_DIR}/ios/assets/Default-568h@2x.png)
./platform_references_code.txt:./CMakeLists.txt:	list(REMOVE_ITEM IOSAssets ${CMAKE_CURRENT_SOURCE_DIR}/ios/assets/Default-568h@3x.png)
./platform_references_code.txt:./CMakeLists.txt:	file(INSTALL ${IOSAssets} DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/assets)
./platform_references_code.txt:./CMakeLists.txt:	file(GLOB IOSAssets ios/assets/Default-568h@*.png)
./platform_references_code.txt:./CMakeLists.txt:	file(INSTALL ${IOSAssets} DESTINATION ${CMAKE_CURRENT_BINARY_DIR})
./platform_references_code.txt:./CMakeLists.txt:	if(IOS_DEBUG)
./platform_references_code.txt:./CMakeLists.txt:	set(RSRC_XIB_FILES "Launch Screen.storyboard" ${CMAKE_CURRENT_SOURCE_DIR}/ios/assets.xcassets)
./platform_references_code.txt:./CMakeLists.txt:		PROPERTIES MACOSX_PACKAGE_LOCATION Resources
./platform_references_code.txt:./CMakeLists.txt:	set(MACOSX_DEPLOYMENT_TARGET ${DEPLOYMENT_TARGET})
./platform_references_code.txt:./CMakeLists.txt:	set(BUNDLE_PLIST "${CMAKE_CURRENT_SOURCE_DIR}/ios/PPSSPP-Info.plist")
./platform_references_code.txt:./CMakeLists.txt:	set(BUNDLE_ENTITLEMENTS "${CMAKE_CURRENT_SOURCE_DIR}/ios/App.entitlements")
./platform_references_code.txt:./CMakeLists.txt:		if(IOS_APP_STORE)
./platform_references_code.txt:./CMakeLists.txt:		if(IOS_APP_STORE)
./platform_references_code.txt:./CMakeLists.txt:	if(IOS_APP_STORE)
./platform_references_code.txt:./CMakeLists.txt:			COMMAND /bin/bash "${CMAKE_SOURCE_DIR}/ios/iosbundle.sh" \"${APP_DIR_NAME}\" "${CMAKE_CURRENT_BINARY_DIR}"
./platform_references_code.txt:./CMakeLists.txt:			"${CMAKE_CURRENT_SOURCE_DIR}/ios/MoltenVK/MoltenVK.xcframework/ios-arm64/libMoltenVK.a"
./platform_references_code.txt:./CMakeLists.txt:		# https://stackoverflow.com/questions/40664125/cmake-and-code-signing-in-xcode-8-for-ios-projects
./platform_references_code.txt:./CMakeLists.txt:			RESOURCE "ios/Launch Screen.storyboard"
./platform_references_code.txt:./CMakeLists.txt:			RESOURCE "ios/Settings.bundle"
./platform_references_code.txt:./CMakeLists.txt:			RESOURCE "ios/assets.xcassets"
./platform_references_code.txt:./CMakeLists.txt:			MACOSX_BUNDLE_INFO_PLIST ${BUNDLE_PLIST}
./platform_references_code.txt:./CMakeLists.txt:			COMMAND /bin/bash "${CMAKE_SOURCE_DIR}/ios/macbundle.sh" \"${APP_DIR_NAME}\"
./platform_references_code.txt:./CMakeLists.txt:			MACOSX_BUNDLE_INFO_PLIST ${BUNDLE_PLIST}
./platform_references_code.txt:./CMakeLists.txt:			RESOURCE "ios/Launch Screen.storyboard"
./platform_references_code.txt:./CMakeLists.txt:			RESOURCE "ios/Settings.bundle"
./platform_references_code.txt:./CMakeLists.txt:			RESOURCE "ext/vulkan/iOS/Frameworks"
./platform_references_code.txt:./CMakeLists.txt:if(MACOSX AND NOT IOS)
./platform_references_code.txt:./CMakeLists.txt:			MACOSX_BUNDLE_INFO_PLIST "${CMAKE_CURRENT_SOURCE_DIR}/macOS/InfoGold.plist"
./platform_references_code.txt:./CMakeLists.txt:			MACOSX_BUNDLE_INFO_PLIST "${CMAKE_CURRENT_SOURCE_DIR}/macOS/Info.plist"
./platform_references_code.txt:./Common/ABI.cpp:// Mac OS X requires the stack to be 16-byte aligned before every call.
./platform_references_code.txt:./Common/ABI.cpp:// Linux requires the stack to be 16-byte aligned before calls that put SSE
./platform_references_code.txt:./Common/ABI.cpp:// Windows binaries compiled with MSVC do not have such a restriction*, but I
./platform_references_code.txt:./Common/ABI.cpp:// expect that GCC on Windows acts the same as GCC on Linux in this respect.
./platform_references_code.txt:./Common/ABI.cpp:// The Windows x64 ABI requires XMM6 - XMM15 to be callee saved.  10 regs.
./platform_references_code.txt:./Common/ABI.h:// Linux 32-bit, Windows 32-bit (cdecl, System V):
./platform_references_code.txt:./Common/ABI.h:// Windows 64-bit
./platform_references_code.txt:./Common/ABI.h:// Linux 64-bit
./platform_references_code.txt:./Common/ABI.h:// 32-bit bog standard cdecl, shared between linux and windows
./platform_references_code.txt:./Common/ABI.h:// MacOSX 32-bit is same as System V with a few exceptions that we probably don't care much about.
./platform_references_code.txt:./Common/ABI.h:#ifdef _WIN32 // 64-bit Windows - the really exotic calling convention 
./platform_references_code.txt:./Common/ABI.h:#else  //64-bit Unix (hopefully MacOSX too) 
./platform_references_code.txt:./Common/Arm64Emitter.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/Arm64Emitter.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Common/Arm64Emitter.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Common/Arm64Emitter.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:#if defined(CPU_FEATURES_OS_LINUX)
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:#if defined(CPU_FEATURES_OS_LINUX) || defined(CPU_FEATURES_OS_ANDROID) || defined(CPU_FEATURES_OS_WINDOWS)
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:#if PPSSPP_PLATFORM(WINDOWS) 
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:	LSTATUS result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0", 0, KEY_READ, &key);
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:// Only Linux platforms have /proc/cpuinfo
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:#if PPSSPP_PLATFORM(LINUX)
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:#if !PPSSPP_PLATFORM(LINUX)
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:#endif // PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:	if (sysctlbyname("machdep.cpu.brand_string", brand_string, &sz, nullptr, 0) != 0) {
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:#else // !PPSSPP_PLATFORM(IOS) && !PPSSPP_PLATFORM(MAC) && !PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/ArmCPUDetect.cpp:#else // PPSSPP_PLATFORM(LINUX)
./platform_references_code.txt:./Common/ArmEmitter.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/ArmEmitter.cpp:#include "CommonWindows.h"
./platform_references_code.txt:./Common/ArmEmitter.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/ArmEmitter.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/ArmEmitter.h:// Everything that needs to generate machine code should inherit from this.
./platform_references_code.txt:./Common/Battery/AppleBatteryClient.m:#if PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Common/Battery/AppleBatteryClient.m:#elif PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/Battery/AppleBatteryClient.m:#if TARGET_OS_IOS
./platform_references_code.txt:./Common/Battery/AppleBatteryClient.m:    // on iOS, this needs to be true to get the battery level
./platform_references_code.txt:./Common/Battery/AppleBatteryClient.m:#elif TARGET_OS_MAC
./platform_references_code.txt:./Common/Battery/AppleBatteryClient.m:#if TARGET_OS_IOS
./platform_references_code.txt:./Common/Battery/AppleBatteryClient.m:#elif TARGET_OS_MAC
./platform_references_code.txt:./Common/BitScan.h:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/BitScan.h:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/CPUDetect.cpp:#if defined(CPU_FEATURES_OS_FREEBSD) || defined(CPU_FEATURES_OS_LINUX) || defined(CPU_FEATURES_OS_ANDROID) || defined(CPU_FEATURES_OS_MACOS) || defined(CPU_FEATURES_OS_WINDOWS)
./platform_references_code.txt:./Common/CPUDetect.cpp:#elif PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Common/CPUDetect.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/CPUDetect.cpp:#if PPSSPP_PLATFORM(LINUX)
./platform_references_code.txt:./Common/CPUDetect.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/CPUDetect.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/CPUDetect.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/CPUDetect.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/CPUDetect.cpp:#elif PPSSPP_PLATFORM(LINUX)
./platform_references_code.txt:./Common/CPUDetect.cpp:#elif PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Common/Common.h:// DO NOT EVER INCLUDE <windows.h> directly _or indirectly_ from this file
./platform_references_code.txt:./Common/Common.h:// Windows compatibility
./platform_references_code.txt:./Common/Common.vcxproj:    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
./platform_references_code.txt:./Common/Common.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./Common/Common.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./Common/Common.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./Common/Common.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./Common/Common.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./Common/Common.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./Common/Common.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./platform_references_code.txt:./Common/Common.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./platform_references_code.txt:./Common/Common.vcxproj:  <PropertyGroup Label="UserMacros" />
./platform_references_code.txt:./Common/Common.vcxproj:      <SubSystem>Windows</SubSystem>
./platform_references_code.txt:./Common/Common.vcxproj:      <SubSystem>Windows</SubSystem>
./platform_references_code.txt:./Common/Common.vcxproj:      <SubSystem>Windows</SubSystem>
./platform_references_code.txt:./Common/Common.vcxproj:      <SubSystem>Windows</SubSystem>
./platform_references_code.txt:./Common/Common.vcxproj:      <SubSystem>Windows</SubSystem>
./platform_references_code.txt:./Common/Common.vcxproj:      <SubSystem>Windows</SubSystem>
./platform_references_code.txt:./Common/Common.vcxproj:    <ClInclude Include="Render\Text\draw_text_qt.h" />
./platform_references_code.txt:./Common/Common.vcxproj:    <ClInclude Include="Render\Text\draw_text_sdl.h" />
./platform_references_code.txt:./Common/Common.vcxproj:    <ClInclude Include="Render\Text\draw_text_uwp.h" />
./platform_references_code.txt:./Common/Common.vcxproj:    <ClInclude Include="CommonWindows.h" />
./platform_references_code.txt:./Common/Common.vcxproj:    <ClInclude Include="MachineContext.h" />
./platform_references_code.txt:./Common/Common.vcxproj:    <ClCompile Include="Render\Text\draw_text_qt.cpp" />
./platform_references_code.txt:./Common/Common.vcxproj:    <ClCompile Include="Render\Text\draw_text_sdl.cpp" />
./platform_references_code.txt:./Common/Common.vcxproj:    <ClCompile Include="Render\Text\draw_text_uwp.cpp" />
./platform_references_code.txt:./Common/Common.vcxproj.filters:    <ClInclude Include="CommonWindows.h" />
./platform_references_code.txt:./Common/Common.vcxproj.filters:    <ClInclude Include="MachineContext.h" />
./platform_references_code.txt:./Common/Common.vcxproj.filters:    <ClInclude Include="Render\Text\draw_text_qt.h">
./platform_references_code.txt:./Common/Common.vcxproj.filters:    <ClInclude Include="Render\Text\draw_text_uwp.h">
./platform_references_code.txt:./Common/Common.vcxproj.filters:    <ClInclude Include="Render\Text\draw_text_sdl.h">
./platform_references_code.txt:./Common/Common.vcxproj.filters:    <ClCompile Include="Render\Text\draw_text_qt.cpp">
./platform_references_code.txt:./Common/Common.vcxproj.filters:    <ClCompile Include="Render\Text\draw_text_uwp.cpp">
./platform_references_code.txt:./Common/Common.vcxproj.filters:    <ClCompile Include="Render\Text\draw_text_sdl.cpp">
./platform_references_code.txt:./Common/CommonFuncs.h:// 64 bit offsets for windows
./platform_references_code.txt:./Common/CommonWindows.h:#include <Windows.h>
./platform_references_code.txt:./Common/Crypto/md5.cpp: * 32-bit integer manipulation macros (little endian)
./platform_references_code.txt:./Common/Crypto/md5.cpp: * MD5 HMAC context setup
./platform_references_code.txt:./Common/Crypto/md5.cpp:void ppsspp_md5_hmac_starts( md5_context *ctx, unsigned char *key, int keylen )
./platform_references_code.txt:./Common/Crypto/md5.cpp: * MD5 HMAC process buffer
./platform_references_code.txt:./Common/Crypto/md5.cpp:void ppsspp_md5_hmac_update( md5_context *ctx, unsigned char *input, int ilen )
./platform_references_code.txt:./Common/Crypto/md5.cpp: * MD5 HMAC final digest
./platform_references_code.txt:./Common/Crypto/md5.cpp:void ppsspp_md5_hmac_finish( md5_context *ctx, unsigned char output[16] )
./platform_references_code.txt:./Common/Crypto/md5.cpp: * output = HMAC-MD5( hmac key, input buffer )
./platform_references_code.txt:./Common/Crypto/md5.cpp:void ppsspp_md5_hmac( unsigned char *key, int keylen, unsigned char *input, int ilen,
./platform_references_code.txt:./Common/Crypto/md5.cpp:    ppsspp_md5_hmac_starts( &ctx, key, keylen );
./platform_references_code.txt:./Common/Crypto/md5.cpp:    ppsspp_md5_hmac_update( &ctx, input, ilen );
./platform_references_code.txt:./Common/Crypto/md5.cpp:    ppsspp_md5_hmac_finish( &ctx, output );
./platform_references_code.txt:./Common/Crypto/md5.cpp:static unsigned char md5_hmac_test_key[7][26] =
./platform_references_code.txt:./Common/Crypto/md5.cpp:static const int md5_hmac_test_keylen[7] =
./platform_references_code.txt:./Common/Crypto/md5.cpp:static unsigned char md5_hmac_test_buf[7][74] =
./platform_references_code.txt:./Common/Crypto/md5.cpp:static const int md5_hmac_test_buflen[7] =
./platform_references_code.txt:./Common/Crypto/md5.cpp:static const unsigned char md5_hmac_test_sum[7][16] =
./platform_references_code.txt:./Common/Crypto/md5.cpp:            printf( "  HMAC-MD5 test #%d: ", i + 1 );
./platform_references_code.txt:./Common/Crypto/md5.cpp:            md5_hmac_starts( &ctx, buf, buflen );
./platform_references_code.txt:./Common/Crypto/md5.cpp:            md5_hmac_starts( &ctx, md5_hmac_test_key[i],
./platform_references_code.txt:./Common/Crypto/md5.cpp:                                   md5_hmac_test_keylen[i] );
./platform_references_code.txt:./Common/Crypto/md5.cpp:        md5_hmac_update( &ctx, md5_hmac_test_buf[i],
./platform_references_code.txt:./Common/Crypto/md5.cpp:                               md5_hmac_test_buflen[i] );
./platform_references_code.txt:./Common/Crypto/md5.cpp:        md5_hmac_finish( &ctx, md5sum );
./platform_references_code.txt:./Common/Crypto/md5.cpp:        if( memcmp( md5sum, md5_hmac_test_sum[i], buflen ) != 0 )
./platform_references_code.txt:./Common/Crypto/md5.h:    unsigned char ipad[64];     /*!< HMAC: inner padding        */
./platform_references_code.txt:./Common/Crypto/md5.h:    unsigned char opad[64];     /*!< HMAC: outer padding        */
./platform_references_code.txt:./Common/Crypto/md5.h: * \brief          MD5 HMAC context setup
./platform_references_code.txt:./Common/Crypto/md5.h: * \param ctx      HMAC context to be initialized
./platform_references_code.txt:./Common/Crypto/md5.h: * \param key      HMAC secret key
./platform_references_code.txt:./Common/Crypto/md5.h: * \param keylen   length of the HMAC key
./platform_references_code.txt:./Common/Crypto/md5.h:void ppsspp_md5_hmac_starts( md5_context *ctx, unsigned char *key, int keylen );
./platform_references_code.txt:./Common/Crypto/md5.h: * \brief          MD5 HMAC process buffer
./platform_references_code.txt:./Common/Crypto/md5.h: * \param ctx      HMAC context
./platform_references_code.txt:./Common/Crypto/md5.h:void ppsspp_md5_hmac_update( md5_context *ctx, unsigned char *input, int ilen );
./platform_references_code.txt:./Common/Crypto/md5.h: * \brief          MD5 HMAC final digest
./platform_references_code.txt:./Common/Crypto/md5.h: * \param ctx      HMAC context
./platform_references_code.txt:./Common/Crypto/md5.h: * \param output   MD5 HMAC checksum result
./platform_references_code.txt:./Common/Crypto/md5.h:void ppsspp_md5_hmac_finish( md5_context *ctx, unsigned char output[16] );
./platform_references_code.txt:./Common/Crypto/md5.h: * \brief          Output = HMAC-MD5( hmac key, input buffer )
./platform_references_code.txt:./Common/Crypto/md5.h: * \param key      HMAC secret key
./platform_references_code.txt:./Common/Crypto/md5.h: * \param keylen   length of the HMAC key
./platform_references_code.txt:./Common/Crypto/md5.h: * \param output   HMAC-MD5 result
./platform_references_code.txt:./Common/Crypto/md5.h:void ppsspp_md5_hmac( unsigned char *key, int keylen,
./platform_references_code.txt:./Common/Crypto/sha1.cpp: * 32-bit integer manipulation macros (big endian)
./platform_references_code.txt:./Common/Crypto/sha1.cpp: * SHA-1 HMAC context setup
./platform_references_code.txt:./Common/Crypto/sha1.cpp:void sha1_hmac_starts( sha1_context *ctx, unsigned char *key, int keylen )
./platform_references_code.txt:./Common/Crypto/sha1.cpp: * SHA-1 HMAC process buffer
./platform_references_code.txt:./Common/Crypto/sha1.cpp:void sha1_hmac_update( sha1_context *ctx, unsigned char *input, int ilen )
./platform_references_code.txt:./Common/Crypto/sha1.cpp: * SHA-1 HMAC final digest
./platform_references_code.txt:./Common/Crypto/sha1.cpp:void sha1_hmac_finish( sha1_context *ctx, unsigned char output[20] )
./platform_references_code.txt:./Common/Crypto/sha1.cpp: * output = HMAC-SHA-1( hmac key, input buffer )
./platform_references_code.txt:./Common/Crypto/sha1.cpp:void sha1_hmac( unsigned char *key, int keylen,
./platform_references_code.txt:./Common/Crypto/sha1.cpp:    sha1_hmac_starts( &ctx, key, keylen );
./platform_references_code.txt:./Common/Crypto/sha1.cpp:    sha1_hmac_update( &ctx, input, ilen );
./platform_references_code.txt:./Common/Crypto/sha1.cpp:    sha1_hmac_finish( &ctx, output );
./platform_references_code.txt:./Common/Crypto/sha1.cpp:static unsigned char sha1_hmac_test_key[7][26] =
./platform_references_code.txt:./Common/Crypto/sha1.cpp:static const int sha1_hmac_test_keylen[7] =
./platform_references_code.txt:./Common/Crypto/sha1.cpp:static unsigned char sha1_hmac_test_buf[7][74] =
./platform_references_code.txt:./Common/Crypto/sha1.cpp:static const int sha1_hmac_test_buflen[7] =
./platform_references_code.txt:./Common/Crypto/sha1.cpp:static const unsigned char sha1_hmac_test_sum[7][20] =
./platform_references_code.txt:./Common/Crypto/sha1.cpp:            printf( "  HMAC-SHA-1 test #%d: ", i + 1 );
./platform_references_code.txt:./Common/Crypto/sha1.cpp:            sha1_hmac_starts( &ctx, buf, buflen );
./platform_references_code.txt:./Common/Crypto/sha1.cpp:            sha1_hmac_starts( &ctx, sha1_hmac_test_key[i],
./platform_references_code.txt:./Common/Crypto/sha1.cpp:                                    sha1_hmac_test_keylen[i] );
./platform_references_code.txt:./Common/Crypto/sha1.cpp:        sha1_hmac_update( &ctx, sha1_hmac_test_buf[i],
./platform_references_code.txt:./Common/Crypto/sha1.cpp:                                sha1_hmac_test_buflen[i] );
./platform_references_code.txt:./Common/Crypto/sha1.cpp:        sha1_hmac_finish( &ctx, sha1sum );
./platform_references_code.txt:./Common/Crypto/sha1.cpp:        if( memcmp( sha1sum, sha1_hmac_test_sum[i], buflen ) != 0 )
./platform_references_code.txt:./Common/Crypto/sha1.h:    unsigned char ipad[64];     /*!< HMAC: inner padding        */
./platform_references_code.txt:./Common/Crypto/sha1.h:    unsigned char opad[64];     /*!< HMAC: outer padding        */
./platform_references_code.txt:./Common/Crypto/sha1.h: * \brief          SHA-1 HMAC context setup
./platform_references_code.txt:./Common/Crypto/sha1.h: * \param ctx      HMAC context to be initialized
./platform_references_code.txt:./Common/Crypto/sha1.h: * \param key      HMAC secret key
./platform_references_code.txt:./Common/Crypto/sha1.h: * \param keylen   length of the HMAC key
./platform_references_code.txt:./Common/Crypto/sha1.h:void sha1_hmac_starts( sha1_context *ctx, unsigned char *key, int keylen );
./platform_references_code.txt:./Common/Crypto/sha1.h: * \brief          SHA-1 HMAC process buffer
./platform_references_code.txt:./Common/Crypto/sha1.h: * \param ctx      HMAC context
./platform_references_code.txt:./Common/Crypto/sha1.h:void sha1_hmac_update( sha1_context *ctx, unsigned char *input, int ilen );
./platform_references_code.txt:./Common/Crypto/sha1.h: * \brief          SHA-1 HMAC final digest
./platform_references_code.txt:./Common/Crypto/sha1.h: * \param ctx      HMAC context
./platform_references_code.txt:./Common/Crypto/sha1.h: * \param output   SHA-1 HMAC checksum result
./platform_references_code.txt:./Common/Crypto/sha1.h:void sha1_hmac_finish( sha1_context *ctx, unsigned char output[20] );
./platform_references_code.txt:./Common/Crypto/sha1.h: * \brief          Output = HMAC-SHA-1( hmac key, input buffer )
./platform_references_code.txt:./Common/Crypto/sha1.h: * \param key      HMAC secret key
./platform_references_code.txt:./Common/Crypto/sha1.h: * \param keylen   length of the HMAC key
./platform_references_code.txt:./Common/Crypto/sha1.h: * \param output   HMAC-SHA-1 result
./platform_references_code.txt:./Common/Crypto/sha1.h:void sha1_hmac( unsigned char *key, int keylen,
./platform_references_code.txt:./Common/Data/Encoding/Utf8.cpp:#include <windows.h>
./platform_references_code.txt:./Common/Data/Format/IniFile.cpp:#include <iostream>
./platform_references_code.txt:./Common/Data/Format/ZIMLoad.cpp:	/* Check for source > 64K on 16-bit machine: */
./platform_references_code.txt:./Common/Data/Format/ZIMSave.cpp:	/* Check for source > 64K on 16-bit machine: */
./platform_references_code.txt:./Common/Data/Text/Parsers.cpp:bool ParseMacAddress(const std::string &str, uint8_t macAddr[6]) {
./platform_references_code.txt:./Common/Data/Text/Parsers.cpp:	unsigned int mac[6];
./platform_references_code.txt:./Common/Data/Text/Parsers.cpp:	if (6 != sscanf(str.c_str(), "%02x:%02x:%02x:%02x:%02x:%02x", &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5])) {
./platform_references_code.txt:./Common/Data/Text/Parsers.cpp:		macAddr[i] = mac[i];
./platform_references_code.txt:./Common/Data/Text/Parsers.h:bool ParseMacAddress(const std::string &str, uint8_t macAddr[6]);
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:#include "Common/MachineContext.h"
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:#ifdef MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:// We cannot handle exceptions in UWP builds. Bleh.
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:static void ExceptionThread(mach_port_t port) {
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:	SetCurrentThreadName("Mach exception thread");
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		mach_msg_header_t Head;
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		mach_msg_type_number_t codeCnt;
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		mach_msg_type_number_t old_stateCnt;
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		mach_msg_trailer_t trailer;
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		mach_msg_header_t Head;
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		mach_msg_type_number_t new_stateCnt;
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:	mach_msg_header_t* send_msg = &msg_out.Head;
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:	mach_msg_size_t send_size = 0;
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:	mach_msg_option_t option = MACH_RCV_MSG;
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		// a message: either a mach_exception_raise_state RPC due to
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		// thread_set_exception_ports, or MACH_NOTIFY_NO_SENDERS due to
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		// mach_port_request_notification.
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		CheckKR("mach_msg_overwrite",
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:			mach_msg_overwrite(send_msg, option, send_size, sizeof(msg_in), port,
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:				MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL, &msg_in.Head, 0));
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		if (msg_in.Head.msgh_id == MACH_NOTIFY_NO_SENDERS) {
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:			mach_port_destroy(mach_task_self(), port);
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		msg_out.Head.msgh_bits = MACH_MSGH_BITS(MACH_MSGH_BITS_REMOTE(msg_in.Head.msgh_bits), 0);
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		msg_out.Head.msgh_local_port = MACH_PORT_NULL;
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		option |= MACH_SEND_MSG;
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:	mach_port_t port;
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:	CheckKR("mach_port_allocate",
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port));
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:	CheckKR("mach_port_insert_right",
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND));
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:	// Mach tries the following exception ports in order: thread, task, host.
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		thread_set_exception_ports(mach_thread_self(), EXC_MASK_BAD_ACCESS, port,
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:			EXCEPTION_STATE | MACH_EXCEPTION_CODES, x86_THREAD_STATE64));
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:	// ...and get rid of our copy so that MACH_NOTIFY_NO_SENDERS works.
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:	CheckKR("mach_port_mod_refs",
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		mach_port_mod_refs(mach_task_self(), port, MACH_PORT_RIGHT_SEND, -1));
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:	mach_port_t previous;
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:	CheckKR("mach_port_request_notification",
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:		mach_port_request_notification(mach_task_self(), port, MACH_NOTIFY_NO_SENDERS, 0, port,
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:			MACH_MSG_TYPE_MAKE_SEND_ONCE, &previous));
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:#else  // !MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/ExceptionHandlerSetup.cpp:#endif  // MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/ExceptionHandlerSetup.h:// On Windows, context is a CONTEXT object.
./platform_references_code.txt:./Common/ExceptionHandlerSetup.h:// On Unix/Linux, context is a mcontext_t.
./platform_references_code.txt:./Common/FakeEmitter.h:// Everything that needs to generate machine code should inherit from this.
./platform_references_code.txt:./Common/File/AndroidStorage.cpp:#if PPSSPP_PLATFORM(ANDROID) && !defined(__LIBRETRO__)
./platform_references_code.txt:./Common/File/AndroidStorage.h:#if PPSSPP_PLATFORM(ANDROID) && !defined(__LIBRETRO__)
./platform_references_code.txt:./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/DirListing.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/DirListing.cpp:#include <UWP/UWPHelpers/StorageManager.h>
./platform_references_code.txt:./Common/File/DirListing.cpp:#if !defined(__linux__) && !defined(_WIN32) && !defined(__QNX__)
./platform_references_code.txt:./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/DirListing.cpp:	const int windowsTickResolution = 10000000;
./platform_references_code.txt:./Common/File/DirListing.cpp:	return (int64_t)(ticks / windowsTickResolution - secToUnixEpoch);
./platform_references_code.txt:./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/DirListing.cpp:		std::vector<std::string> drives = File::GetWindowsDrives();
./platform_references_code.txt:./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/DirListing.cpp:std::vector<std::string> GetWindowsDrives() {
./platform_references_code.txt:./Common/File/DirListing.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/DirListing.cpp:#endif  // PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/DirListing.cpp:#endif  // PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/DirListing.h:std::vector<std::string> GetWindowsDrives();
./platform_references_code.txt:./Common/File/DiskFree.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/File/DiskFree.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/DiskFree.cpp:#include "UWP/UWPHelpers/StorageManager.h"
./platform_references_code.txt:./Common/File/DiskFree.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileDescriptor.cpp:		// Windows XP doesn't support inet_ntop.
./platform_references_code.txt:./Common/File/FileUtil.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#include "UWP/UWPHelpers/StorageManager.h"
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if !PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#include <mach-o/dyld.h>
./platform_references_code.txt:./Common/File/FileUtil.cpp:#endif  // !PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if !defined(__linux__) && !defined(_WIN32) && !defined(__QNX__)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./platform_references_code.txt:./Common/File/FileUtil.cpp:	// FileSystem (broadFileSystemAccess) doesn't apply on _wfopen
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#elif PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/File/FileUtil.cpp:	// Make sure Windows will no longer handle critical errors, which means no annoying "No disk" dialog
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#elif (defined(__APPLE__) && !PPSSPP_PLATFORM(IOS)) || defined(__linux__) || defined(KERN_PROC_PATHNAME)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#if defined(__linux__)
./platform_references_code.txt:./Common/File/FileUtil.cpp:#elif defined(__APPLE__) && !PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/File/FileUtil.h:// Mostly to handle UTF-8 filenames better on Windows.
./platform_references_code.txt:./Common/File/Path.cpp:#if PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./platform_references_code.txt:./Common/File/Path.cpp:#include "UWP/UWPHelpers/StorageManager.h"
./platform_references_code.txt:./Common/File/Path.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/Path.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/Path.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/Path.cpp:		// Windows fake-root.
./platform_references_code.txt:./Common/File/Path.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/Path.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/Path.cpp:#if PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./platform_references_code.txt:./Common/File/Path.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/Path.cpp:		// Windows path with drive letter
./platform_references_code.txt:./Common/File/Path.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/Path.cpp:		return true; // Windows path with drive letter
./platform_references_code.txt:./Common/File/Path.cpp:	// We don't support case-insensitive file systems on Windows.
./platform_references_code.txt:./Common/File/Path.h:// Mac OSX case sensitivity defaults off, but is user configurable (when
./platform_references_code.txt:./Common/File/Path.h:#else  // Android, Linux, BSD (and the rest?)
./platform_references_code.txt:./Common/File/Path.h:// Windows paths are always stored with '/' slashes in a Path.
./platform_references_code.txt:./Common/File/Path.h:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/Path.h:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/File/Path.h:	std::string ToCString() const;  // Flips the slashes back to Windows standard, but string still UTF-8.
./platform_references_code.txt:./Common/File/Path.h:	// Not actually always the root of the volume, especially on systems like Mac and Linux where things are often mounted.
./platform_references_code.txt:./Common/File/PathBrowser.h:// "/" is a special path that means the root of the file system. On Windows,
./platform_references_code.txt:./Common/File/VFS/VFS.cpp:	bool isWindowsLocal = (isalpha(path[0]) && path[1] == ':') || startsWith(path, "\\\\") || startsWith(path, "//");
./platform_references_code.txt:./Common/File/VFS/VFS.cpp:	bool isWindowsLocal = false;
./platform_references_code.txt:./Common/File/VFS/VFS.cpp:	return isUnixLocal || isWindowsLocal || isContentURI;
./platform_references_code.txt:./Common/GPU/D3D11/D3D11Loader.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/GPU/D3D11/D3D11Loader.cpp:#error This file should not be compiled for UWP.
./platform_references_code.txt:./Common/GPU/D3D11/D3D11Loader.h:// Standard Windows includes
./platform_references_code.txt:./Common/GPU/D3D11/D3D11Loader.h:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/GPU/D3D11/D3D11Loader.h:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/GPU/D3D11/D3D11Loader.h:#error This file should not be compiled for UWP.
./platform_references_code.txt:./Common/GPU/D3D11/thin3d_d3d11.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/GPU/D3D11/thin3d_d3d11.cpp:#ifndef __LIBRETRO__  // their build server uses an old SDK
./platform_references_code.txt:./Common/GPU/D3D11/thin3d_d3d11.cpp:// https://tedwvc.wordpress.com/2014/01/01/how-to-target-xp-with-vc2012-or-vc2013-and-continue-to-use-the-windows-8-x-sdk/
./platform_references_code.txt:./Common/GPU/D3D11/thin3d_d3d11.cpp:#ifndef __LIBRETRO__
./platform_references_code.txt:./Common/GPU/D3D11/thin3d_d3d11.cpp:	// We no longer support Windows Phone.
./platform_references_code.txt:./Common/GPU/D3D11/thin3d_d3d11.cpp:			// TODO: There are Windows ARM devices that could have Qualcomm here too.
./platform_references_code.txt:./Common/GPU/D3D11/thin3d_d3d11.cpp:#ifndef __LIBRETRO__  // their build server uses an old SDK
./platform_references_code.txt:./Common/GPU/D3D11/thin3d_d3d11.cpp:	// Safety for libretro
./platform_references_code.txt:./Common/GPU/D3D11/thin3d_d3d11.cpp:#ifndef __LIBRETRO__  // their build server uses an old SDK
./platform_references_code.txt:./Common/GPU/D3D11/thin3d_d3d11.cpp:	// TODO: deviceContext1 can actually discard. Useful on Windows Mobile.
./platform_references_code.txt:./Common/GPU/OpenGL/GLCommon.h:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/OpenGL/GLCommon.h:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/OpenGL/GLFeatures.cpp:#if !PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/OpenGL/GLFeatures.cpp:#if defined(WIN32) && !defined(__LIBRETRO__)
./platform_references_code.txt:./Common/GPU/OpenGL/GLFeatures.cpp:		// https://twitter.com/ID_AA_Carmack/status/387383037794603008
./platform_references_code.txt:./Common/GPU/OpenGL/GLFeatures.cpp:		// Hm, this should be available on iOS too.
./platform_references_code.txt:./Common/GPU/OpenGL/GLFeatures.cpp:#elif defined(USING_GLES2) && defined(__linux__)
./platform_references_code.txt:./Common/GPU/OpenGL/GLMemory.cpp:#if !PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/OpenGL/GLQueueRunner.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/OpenGL/GLQueueRunner.cpp:#elif !PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/OpenGL/GLQueueRunner.cpp:#if !PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/OpenGL/GLQueueRunner.cpp:#if PPSSPP_PLATFORM(IOS) && !defined(__LIBRETRO__)
./platform_references_code.txt:./Common/GPU/OpenGL/GLRenderManager.cpp:	// PowerVR GX6xxx / iOS 10.3 - mapping has little improvement, explicit flush is slower.
./platform_references_code.txt:./Common/GPU/OpenGL/GLRenderManager.h:	void StartThread();  // Currently only used on iOS, since we fully recreate the context on Android
./platform_references_code.txt:./Common/GPU/OpenGL/gl3stub.c:#if !PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/OpenGL/gl3stub.c:#endif // PPSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/OpenGL/gl3stub.h:#if !PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/OpenGL/gl3stub.h:#endif   // PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/OpenGL/thin3d_gl.cpp:static const unsigned short blendEqToGL[] = {
./platform_references_code.txt:./Common/GPU/OpenGL/thin3d_gl.cpp:#elif !PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/OpenGL/thin3d_gl.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/OpenGL/thin3d_gl.cpp:				// Older macOS devices seem to have problems defining uint uniforms.
./platform_references_code.txt:./Common/GPU/OpenGL/thin3d_gl.cpp:	bs->eqCol = blendEqToGL[(int)desc.eqCol];
./platform_references_code.txt:./Common/GPU/OpenGL/thin3d_gl.cpp:	bs->eqAlpha = blendEqToGL[(int)desc.eqAlpha];
./platform_references_code.txt:./Common/GPU/ShaderTranslation.cpp:#if PPSSPP_PLATFORM(WINDOWS) && PPSSPP_ARCH(ARM)
./platform_references_code.txt:./Common/GPU/ShaderTranslation.cpp:		// macOS OpenGL 4.1 implementation does not support GL_ARB_shading_language_420pack.
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:#define __STDC_LIMIT_MACROS
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:#include <iostream>
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:		// Windows uses _putenv_s
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:#if !PPSSPP_PLATFORM(MAC) && !PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:	VkResult result = vmaCreateAllocator(&allocatorInfo, &allocator_);
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:VkResult VulkanContext::InitSurface(WindowSystem winsys, void *data1, void *data2) {
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:	case WINDOWSYSTEM_WIN32:
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:	case WINDOWSYSTEM_ANDROID:
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:	case WINDOWSYSTEM_METAL_EXT:
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:	case WINDOWSYSTEM_XLIB:
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:	case WINDOWSYSTEM_XCB:
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:	case WINDOWSYSTEM_WAYLAND:
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:	case WINDOWSYSTEM_DISPLAY:
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:#if !defined(__LIBRETRO__)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:		And when not to use libretro need VkDisplaySurfaceCreateInfoKHR this extension,
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:		// When using the VK_KHR_display extension and not using LIBRETRO, a complete
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.cpp:	// Standard scheme, use the standard macros.
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.h:enum WindowSystem {
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_UNINITIALIZED,
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_WIN32,
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_ANDROID,
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_METAL_EXT,
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_XLIB,
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_XCB,
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_WAYLAND,
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.h:	WINDOWSYSTEM_DISPLAY,
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.h:	VkResult InitSurface(WindowSystem winsys, void *data1, void *data2);
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanContext.h:	WindowSystem winsys_ = WINDOWSYSTEM_UNINITIALIZED;
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanFrameData.h:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanFrameData.h:// iOS doesn't support a large number of timestamp queries natively.
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanFramebuffer.cpp:	VkResult res = vmaCreateImage(vulkan->Allocator(), &ici, &allocCreateInfo, &img.image, &img.alloc, &allocInfo);
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanImage.cpp:	VkResult res = vmaCreateImage(vulkan_->Allocator(), &image_create_info, &allocCreateInfo, &image_, &allocation_, &allocInfo);
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanImage.cpp:		ERROR_LOG(Log::G3D, "vmaCreateImage failed: %s. Destroying image.", VulkanResultToString(res));
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#if !PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(SWITCH)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:	"SDL:Horizon",
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#if PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#elif PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#elif PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#elif PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:	// MoltenVK does no longer seem to support iOS <= 12, despite what the docs say.
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:	INFO_LOG(Log::G3D, "iOS: Vulkan doesn't need loading");
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.h:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.h:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.h:// Putting our own Vulkan function pointers in a namespace ensures that ppsspp_libretro.so doesn't collide with libvulkan.so.
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanLoader.h:#endif  // !PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanMemory.cpp:	VkResult result = vmaCreateBuffer(vulkan_->Allocator(), &b, &allocCreateInfo, &block.buffer, &block.allocation, &allocInfo);
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanQueueRunner.cpp:	VkResult res = vmaCreateImage(vulkan_->Allocator(), &image_info, &allocCreateInfo, &depth_.image, &depth_.alloc, &allocInfo);
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanQueueRunner.cpp:	VkResult res = vmaCreateBuffer(vulkan_->Allocator(), &buf, &allocCreateInfo, &readback->buffer, &readback->allocation, &allocInfo);
./platform_references_code.txt:./Common/GPU/Vulkan/VulkanRenderManager.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Common/GPU/Vulkan/thin3d_vulkan.cpp:static const VkBlendOp blendEqToVk[] = {
./platform_references_code.txt:./Common/GPU/Vulkan/thin3d_vulkan.cpp:		// Color write mask not masking write in certain scenarios with a depth test, see #10421.
./platform_references_code.txt:./Common/GPU/Vulkan/thin3d_vulkan.cpp:	bs->attachments[0].colorBlendOp = blendEqToVk[(int)desc.eqCol];
./platform_references_code.txt:./Common/GPU/Vulkan/thin3d_vulkan.cpp:	bs->attachments[0].alphaBlendOp = blendEqToVk[(int)desc.eqAlpha];
./platform_references_code.txt:./Common/GPU/thin3d_create.h:// Separated this stuff into its own file so we don't get Windows.h included if all we want is the thin3d declarations.
./platform_references_code.txt:./Common/GPU/thin3d_create.h:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/GraphicsContext.h:	virtual bool ThreadFrame(bool waitIfEmpty) { return true; }   // waitIfEmpty should normally be true, except in exit scenarios.
./platform_references_code.txt:./Common/Log.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Log.cpp:#include "CommonWindows.h"
./platform_references_code.txt:./Common/Log.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Log.h:// Currently only actually shows a dialog box on Windows.
./platform_references_code.txt:./Common/Log.h:void SetAssertDialogParent(void *handle);  // HWND on windows. Ignored on other platforms.
./platform_references_code.txt:./Common/Log.h:// Tricky macro to get the basename, that also works if *built* on Win32.
./platform_references_code.txt:./Common/Log.h:// Doesn't mean this macro can be used on Win32 though.
./platform_references_code.txt:./Common/Log.h:// If we're a debug build, _dbg_assert_ is active. Not otherwise, even on Windows.
./platform_references_code.txt:./Common/Log.h:// Just INFO_LOGs on nonWindows. On Windows it outputs to the VS output console.
./platform_references_code.txt:./Common/Log/ConsoleListener.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/Log/ConsoleListener.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/Log/ConsoleListener.cpp:#endif  // PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Log/ConsoleListener.h:// Windows-only.
./platform_references_code.txt:./Common/Log/ConsoleListener.h:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/Log/ConsoleListener.h:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(UWP) && defined(_DEBUG)
./platform_references_code.txt:./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(UWP) || PPSSPP_PLATFORM(SWITCH)
./platform_references_code.txt:./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Log/LogManager.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Log/LogManager.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/Log/LogManager.h:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Log/LogManager.h:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/LoongArchCPUDetect.cpp:#if defined(CPU_FEATURES_OS_LINUX)
./platform_references_code.txt:./Common/LoongArchCPUDetect.cpp:// Only Linux platforms have /proc/cpuinfo
./platform_references_code.txt:./Common/LoongArchCPUDetect.cpp:#if defined(__linux__)
./platform_references_code.txt:./Common/LoongArchCPUDetect.cpp:	// https://github.com/torvalds/linux/blob/master/arch/loongarch/include/uapi/asm/hwcap.h
./platform_references_code.txt:./Common/LoongArchCPUDetect.cpp:#if !defined(__linux__)
./platform_references_code.txt:./Common/LoongArchCPUDetect.cpp:#else // __linux__
./platform_references_code.txt:./Common/MachineContext.h:// Note: If MACHINE_CONTEXT_SUPPORTED is not set after including this,
./platform_references_code.txt:./Common/MachineContext.h:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/MachineContext.h:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/MachineContext.h:#if defined(__LIBRETRO__)
./platform_references_code.txt:./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/MachineContext.h:#elif PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Common/MachineContext.h:#include <mach/mach.h>
./platform_references_code.txt:./Common/MachineContext.h:#include <mach/message.h>
./platform_references_code.txt:./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/MachineContext.h:#elif defined(__linux__)
./platform_references_code.txt:./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/MachineContext.h:#define MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/MachineContext.h:// No context definition for machine
./platform_references_code.txt:./Common/MachineContext.h:#ifdef MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/MachineContext.h:#endif  // MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Common/Math/SIMDHeaders.h:// Weird how you can't just use #pragma in a macro.
./platform_references_code.txt:./Common/MemArena.h:#include "CommonWindows.h"
./platform_references_code.txt:./Common/MemArena.h:#include <mach/mach.h>
./platform_references_code.txt:./Common/MemArenaAndroid.cpp:#include <linux/ashmem.h>
./platform_references_code.txt:./Common/MemArenaAndroid.cpp:// Windows mappings need to be on 64K boundaries, due to Alpha legacy.
./platform_references_code.txt:./Common/MemArenaDarwin.cpp:#include <mach/mach.h>
./platform_references_code.txt:./Common/MemArenaDarwin.cpp:#include <mach/vm_map.h>
./platform_references_code.txt:./Common/MemArenaDarwin.cpp:	kern_return_t retval = vm_allocate(mach_task_self(), &vm_mem, size, VM_FLAGS_ANYWHERE);
./platform_references_code.txt:./Common/MemArenaDarwin.cpp:	vm_deallocate(mach_task_self(), vm_mem, vm_size);
./platform_references_code.txt:./Common/MemArenaDarwin.cpp:	mach_port_t self = mach_task_self();
./platform_references_code.txt:./Common/MemArenaDarwin.cpp:	vm_deallocate(mach_task_self(), addr, size);
./platform_references_code.txt:./Common/MemArenaDarwin.cpp:#if PPSSPP_PLATFORM(IOS) && PPSSPP_ARCH(64BIT)
./platform_references_code.txt:./Common/MemArenaDarwin.cpp:#if PPSSPP_PLATFORM(IOS) && PPSSPP_ARCH(64BIT)
./platform_references_code.txt:./Common/MemArenaDarwin.cpp:	// The caller will need to do probing, like on 32-bit Windows.
./platform_references_code.txt:./Common/MemArenaDarwin.cpp:	kern_return_t retval = vm_allocate(mach_task_self(), &addr, size, VM_FLAGS_ANYWHERE);
./platform_references_code.txt:./Common/MemArenaDarwin.cpp:		vm_deallocate(mach_task_self(), addr, size);
./platform_references_code.txt:./Common/MemArenaPosix.cpp:// Do not sync memory to underlying file. Linux has this by default.
./platform_references_code.txt:./Common/MemArenaWin32.cpp:#include "CommonWindows.h"
./platform_references_code.txt:./Common/MemArenaWin32.cpp:// Windows mappings need to be on 64K boundaries, due to Alpha legacy.
./platform_references_code.txt:./Common/MemArenaWin32.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/MemArenaWin32.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/MemArenaWin32.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/MemoryUtil.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/MemoryUtil.cpp:#include <mach/vm_param.h>
./platform_references_code.txt:./Common/MemoryUtil.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/MemoryUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/MemoryUtil.cpp:#else  // Non-Windows platforms
./platform_references_code.txt:./Common/MemoryUtil.cpp:#endif  // non-windows
./platform_references_code.txt:./Common/MemoryUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/MemoryUtil.cpp:	// This might also come in useful for UWP (Universal Windows Platform) if I'm understanding things correctly.
./platform_references_code.txt:./Common/MemoryUtil.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(UWP) || defined(__OpenBSD__)
./platform_references_code.txt:./Common/MemoryUtil.cpp:#elif PPSSPP_PLATFORM(MAC) && PPSSPP_ARCH(ARM64)
./platform_references_code.txt:./Common/MemoryUtil.cpp:	// Returning true here lets you test the W^X path on Windows and other non-W^X platforms.
./platform_references_code.txt:./Common/MemoryUtil.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/MipsCPUDetect.cpp:// Only Linux platforms have /proc/cpuinfo
./platform_references_code.txt:./Common/MipsCPUDetect.cpp:#if defined(__linux__)
./platform_references_code.txt:./Common/MipsCPUDetect.cpp:#if !defined(__linux__)
./platform_references_code.txt:./Common/MipsCPUDetect.cpp:#else // __linux__
./platform_references_code.txt:./Common/MipsEmitter.h:// Everything that needs to generate machine code should inherit from this.
./platform_references_code.txt:./Common/MsgHandler.h:// Currently only actually shows a dialog box on Windows.
./platform_references_code.txt:./Common/MsgHandler.h:// Tricky macro to get the basename, that also works if *built* on Win32.
./platform_references_code.txt:./Common/Net/HTTPClient.cpp:			// Windows sockets aren't limited by socket number, just by count, so checking FD_SETSIZE there is wrong.
./platform_references_code.txt:./Common/Net/HTTPClient.cpp:#if !PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Net/HTTPServer.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/Net/HTTPServer.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Net/HTTPServer.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Net/Resolve.cpp:#elif defined(SIOCGIFCONF) // Better detection on Linux/UNIX/MacOS/some Android
./platform_references_code.txt:./Common/Net/Resolve.cpp:#else // Fallback to POSIX/Cross-platform way but may not work well on Linux (ie. only shows 127.0.0.1)
./platform_references_code.txt:./Common/Net/Resolve.cpp:		ptr += 5; // Null byte + QTYPE (2 bytes) + QCLASS (2 bytes)
./platform_references_code.txt:./Common/Net/Sinks.cpp:#if !PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Net/Sinks.cpp:#if !PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Net/SocketCompat.h:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Net/SocketCompat.h:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/Net/SocketCompat.h:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/OSVersion.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/OSVersion.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/OSVersion.cpp:struct WindowsReleaseInfo
./platform_references_code.txt:./Common/OSVersion.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/OSVersion.cpp:bool DoesVersionMatchWindows(uint32_t major, uint32_t minor, uint32_t spMajor, uint32_t spMinor, uint32_t build, bool greater) {
./platform_references_code.txt:./Common/OSVersion.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/OSVersion.cpp:		// "Applications not manifested for Windows 10 will return the Windows 8 OS version value (6.2)."
./platform_references_code.txt:./Common/OSVersion.cpp:		// Try to use kernel32.dll instead, for Windows 10+.  Doesn't do SP versions.
./platform_references_code.txt:./Common/OSVersion.cpp:			// To detect Windows 11 we must check build number
./platform_references_code.txt:./Common/OSVersion.cpp:	return DoesVersionMatchWindows(6, 0, 0, 0, 0, true);
./platform_references_code.txt:./Common/OSVersion.cpp:	return DoesVersionMatchWindows(6, 1, 0, 0, 0, true);
./platform_references_code.txt:./Common/OSVersion.cpp:	return DoesVersionMatchWindows(6, 2, 0, 0, 0, true);
./platform_references_code.txt:./Common/OSVersion.cpp:	return DoesVersionMatchWindows(10, 0, 0, 0, 0, true);
./platform_references_code.txt:./Common/OSVersion.cpp:	return DoesVersionMatchWindows(10, 0, 0, 0, 22000, true);
./platform_references_code.txt:./Common/OSVersion.cpp:std::string GetWindowsVersion() {
./platform_references_code.txt:./Common/OSVersion.cpp:	std::vector<std::pair<std::string, WindowsReleaseInfo>> windowsReleases = {
./platform_references_code.txt:./Common/OSVersion.cpp:		{ "Microsoft Windows XP, Service Pack 2", { 5, 1, 2, 0 } },
./platform_references_code.txt:./Common/OSVersion.cpp:		{ "Microsoft Windows XP, Service Pack 3", { 5, 1, 3, 0 } },
./platform_references_code.txt:./Common/OSVersion.cpp:		{ "Microsoft Windows Vista", { 6, 0, 0, 0 } },
./platform_references_code.txt:./Common/OSVersion.cpp:		{ "Microsoft Windows Vista, Service Pack 1", { 6, 0, 1, 0 } },
./platform_references_code.txt:./Common/OSVersion.cpp:		{ "Microsoft Windows Vista, Service Pack 2", { 6, 0, 2, 0 } },
./platform_references_code.txt:./Common/OSVersion.cpp:		{ "Microsoft Windows 7", { 6, 1, 0, 0 } },
./platform_references_code.txt:./Common/OSVersion.cpp:		{ "Microsoft Windows 7, Service Pack 1", { 6, 1, 1, 0 } },
./platform_references_code.txt:./Common/OSVersion.cpp:		{ "Microsoft Windows 8", { 6, 2, 0, 0 } },
./platform_references_code.txt:./Common/OSVersion.cpp:		{ "Microsoft Windows 8.1", { 6, 3, 0, 0 } },
./platform_references_code.txt:./Common/OSVersion.cpp:		{ "Microsoft Windows 10", { 10, 0, 0, 0 } },
./platform_references_code.txt:./Common/OSVersion.cpp:		{ "Microsoft Windows 11", { 10, 0, 0, 0, 22000 } },
./platform_references_code.txt:./Common/OSVersion.cpp:	for (auto release = rbegin(windowsReleases); release != rend(windowsReleases); ++release) {
./platform_references_code.txt:./Common/OSVersion.cpp:		WindowsReleaseInfo releaseInfo = release->second;
./platform_references_code.txt:./Common/OSVersion.cpp:		if (DoesVersionMatchWindows(releaseInfo.major, releaseInfo.minor, releaseInfo.spMajor, releaseInfo.spMinor, releaseInfo.build, releaseInfo.greater)) {
./platform_references_code.txt:./Common/OSVersion.cpp:	return "Unknown version of Microsoft Windows.";
./platform_references_code.txt:./Common/OSVersion.cpp:std::string GetWindowsSystemArchitecture() {
./platform_references_code.txt:./Common/OSVersion.h:bool DoesVersionMatchWindows(uint32_t major, uint32_t minor, uint32_t spMajor, uint32_t spMinor, uint32_t build, bool acceptGreater);
./platform_references_code.txt:./Common/OSVersion.h:std::string GetWindowsVersion();
./platform_references_code.txt:./Common/OSVersion.h:std::string GetWindowsSystemArchitecture();
./platform_references_code.txt:./Common/Profiler/Profiler.cpp:#if PPSSPP_PLATFORM(IOS) && defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_9_0
./platform_references_code.txt:./Common/Profiler/Profiler.cpp:// iOS did not support C++ thread_local before iOS 9
./platform_references_code.txt:./Common/Render/DrawBuffer.h:	// Good for stretching out a white image without edge artifacts that I'm getting on iOS.
./platform_references_code.txt:./Common/Render/Text/draw_text.cpp:#include "Common/Render/Text/draw_text_uwp.h"
./platform_references_code.txt:./Common/Render/Text/draw_text.cpp:#include "Common/Render/Text/draw_text_qt.h"
./platform_references_code.txt:./Common/Render/Text/draw_text.cpp:#include "Common/Render/Text/draw_text_sdl.h"
./platform_references_code.txt:./Common/Render/Text/draw_text.cpp:#if defined(__LIBRETRO__)
./platform_references_code.txt:./Common/Render/Text/draw_text.cpp:#elif defined(_WIN32) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/Render/Text/draw_text.cpp:#elif PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/Render/Text/draw_text.cpp:	drawer = new TextDrawerUWP(draw);
./platform_references_code.txt:./Common/Render/Text/draw_text.cpp:#elif PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/Render/Text/draw_text.cpp:#elif defined(USING_QT_UI)
./platform_references_code.txt:./Common/Render/Text/draw_text.cpp:	drawer = new TextDrawerQt(draw);
./platform_references_code.txt:./Common/Render/Text/draw_text.cpp:#elif USE_SDL2_TTF
./platform_references_code.txt:./Common/Render/Text/draw_text.cpp:	drawer = new TextDrawerSDL(draw);
./platform_references_code.txt:./Common/Render/Text/draw_text_android.cpp:#if PPSSPP_PLATFORM(ANDROID) && !defined(__LIBRETRO__)
./platform_references_code.txt:./Common/Render/Text/draw_text_cocoa.h:#if PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/Render/Text/draw_text_cocoa.mm:#if PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/Render/Text/draw_text_cocoa.mm:#if PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.cpp:#include "Common/Render/Text/draw_text_qt.h"
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.cpp:#if defined(USING_QT_UI)
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.cpp:#include <QtGui/QFont>
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.cpp:#include <QtGui/QImage>
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.cpp:#include <QtGui/QPainter>
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.cpp:#include <QtGui/QFontMetrics>
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.cpp:#include <QtOpenGL/QGLWidget>
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.cpp:TextDrawerQt::TextDrawerQt(Draw::DrawContext *draw) : TextDrawer(draw) {
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.cpp:TextDrawerQt::~TextDrawerQt() {
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.cpp:void TextDrawerQt::SetOrCreateFont(const FontStyle &style) {
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.cpp:void TextDrawerQt::MeasureStringInternal(std::string_view str, float *w, float *h) {
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.cpp:bool TextDrawerQt::DrawStringBitmap(std::vector<uint8_t> &bitmapData, TextStringEntry &entry, Draw::DataFormat texFormat, std::string_view str, int align, bool fullColor) {
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.cpp:	painter.drawText(image.rect(), Qt::AlignTop | Qt::AlignLeft, QString::fromUtf8(str.data(), str.length()));
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.cpp:void TextDrawerQt::ClearFonts() {
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.h:#if defined(USING_QT_UI)
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.h:class TextDrawerQt : public TextDrawer {
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.h:	TextDrawerQt(Draw::DrawContext *draw);
./platform_references_code.txt:./Common/Render/Text/draw_text_qt.h:	~TextDrawerQt();
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:#include "Common/Render/Text/draw_text_sdl.h"
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:#if defined(USE_SDL2_TTF)
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:#include "SDL2/SDL.h"
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:#include "SDL2/SDL_ttf.h"
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:TextDrawerSDL::TextDrawerSDL(Draw::DrawContext *draw): TextDrawer(draw) {
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:		ERROR_LOG(Log::G3D, "Unable to initialize SDL2_ttf");
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:#if defined(USE_SDL2_TTF_FONTCONFIG)
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:TextDrawerSDL::~TextDrawerSDL() {
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:#if defined(USE_SDL2_TTF_FONTCONFIG)
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:// If a user complains about missing characters on SDL, re-visit this!
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:void TextDrawerSDL::PrepareFallbackFonts(std::string_view locale) {
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:#if defined(USE_SDL2_TTF_FONTCONFIG)
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:#elif PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:uint32_t TextDrawerSDL::CheckMissingGlyph(std::string_view text) {
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:int TextDrawerSDL::FindFallbackFonts(uint32_t missingGlyph, int ptSize) {
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:void TextDrawerSDL::SetOrCreateFont(const FontStyle &style) {
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:		INFO_LOG(Log::G3D, "Loading SDL font '%s' from VFS at size %d pts", useFont.c_str(), ptSize);
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:			SDL_RWops *rw = SDL_RWFromMem(fileData, static_cast<int>(fileSz));
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:void TextDrawerSDL::MeasureStringInternal(std::string_view str, float *w, float *h) {
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:bool TextDrawerSDL::DrawStringBitmap(std::vector<uint8_t> &bitmapData, TextStringEntry &entry, Draw::DataFormat texFormat, std::string_view str, int align, bool fullColor) {
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:	// If a string includes only newlines, SDL2_ttf will refuse to render it
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:#if SDL_TTF_VERSION_ATLEAST(2, 20, 0)
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:	SDL_Color fgColor = { 0xFF, 0xFF, 0xFF, 0xFF };
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:	SDL_Surface *text = TTF_RenderUTF8_Blended_Wrapped(font, processedStr.c_str(), fgColor, 0);
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:	SDL_LockSurface(text);
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:	SDL_UnlockSurface(text);
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:	SDL_FreeSurface(text);
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.cpp:void TextDrawerSDL::ClearFonts() {
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.h:#if defined(USE_SDL2_TTF)
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.h:#include "SDL2/SDL.h"
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.h:#include "SDL2/SDL_ttf.h"
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.h:#if defined(USE_SDL2_TTF_FONTCONFIG)
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.h:class TextDrawerSDL : public TextDrawer {
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.h:	TextDrawerSDL(Draw::DrawContext *draw);
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.h:	~TextDrawerSDL();
./platform_references_code.txt:./Common/Render/Text/draw_text_sdl.h:#if defined(USE_SDL2_TTF_FONTCONFIG)
./platform_references_code.txt:./Common/Render/Text/draw_text_uwp.cpp:#include "Common/Render/Text/draw_text_uwp.h"
./platform_references_code.txt:./Common/Render/Text/draw_text_uwp.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/Render/Text/draw_text_uwp.cpp:TextDrawerUWP::TextDrawerUWP(Draw::DrawContext *draw) : TextDrawer(draw), ctx_(nullptr) {
./platform_references_code.txt:./Common/Render/Text/draw_text_uwp.cpp:	// It's fine to assume we are using D3D11 in UWP
./platform_references_code.txt:./Common/Render/Text/draw_text_uwp.cpp:TextDrawerUWP::~TextDrawerUWP() {
./platform_references_code.txt:./Common/Render/Text/draw_text_uwp.cpp:void TextDrawerUWP::SetOrCreateFont(const FontStyle &style) {
./platform_references_code.txt:./Common/Render/Text/draw_text_uwp.cpp:void TextDrawerUWP::MeasureStringInternal(std::string_view str, float *w, float *h) {
./platform_references_code.txt:./Common/Render/Text/draw_text_uwp.cpp:bool TextDrawerUWP::DrawStringBitmap(std::vector<uint8_t> &bitmapData, TextStringEntry &entry, Draw::DataFormat texFormat, std::string_view str, int align, bool fullColor) {
./platform_references_code.txt:./Common/Render/Text/draw_text_uwp.cpp:void TextDrawerUWP::ClearFonts() {
./platform_references_code.txt:./Common/Render/Text/draw_text_uwp.h:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/Render/Text/draw_text_uwp.h:class TextDrawerUWP : public TextDrawer {
./platform_references_code.txt:./Common/Render/Text/draw_text_uwp.h:	TextDrawerUWP(Draw::DrawContext *draw);
./platform_references_code.txt:./Common/Render/Text/draw_text_uwp.h:	~TextDrawerUWP();
./platform_references_code.txt:./Common/Render/Text/draw_text_win.cpp:#if defined(_WIN32) && !defined(USING_QT_UI) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/Render/Text/draw_text_win.cpp:#include <Windows.h>
./platform_references_code.txt:./Common/Render/Text/draw_text_win.h:#if defined(_WIN32) && !defined(USING_QT_UI) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/RiscVCPUDetect.cpp:#if defined(CPU_FEATURES_OS_LINUX)
./platform_references_code.txt:./Common/RiscVCPUDetect.cpp:// Only Linux platforms have /proc/cpuinfo
./platform_references_code.txt:./Common/RiscVCPUDetect.cpp:#if defined(__linux__)
./platform_references_code.txt:./Common/RiscVCPUDetect.cpp:#if !defined(__linux__)
./platform_references_code.txt:./Common/RiscVCPUDetect.cpp:#else // __linux__
./platform_references_code.txt:./Common/RiscVEmitter.cpp:#if PPSSPP_ARCH(RISCV64) && PPSSPP_PLATFORM(LINUX)
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	VMACC = 0b101101,
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	VFMACC = 0b101100,
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	VFNMACC = 0b101101,
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	VWMACCU = 0b111100,
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	VWMACC = 0b111101,
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	VWMACCUS = 0b111110,
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	VWMACCSU = 0b111111,
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	VFWMACC = 0b111100,
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	VFWNMACC = 0b111101,
./platform_references_code.txt:./Common/RiscVEmitter.cpp:#if PPSSPP_PLATFORM(LINUX)
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeMVV(vd, vs1, vs2, vm, Funct6::VMACC));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VMACC_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeMVX(vd, rs1, vs2, vm, Funct6::VMACC));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VWMACCU_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeMVV(vd, vs1, vs2, vm, Funct6::VWMACCU));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VWMACCU_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeMVX(vd, rs1, vs2, vm, Funct6::VWMACCU));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VWMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeMVV(vd, vs1, vs2, vm, Funct6::VWMACC));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VWMACC_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeMVX(vd, rs1, vs2, vm, Funct6::VWMACC));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VWMACCSU_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeMVV(vd, vs1, vs2, vm, Funct6::VWMACCSU));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VWMACCSU_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeMVX(vd, rs1, vs2, vm, Funct6::VWMACCSU));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VWMACCUS_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeMVX(vd, rs1, vs2, vm, Funct6::VWMACCUS));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VFMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeFVV(vd, vs1, vs2, vm, Funct6::VFMACC));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VFMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeFVF(vd, rs1, vs2, vm, Funct6::VFMACC));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VFNMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeFVV(vd, vs1, vs2, vm, Funct6::VFNMACC));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VFNMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeFVF(vd, rs1, vs2, vm, Funct6::VFNMACC));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VFWMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeFVV(vd, vs1, vs2, vm, Funct6::VFWMACC));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VFWMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeFVF(vd, rs1, vs2, vm, Funct6::VFWMACC));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VFWNMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeFVV(vd, vs1, vs2, vm, Funct6::VFWNMACC));
./platform_references_code.txt:./Common/RiscVEmitter.cpp:void RiscVEmitter::VFWNMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm) {
./platform_references_code.txt:./Common/RiscVEmitter.cpp:	Write32(EncodeFVF(vd, rs1, vs2, vm, Funct6::VFWNMACC));
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VMACC_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VWMACCU_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VWMACCU_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VWMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VWMACC_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VWMACCSU_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VWMACCSU_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VWMACCUS_VX(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VFMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VFMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VFNMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VFNMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VFWMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VFWMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VFWNMACC_VV(RiscVReg vd, RiscVReg vs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/RiscVEmitter.h:	void VFWNMACC_VF(RiscVReg vd, RiscVReg rs1, RiscVReg vs2, VUseMask vm = VUseMask::NONE);
./platform_references_code.txt:./Common/Serialize/SerializeFuncs.h:// Which also can be a problem, for example struct tm is non-POD on linux, for whatever reason...
./platform_references_code.txt:./Common/Serialize/Serializer.h:	// If it's not null, it will be used, but only hope can save you from overruns at the end. For libretro.
./platform_references_code.txt:./Common/StringUtils.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/StringUtils.h:// if not nullptr. Useful for Windows menu strings.
./platform_references_code.txt:./Common/SysError.cpp:#include "CommonWindows.h"
./platform_references_code.txt:./Common/System/Display.h:// On some platforms (currently only Windows UWP) we need to manually rotate
./platform_references_code.txt:./Common/System/Request.h:// images with the file browser below. If you provide savePath, iOS will be able to
./platform_references_code.txt:./Common/System/System.h:// These APIs must be implemented by every port (for example app-android.cpp, SDLMain.cpp).
./platform_references_code.txt:./Common/System/System.h:	// for iOS IAP support
./platform_references_code.txt:./Common/System/System.h:	// Exposed on SDL.
./platform_references_code.txt:./Common/System/System.h:	// iOS app store limitation: The documents directory should be the only browsable directory.
./platform_references_code.txt:./Common/Thread/ThreadUtil.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Thread/ThreadUtil.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/Thread/ThreadUtil.cpp:#if (PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(LINUX)) && !defined(_GNU_SOURCE)
./platform_references_code.txt:./Common/Thread/ThreadUtil.cpp:#if !PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Thread/ThreadUtil.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/Thread/ThreadUtil.cpp:		// Failed to find the function. Windows version too old, most likely.
./platform_references_code.txt:./Common/Thread/ThreadUtil.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/Thread/ThreadUtil.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Thread/ThreadUtil.cpp:#elif PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(LINUX)
./platform_references_code.txt:./Common/Thread/ThreadUtil.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Thread/ThreadUtil.cpp:#if __LIBRETRO__
./platform_references_code.txt:./Common/Thread/ThreadUtil.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/Thread/ThreadUtil.cpp:#elif PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/Thread/ThreadUtil.cpp:#elif PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(LINUX)
./platform_references_code.txt:./Common/Thunk.cpp:	// Account for the return address and "home space" on Windows (which needs to be at the bottom.)
./platform_references_code.txt:./Common/TimeUtil.cpp:#include "CommonWindows.h"
./platform_references_code.txt:./Common/TimeUtil.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Common/TimeUtil.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Common/TimeUtil.cpp:#elif PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(LINUX) || PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Common/TimeUtil.cpp:	// Precise Windows sleep function from: https://github.com/blat-blatnik/Snippets/blob/main/precise_sleep.c
./platform_references_code.txt:./Common/TimeUtil.h:// This is only interesting for Linux, in relation to VK_GOOGLE_display_timing.
./platform_references_code.txt:./Common/TimeUtil.h:// Sleep for milliseconds. Does not necessarily have millisecond granularity, especially on Windows.
./platform_references_code.txt:./Common/TimeUtil.h:// Sleep for microseconds. Does not necessarily have microsecond granularity, especially on Windows.
./platform_references_code.txt:./Common/TimeUtil.h:// Precise sleep. Can consume a little bit of CPU on Windows at least.
./platform_references_code.txt:./Common/UI/Root.cpp:				// We stupidly interpret the joystick Y axis backwards on Android and Linux instead of reversing
./platform_references_code.txt:./Common/UI/Root.cpp:#if PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(LINUX) || PPSSPP_PLATFORM(SWITCH)
./platform_references_code.txt:./Common/UI/View.cpp:// Handles both windows and unix line endings.
./platform_references_code.txt:./Common/VR/OpenXRLoader.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/VR/OpenXRLoader.h:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Common/VR/OpenXRLoader.h:// On Windows (and Linux etc), we're not so lucky - we could link to static libraries, but we really
./platform_references_code.txt:./Common/x64Emitter.cpp:	sseMOVDQtoRM   = 0x7F,
./platform_references_code.txt:./Common/x64Emitter.cpp:	// Nop strings from https://stackoverflow.com/questions/25545470/long-multi-byte-nops-commonly-understood-macros-or-other-notation
./platform_references_code.txt:./Common/x64Emitter.cpp:void XEmitter::MOVDQA(OpArg arg, X64Reg regOp)  {WriteSSEOp(0x66, sseMOVDQtoRM, regOp, arg);}
./platform_references_code.txt:./Common/x64Emitter.cpp:void XEmitter::MOVDQU(OpArg arg, X64Reg regOp)  {WriteSSEOp(0xF3, sseMOVDQtoRM, regOp, arg);}
./platform_references_code.txt:./Common/x64Emitter.cpp:void XEmitter::VMOVDQA(int bits, OpArg arg, X64Reg regOp1) { WriteAVXOp(bits, 0x66, sseMOVDQtoRM, regOp1, arg); }
./platform_references_code.txt:./Common/x64Emitter.cpp:void XEmitter::VMOVDQU(int bits, OpArg arg, X64Reg regOp1) { WriteAVXOp(bits, 0xF3, sseMOVDQtoRM, regOp1, arg); }
./platform_references_code.txt:./Common/x64Emitter.h:inline OpArg MAccessibleDisp(X64Reg r, const T *tbase, const T *t) {
./platform_references_code.txt:./Core/AVIDump.cpp:#define __STDC_CONSTANT_MACROS 1
./platform_references_code.txt:./Core/Config.cpp:#if PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Core/Config.cpp:std::string CreateRandMAC() {
./platform_references_code.txt:./Core/Config.cpp:#if PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Core/Config.cpp:#if PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(LINUX) || PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Core/Config.cpp:	ConfigSetting("IgnoreBadMemAccess", SETTING(g_Config, bIgnoreBadMemAccess), true, CfgFlag::DEFAULT),
./platform_references_code.txt:./Core/Config.cpp:#if PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Core/Config.cpp:	ConfigSetting("ShrinkIfWindowSmall", SETTING(g_Config, bShrinkIfWindowSmall), false, CfgFlag::DEFAULT),
./platform_references_code.txt:./Core/Config.cpp:	// Auto on Windows and Linux, 2x on large screens and iOS, 1x elsewhere.
./platform_references_code.txt:./Core/Config.cpp:#if defined(USING_WIN_UI) || defined(USING_QT_UI)
./platform_references_code.txt:./Core/Config.cpp:#elif PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Core/Config.cpp:#if PPSSPP_PLATFORM(ANDROID) || defined(USING_QT_UI) || PPSSPP_PLATFORM(UWP) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Core/Config.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/Config.cpp:	// On older Windows, to be safe, use Direct3D 11.
./platform_references_code.txt:./Core/Config.cpp:#elif PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Core/Config.cpp:	// On Intel (generally older Macs) default to OpenGL.
./platform_references_code.txt:./Core/Config.cpp:#elif PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./Core/Config.cpp:	// TODO: On some additional Linux platforms, we should also default to Vulkan.
./platform_references_code.txt:./Core/Config.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/Config.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/Config.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/Config.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/Config.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Core/Config.cpp:	ConfigSetting("AudioBufferSize", SETTING(g_Config, iSDLAudioBufferSize), 256, CfgFlag::DEFAULT),
./platform_references_code.txt:./Core/Config.cpp:	ConfigSetting("AudioSyncMode", SETTING(g_Config, iAudioPlaybackMode), (int)AudioSyncMode::CLASSIC_PITCH, CfgFlag::DEFAULT),
./platform_references_code.txt:./Core/Config.cpp:	ConfigSetting("IgnoreWindowsKey", SETTING(g_Config, bIgnoreWindowsKey), false, CfgFlag::PER_GAME),
./platform_references_code.txt:./Core/Config.cpp:	ConfigSetting("MacAddress", SETTING(g_Config, sMACAddress), "", CfgFlag::PER_GAME),
./platform_references_code.txt:./Core/Config.cpp:#if defined(USING_WIN_UI) || defined(USING_QT_UI) || PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(SWITCH)
./platform_references_code.txt:./Core/Config.cpp:	// For iOS, issue #19211
./platform_references_code.txt:./Core/Config.cpp:	// Set a default MAC, and correct if it's an old format.
./platform_references_code.txt:./Core/Config.cpp:	if (sMACAddress.length() != 17)
./platform_references_code.txt:./Core/Config.cpp:		sMACAddress = CreateRandMAC();
./platform_references_code.txt:./Core/Config.h:	bool bIgnoreWindowsKey;
./platform_references_code.txt:./Core/Config.h:	bool bIgnoreBadMemAccess;
./platform_references_code.txt:./Core/Config.h:	bool bShrinkIfWindowSmall;
./platform_references_code.txt:./Core/Config.h:	std::string sD3D11Device;  // Windows only
./platform_references_code.txt:./Core/Config.h:	int iWindowWidth;  // Windows and other windowed environments
./platform_references_code.txt:./Core/Config.h:	bool bShowMenuBar;  // Windows-only
./platform_references_code.txt:./Core/Config.h:	int iSDLAudioBufferSize;
./platform_references_code.txt:./Core/Config.h:	// iOS only for now
./platform_references_code.txt:./Core/Config.h:	// Ignored on iOS and other platforms that lack pause.
./platform_references_code.txt:./Core/Config.h:	// Use the hardware scaler to scale up the image to save fillrate. Similar to Windows' window size, really.
./platform_references_code.txt:./Core/Config.h:	std::string sMACAddress;
./platform_references_code.txt:./Core/Config.h:std::string CreateRandMAC();
./platform_references_code.txt:./Core/ConfigValues.h:constexpr int AUDIOSAMPLES_MIN = 0;
./platform_references_code.txt:./Core/ConfigValues.h:constexpr int AUDIOSAMPLES_MAX = 2048;
./platform_references_code.txt:./Core/ConfigValues.h:enum class AudioSyncMode {
./platform_references_code.txt:./Core/ConfigValues.h:// iOS only
./platform_references_code.txt:./Core/Core.cpp:			switch (gpu->ProcessDLQueue()) {
./platform_references_code.txt:./Core/Core.cpp:			// If not a branch, just do a simple single-step, no point in involving the breakpoint machinery.
./platform_references_code.txt:./Core/Core.cpp:	// In jit, we only flush PC when bIgnoreBadMemAccess is off.
./platform_references_code.txt:./Core/Core.cpp:	if ((g_Config.iCpuCore == (int)CPUCore::JIT || g_Config.iCpuCore == (int)CPUCore::JIT_IR) && g_Config.bIgnoreBadMemAccess) {
./platform_references_code.txt:./Core/Core.cpp:	if (!g_Config.bIgnoreBadMemAccess) {
./platform_references_code.txt:./Core/Core.cpp:	// In jit, we only flush PC when bIgnoreBadMemAccess is off.
./platform_references_code.txt:./Core/Core.cpp:	if ((g_Config.iCpuCore == (int)CPUCore::JIT || g_Config.iCpuCore == (int)CPUCore::JIT_IR) && g_Config.bIgnoreBadMemAccess) {
./platform_references_code.txt:./Core/Core.cpp:	if (!g_Config.bIgnoreBadMemAccess || forceReport) {
./platform_references_code.txt:./Core/Core.cpp:	if (!g_Config.bIgnoreBadMemAccess) {
./platform_references_code.txt:./Core/Core.h:// Warning: these three are only used on Windows - debugger integration.
./platform_references_code.txt:./Core/Core.vcxproj:    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
./platform_references_code.txt:./Core/Core.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./Core/Core.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./Core/Core.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./Core/Core.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./Core/Core.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./Core/Core.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./Core/Core.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./platform_references_code.txt:./Core/Core.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./platform_references_code.txt:./Core/Core.vcxproj:  <PropertyGroup Label="UserMacros" />
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ext\libchdr\include;..\ffmpeg\Windows\x86\include;../common;..;../ext/glew;../ext/snappy;../ext/libpng17;../ext/zlib;../ext;../ext/zstd/lib</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <Command>../Windows/git-version-gen.cmd</Command>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ext\libchdr\include;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/glew;../ext/snappy;../ext/libpng17;../ext/zlib;../ext;../ext/zstd/lib;../ext/zstd/lib</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <Command>../Windows/git-version-gen.cmd</Command>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ext\libchdr\include;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/glew;../ext/snappy;../ext/libpng17;../ext/zlib;../ext;../ext/zstd/lib</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <Command>../Windows/git-version-gen.cmd</Command>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ext\libchdr\include;..\ffmpeg\Windows\x86\include;../common;..;../ext/glew;../ext/snappy;../ext/libpng17;../ext/zlib;../ext;../ext/zstd/lib</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <Command>../Windows/git-version-gen.cmd</Command>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ext\libchdr\include;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/glew;../ext/snappy;../ext/libpng17;../ext/zlib;../ext;../ext/zstd/lib;../ext/zstd/lib</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <Command>../Windows/git-version-gen.cmd</Command>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ext\libchdr\include;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/glew;../ext/snappy;../ext/libpng17;../ext/zlib;../ext;../ext/zstd/lib</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <Command>../Windows/git-version-gen.cmd</Command>
./platform_references_code.txt:./Core/Core.vcxproj:    <ClCompile Include="..\ext\libzip\zip_random_uwp.c">
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:    <ClCompile Include="HLE\sceDmac.cpp" />
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|x64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/native/ext/libpng17;../ext/zlib;../ext/native/ext;../ext/armips/;../ext/armips/ext/filesystem/include/;../ext/armips/ext/tinyformat/</AdditionalIncludeDirectories>
./platform_references_code.txt:./Core/Core.vcxproj:    <ClInclude Include="HLE\sceDmac.h" />
./platform_references_code.txt:./Core/Core.vcxproj.filters:    <ClCompile Include="HLE\sceDmac.cpp">
./platform_references_code.txt:./Core/Core.vcxproj.filters:    <ClCompile Include="..\ext\libzip\zip_random_uwp.c">
./platform_references_code.txt:./Core/Core.vcxproj.filters:    <ClInclude Include="HLE\sceDmac.h">
./platform_references_code.txt:./Core/CoreTiming.cpp:	// Now, now... no time machines, please.
./platform_references_code.txt:./Core/CoreTiming.h:// This is a system to schedule events into the emulated machine's future. Time is measured
./platform_references_code.txt:./Core/CwCheat.h:#include <iostream>
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:			// otherwise there may be hidden consequences if the macro is displayed.
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:			// also, don't create a macro if something branches into the middle of it
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:				DisassemblyMacro* macro = NULL;
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:					macro = new DisassemblyMacro(opAddress);
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:					macro->setMacroLi(immediate,rt);
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:					macro = new DisassemblyMacro(opAddress);
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:						delete macro;
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:					macro->setMacroMemory(MIPSGetName(next),immediate,rt,dataSize);
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:				if (macro != NULL)
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:					entries[opAddress] = macro;
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:					for (int i = 0; i < macro->getNumLines(); i++)
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:						lineAddresses.push_back(macro->getLineAddress(i));
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:void DisassemblyMacro::setMacroLi(u32 _immediate, u8 _rt)
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:	type = MACRO_LI;
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:void DisassemblyMacro::setMacroMemory(std::string_view _name, u32 _immediate, u8 _rt, int _dataSize)
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:	type = MACRO_MEMORYIMM;
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:bool DisassemblyMacro::disassemble(u32 address, DisassemblyLineInfo &dest, bool insertSymbols, DebugInterface *cpuDebug)
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:	dest.type = DISTYPE_MACRO;
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:	case MACRO_LI:
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.cpp:	case MACRO_MEMORYIMM:
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.h:enum DisassemblyLineType { DISTYPE_OPCODE, DISTYPE_MACRO, DISTYPE_DATA, DISTYPE_OTHER };
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.h:class DisassemblyMacro: public DisassemblyEntry
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.h:	DisassemblyMacro(u32 _address): address(_address) { }
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.h:	void setMacroLi(u32 _immediate, u8 _rt);
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.h:	void setMacroMemory(std::string_view _name, u32 _immediate, u8 _rt, int _dataSize);
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.h:	enum MacroType { MACRO_LI, MACRO_MEMORYIMM };
./platform_references_code.txt:./Core/Debugger/DisassemblyManager.h:	MacroType type;
./platform_references_code.txt:./Core/Debugger/SymbolMap.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/Debugger/SymbolMap.cpp:#include <WindowsX.h>
./platform_references_code.txt:./Core/Debugger/SymbolMap.cpp:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/Debugger/WebSocket/DisasmSubscriber.cpp:	else if (l.type == DISTYPE_MACRO)
./platform_references_code.txt:./Core/Debugger/WebSocket/DisasmSubscriber.cpp:		json.writeString("type", "macro");
./platform_references_code.txt:./Core/Debugger/WebSocket/DisasmSubscriber.cpp:		json.pushArray("macroEncoding");
./platform_references_code.txt:./Core/Debugger/WebSocket/DisasmSubscriber.cpp:		json.writeNull("macroEncoding");
./platform_references_code.txt:./Core/Debugger/WebSocket/DisasmSubscriber.cpp:	// TODO: Account for bp inside macro?
./platform_references_code.txt:./Core/Debugger/WebSocket/DisasmSubscriber.cpp://     - type: "opcode", "macro", "data", or "other".
./platform_references_code.txt:./Core/Debugger/WebSocket/DisasmSubscriber.cpp://     - macroEncoding: null, or an array of encodings if this line represents multiple instructions.
./platform_references_code.txt:./Core/Debugger/WebSocket/DisasmSubscriber.cpp:		// This accounts for macros as one line, although two instructions.
./platform_references_code.txt:./Core/Debugger/WebSocket/DisasmSubscriber.cpp://  - encoding: resulting encoding at this address.  Always returns one value, even for macros.
./platform_references_code.txt:./Core/Debugger/WebSocket/GPUBufferSubscriber.cpp:#ifndef USING_QT_UI
./platform_references_code.txt:./Core/Debugger/WebSocket/GPUBufferSubscriber.cpp:#ifdef USING_QT_UI
./platform_references_code.txt:./Core/Debugger/WebSocket/GPUBufferSubscriber.cpp:	req.Fail("Not supported on Qt yet, pull requests accepted");
./platform_references_code.txt:./Core/Debugger/WebSocket/WebSocketUtils.h:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/Debugger/WebSocket/WebSocketUtils.h:// Enum name overlapped with UWP macro, quick hack to disable it
./platform_references_code.txt:./Core/Dialog/PSPOskDialog.cpp:#if defined(USING_WIN_UI) || defined(USING_QT_UI) || PPSSPP_PLATFORM(ANDROID)
./platform_references_code.txt:./Core/Dialog/PSPOskDialog.cpp:#if defined(USING_WIN_UI) || defined(USING_QT_UI) || PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(SWITCH)
./platform_references_code.txt:./Core/Dialog/PSPOskDialog.cpp:	// Windows: Fall back to the OSK/continue normally if we're in fullscreen.
./platform_references_code.txt:./Core/Dialog/PSPSaveDialog.h:	enum SaveIOStatus {
./platform_references_code.txt:./Core/Dialog/PSPSaveDialog.h:	volatile SaveIOStatus ioThreadStatus = SAVEIO_NONE;
./platform_references_code.txt:./Core/Dialog/SavedataParam.cpp:	if (sceSdMacInit(ctx1, mode) < 0)
./platform_references_code.txt:./Core/Dialog/SavedataParam.cpp:	if (sceSdMacUpdate(ctx1, data, 0x10) < 0)
./platform_references_code.txt:./Core/Dialog/SavedataParam.cpp:	if (sceSdMacUpdate(ctx1, data + 0x10, *alignedLen) < 0)
./platform_references_code.txt:./Core/Dialog/SavedataParam.cpp:	if (sceSdMacFinal(ctx1, hash, cryptkey) < 0)
./platform_references_code.txt:./Core/Dialog/SavedataParam.cpp:	if (sceSdMacInit(ctx1, mode) < 0)
./platform_references_code.txt:./Core/Dialog/SavedataParam.cpp:	if (sceSdMacUpdate(ctx1, data, 0x10) < 0)
./platform_references_code.txt:./Core/Dialog/SavedataParam.cpp:	if (sceSdMacUpdate(ctx1, data + 0x10, *alignedLen) < 0)
./platform_references_code.txt:./Core/Dialog/SavedataParam.cpp:		if (sceSdMacFinal(ctx1, hash, cryptkey) < 0)
./platform_references_code.txt:./Core/Dialog/SavedataParam.cpp:	if (sceSdMacInit(ctx1, mode & 0xFF) < 0)
./platform_references_code.txt:./Core/Dialog/SavedataParam.cpp:	if (sceSdMacUpdate(ctx1, data, alignedLen) < 0)
./platform_references_code.txt:./Core/Dialog/SavedataParam.cpp:	if (sceSdMacFinal(ctx1, output, cryptkey) < 0)
./platform_references_code.txt:./Core/ELF/ElfReader.h:	ElfMachine GetMachine() const { return (ElfMachine)(u16)(header->e_machine); }
./platform_references_code.txt:./Core/ELF/PSPElfTypes.h:// Machine/Architecture
./platform_references_code.txt:./Core/ELF/PSPElfTypes.h:enum ElfMachine
./platform_references_code.txt:./Core/ELF/PSPElfTypes.h:#define EF_MIPS_MACH_MASK 0x00ff0000
./platform_references_code.txt:./Core/ELF/PSPElfTypes.h:#define EF_MIPS_MACH_PSP  0x00a20000
./platform_references_code.txt:./Core/ELF/PSPElfTypes.h:    Elf32_Half    e_machine;
./platform_references_code.txt:./Core/FileLoaders/DiskCachingFileLoader.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/FileLoaders/DiskCachingFileLoader.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/FileLoaders/DiskCachingFileLoader.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/FileLoaders/LocalFileLoader.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/FileLoaders/LocalFileLoader.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/FileLoaders/LocalFileLoader.cpp:#ifdef HAVE_LIBRETRO_VFS
./platform_references_code.txt:./Core/FileLoaders/LocalFileLoader.cpp:#if !defined(_WIN32) && !defined(HAVE_LIBRETRO_VFS)
./platform_references_code.txt:./Core/FileLoaders/LocalFileLoader.cpp:#if HAVE_LIBRETRO_VFS
./platform_references_code.txt:./Core/FileLoaders/LocalFileLoader.cpp:#if PPSSPP_PLATFORM(ANDROID) && !defined(HAVE_LIBRETRO_VFS)
./platform_references_code.txt:./Core/FileLoaders/LocalFileLoader.cpp:#if defined(HAVE_LIBRETRO_VFS)
./platform_references_code.txt:./Core/FileLoaders/LocalFileLoader.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/FileLoaders/LocalFileLoader.cpp:#if defined(HAVE_LIBRETRO_VFS)
./platform_references_code.txt:./Core/FileLoaders/LocalFileLoader.cpp:#if defined(HAVE_LIBRETRO_VFS)
./platform_references_code.txt:./Core/FileLoaders/LocalFileLoader.cpp:#if defined(HAVE_LIBRETRO_VFS)
./platform_references_code.txt:./Core/FileLoaders/LocalFileLoader.h:#ifdef HAVE_LIBRETRO_VFS
./platform_references_code.txt:./Core/FileLoaders/LocalFileLoader.h:#if !defined(_WIN32) && !defined(HAVE_LIBRETRO_VFS)
./platform_references_code.txt:./Core/FileSystems/BlockDevices.cpp:	MAC_KEY mkey;
./platform_references_code.txt:./Core/FileSystems/BlockDevices.cpp:	sceDrmBBMacInit(&mkey, 3);
./platform_references_code.txt:./Core/FileSystems/BlockDevices.cpp:	sceDrmBBMacUpdate(&kirk_, &mkey, np_header, 0xc0);
./platform_references_code.txt:./Core/FileSystems/BlockDevices.cpp:	bbmac_getkey(&kirk_, &mkey, np_header+0xc0, vkey);
./platform_references_code.txt:./Core/FileSystems/BlockDevices.cpp:		// skip mac check
./platform_references_code.txt:./Core/FileSystems/BlockDevices.h:	u8 mac[16];
./platform_references_code.txt:./Core/FileSystems/DirectoryFileSystem.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/FileSystems/DirectoryFileSystem.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/FileSystems/DirectoryFileSystem.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/FileSystems/DirectoryFileSystem.cpp:	// Convert parameters to Windows permissions and access
./platform_references_code.txt:./Core/FileSystems/DirectoryFileSystem.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/FileSystems/DirectoryFileSystem.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/FileSystems/DirectoryFileSystem.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/FileSystems/DirectoryFileSystem.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/FileSystems/DirectoryFileSystem.cpp:#if !PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/FileSystems/DirectoryFileSystem.cpp:// Windows NT VFAT optimizes valid DOS filenames that are in lowercase.
./platform_references_code.txt:./Core/FileSystems/DirectoryFileSystem.cpp:// The PSP VFAT driver doesn't support this optimization, and behaves like Windows 98.
./platform_references_code.txt:./Core/FileSystems/DirectoryFileSystem.cpp:// This essentially tries to simulate the "Windows 98 world view" on modern operating systems.
./platform_references_code.txt:./Core/FileSystems/DirectoryFileSystem.cpp:	// Then apply transforms to match PSP idiosynchrasies, as we convert the entries.
./platform_references_code.txt:./Core/FileSystems/DirectoryFileSystem.h:// TODO: Remove the Windows-specific code, FILE is fine there too.
./platform_references_code.txt:./Core/FileSystems/ISOFileSystem.h:// Simply wrap around an ISOFileSystem which has all the necessary machinery, while changing
./platform_references_code.txt:./Core/FileSystems/VirtualDiscFileSystem.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/FileSystems/VirtualDiscFileSystem.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/FileSystems/VirtualDiscFileSystem.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/FileSystems/VirtualDiscFileSystem.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/FileSystems/VirtualDiscFileSystem.cpp:#if !PPSSPP_PLATFORM(UWP) && !PPSSPP_PLATFORM(SWITCH)
./platform_references_code.txt:./Core/FileSystems/VirtualDiscFileSystem.h:// TODO: Remove the Windows-specific code, FILE is fine there too.
./platform_references_code.txt:./Core/FrameTiming.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/FrameTiming.cpp:		// Only FIFO mode is supported (like on iOS and some GLES backends).
./platform_references_code.txt:./Core/HLE/AtracCtx2.cpp:// Windows\x64\debug\PPSSPPHeadless.exe  --root pspautotests/tests/../ -o --compare --new-atrac --timeout=30 --graphics=software pspautotests/tests/audio/atrac/stream.prx
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_REQUEST_FAILED              = 0x800202bc,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_REQUEST_DENIED              = 0x800202bd,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_QUEUED                   = 0x800202be,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_NOT_QUEUED               = 0x800202bf,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_RUNNING                  = 0x800202c0,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_NOT_ASSIGNED             = 0x800202c1,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_TIMEOUT                  = 0x800202c2,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_FREED                    = 0x800202c3,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_USED                     = 0x800202c4,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_EMPTY                    = 0x800202c5,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_ABORTED                  = 0x800202c6,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_OP_ERROR                    = 0x800202c7,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_CHANNEL_RESERVED            = 0x800202c8,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_CHANNEL_EXCLUDED            = 0x800202c9,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_PRIVILEGE_ADDRESS           = 0x800202ca,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_NO_ENOUGHSPACE              = 0x800202cb,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_CHANNEL_NOT_ASSIGNED        = 0x800202cc,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_CHILD_OPERATION             = 0x800202cd,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_TOO_MUCH_SIZE               = 0x800202ce,
./platform_references_code.txt:./Core/HLE/ErrorCodes.h:	SCE_KERNEL_ERROR_DMAC_INVALID_ARGUMENT            = 0x800202cf,
./platform_references_code.txt:./Core/HLE/HLE.h:// Don't manually call this, it's called by the various syscall return macros.
./platform_references_code.txt:./Core/HLE/HLETables.cpp:#include "sceDmac.h"
./platform_references_code.txt:./Core/HLE/HLETables.cpp:	{"Pspnet_Show_MacAddr"},
./platform_references_code.txt:./Core/HLE/HLETables.cpp:	Register_sceDmac();
./platform_references_code.txt:./Core/HLE/NetInetConstants.cpp:		// FIXME: SOCK_RAW have some restrictions on newer Windows?
./platform_references_code.txt:./Core/HLE/NetInetConstants.h:// Socket Types (based on https://github.com/justincormack/netbsd-src/blob/master/src/sys/sys/socket.h )
./platform_references_code.txt:./Core/HLE/NetInetConstants.h:#define	PSP_NET_INET_SOCK_RAW			3			// raw-protocol interface // SOCK_RAW is similar to but not compatible with the obsolete AF_INET / SOCK_PACKET // SOCK_RAW have some restrictions on newer Windows https://docs.microsoft.com/en-us/windows/win32/winsock/tcp-ip-raw-sockets-2
./platform_references_code.txt:./Core/HLE/NetInetConstants.h:#define PSP_NET_INET_SOCK_PACKET		10			// Linux specific way of getting packets at the dev level. For writing rarp and other similar things on the user level // SOCK_PACKET is an obsolete socket type to receive raw packets directly from the device driver
./platform_references_code.txt:./Core/HLE/NetInetConstants.h:// Option flags per-socket (based on SOL_SOCKET value on PSP (0xffff) seems to be different with linux/android's auto-generated socket.h (1), but similar to posix/gnu/BSD <sys/socket.h> like this https://github.com/eblot/newlib/blob/master/newlib/libc/sys/linux/sys/socket.h ?)
./platform_references_code.txt:./Core/HLE/NetInetConstants.h:#define ERROR_INET_ESOCKTNOSUPPORT	124	// Socket type not supported (linux?)
./platform_references_code.txt:./Core/HLE/ReplaceTables.h:// own parameter parsing using the old school PARAM macros.
./platform_references_code.txt:./Core/HLE/ThreadQueueList.h:		// Start smack in the middle so it can move both directions.
./platform_references_code.txt:./Core/HLE/__sceAudio.cpp:void __AudioShutdown() {
./platform_references_code.txt:./Core/HLE/__sceAudio.cpp:void __AudioSetOutputFrequency(int freq) {
./platform_references_code.txt:./Core/HLE/__sceAudio.cpp:void __AudioSetSRCFrequency(int freq) {
./platform_references_code.txt:./Core/HLE/__sceAudio.h:void __AudioShutdown();
./platform_references_code.txt:./Core/HLE/__sceAudio.h:void __AudioSetOutputFrequency(int freq);
./platform_references_code.txt:./Core/HLE/__sceAudio.h:void __AudioSetSRCFrequency(int freq);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:std::vector<SceNetEtherAddr> requiredGameModeMacs;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:std::vector<SceNetEtherAddr> gameModeMacs;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:// Broadcast MAC
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:uint8_t broadcastMAC[ETHER_ADDR_LEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:bool isMacMatch(const SceNetEtherAddr* addr1, const SceNetEtherAddr* addr2) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:bool isLocalMAC(const SceNetEtherAddr * addr) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	getLocalMac(&saddr);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	return isMacMatch(addr, &saddr);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:bool isPTPPortInUse(uint16_t port, bool forListen, SceNetEtherAddr* dstmac, uint16_t dstport) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:			// It's allowed to Listen and Open the same PTP port, But it's not allowed to Listen or Open the same PTP port twice (unless destination mac or port are different).
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:			      sock->data.ptp.pport == dstport && dstmac != nullptr && isMacMatch(&sock->data.ptp.paddr, dstmac)))) 
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:std::string mac2str(const SceNetEtherAddr *mac) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	if (mac != NULL) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		snprintf(str, sizeof(str), "%02x:%02x:%02x:%02x:%02x:%02x", mac->data[0], mac->data[1], mac->data[2], mac->data[3], mac->data[4], mac->data[5]);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:SceNetAdhocMatchingMemberInternal* addMember(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	if (context == NULL || mac == NULL) return NULL;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, mac);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		WARN_LOG(Log::sceNet, "Member Peer Already Existed! Updating [%s]", mac2str(mac).c_str());
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:			peer->mac = *mac;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	SceNetAdhocctlPeerInfo * peer = findFriend(&packet->mac);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		WARN_LOG(Log::sceNet, "Friend Peer Already Existed! Updating [%s][%s][%s]", mac2str(&packet->mac).c_str(), ip2str(*(struct in_addr*)&tmpip).c_str(), packet->name.data); //inet_ntoa(*(in_addr*)&packet->ip)
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		peer->mac_addr = packet->mac;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:			// Save MAC Address
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:			peer->mac_addr = packet->mac;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:SceNetAdhocctlPeerInfo * findFriend(SceNetEtherAddr * MAC) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	if (MAC == NULL) return NULL;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		if (isMacMatch(&peer->mac_addr, MAC)) break;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	// Avoid getting Fatal signal 6 (SIGABRT) on linux/android
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	// Note: select will flags an unconnected TCP socket (ie. a freshly created socket without connecting first, or when connect failed with ECONNREFUSED on linux) as writeable/readable, thus can't be used to tell whether the connection has established or not.
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	for (; group != NULL && (!excludeSelf || !isLocalMAC(&group->bssid.mac_addr)); group = group->next) count++;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:SceNetAdhocctlScanInfo * findGroup(SceNetEtherAddr * MAC) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	if (MAC == NULL) return NULL;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		if (isMacMatch(&group->bssid.mac_addr, MAC)) break;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	gameModeMacs.clear();
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	requiredGameModeMacs.clear();
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:			INFO_LOG(Log::sceNet, "Removing Friend Peer %s [%s]", mac2str(&peer->mac_addr).c_str(), ip2str(*(struct in_addr *)&tmpip).c_str()); //inet_ntoa(*(in_addr*)&peer->ip_addr)
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:* @param siblings Sibling MAC Array
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	// Cast Sibling MAC Array to uint8_t
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		SceNetEtherAddr* mac = (SceNetEtherAddr*)(siblings_u8 + sizeof(SceNetEtherAddr) * i);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		auto peer = findPeer(context, mac);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:			WARN_LOG(Log::sceNet, "Updating Sibling Peer %s", mac2str(mac).c_str());
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:				// Save MAC Address
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:				memcpy(&sibling->mac, mac, sizeof(SceNetEtherAddr));
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:				//spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_ESTABLISHED, &sibling->mac, 0, NULL);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:				INFO_LOG(Log::sceNet, "Accepting Sibling Peer %s", mac2str(&sibling->mac).c_str());
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:* Find Peer in Context by MAC
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:* @param mac Peer MAC Address
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:SceNetAdhocMatchingMemberInternal * findPeer(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac)
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	if (mac == NULL)
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		if (isMacMatch(&peer->mac, mac))
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:			INFO_LOG(Log::sceNet, "Removing Member Peer %s", mac2str(&peer->mac).c_str());
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:* @param mac Target MAC
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:void sendGenericMessage(SceNetAdhocMatchingContext * context, int stack, SceNetEtherAddr * mac, int opcode, int optlen, const void * opt)
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		// Set Peer MAC Address
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		header->mac = *mac;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	auto peer = findPeer(context, mac);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_INPUT_STACK, &peer->mac, PSP_ADHOC_MATCHING_PACKET_ACCEPT, optlen, opt);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_INPUT_STACK, &peer->mac, PSP_ADHOC_MATCHING_PACKET_JOIN, optlen, opt);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_INPUT_STACK, &peer->mac, PSP_ADHOC_MATCHING_PACKET_CANCEL, optlen, opt);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_INPUT_STACK, &peer->mac, PSP_ADHOC_MATCHING_PACKET_BULK, datalen, data);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_INPUT_STACK, &peer->mac, PSP_ADHOC_MATCHING_PACKET_BULK_ABORT, 0, NULL);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_INPUT_STACK, &peer->mac, PSP_ADHOC_MATCHING_PACKET_BIRTH, 0, NULL);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_INPUT_STACK, &peer->mac, PSP_ADHOC_MATCHING_PACKET_DEATH, 0, NULL);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:* @param mac Event Source MAC
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:void spawnLocalEvent(SceNetAdhocMatchingContext * context, int event, SceNetEtherAddr * mac, int optlen, void * opt)
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	sendGenericMessage(context, PSP_ADHOC_MATCHING_EVENT_STACK, mac, event, optlen, opt);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:				spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_TIMEOUT, &peer->mac, 0, NULL);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:				INFO_LOG(Log::sceNet, "TimedOut Member Peer %s (%lld - %lld = %lld > %lld us)", mac2str(&peer->mac).c_str(), now, peer->lastping, (now - peer->lastping), context->timeout);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	DEBUG_LOG(Log::sceNet, "AfterMatchingMipsCall::run [ID=%i][Event=%d][%s] [cbId: %u][retV0: %08x]", contextID, EventID, mac2str((SceNetEtherAddr*)Memory::GetPointer(bufAddr)).c_str(), call.cbId, v0);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:				// Send Ping to Server, may failed with socket error 10054/10053 if someone else with the same IP already connected to AdHoc Server (the server might need to be modified to differentiate MAC instead of IP)
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:						INFO_LOG(Log::sceNet, "FriendFinder: Incoming OPCODE_CONNECT_BSSID [%s]", mac2str(&packet->mac).c_str());
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:						parameter.bssid.mac_addr = packet->mac; // This packet seems to contains Adhoc Group Creator's BSSID (similar to AP's BSSID) so it shouldn't get mixed up with local MAC address. Note: On JPCSP + prx files params.bssid is hardcoded to "Jpcsp\0" and doesn't match to any of player's mac
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:							SceNetEtherAddr localMac;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:							getLocalMac(&localMac);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:							if (std::find_if(gameModeMacs.begin(), gameModeMacs.end(),
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:								[localMac](SceNetEtherAddr const& e) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:									return isMacMatch(&e, &localMac);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:								}) == gameModeMacs.end()) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:								gameModeMacs.push_back(localMac);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:								if (netAdhocGameModeEntered && gameModeMacs.size() >= requiredGameModeMacs.size()) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:								WARN_LOG(Log::sceNet, "GameMode SelfMember [%s] Already Existed!", mac2str(&localMac).c_str());
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:						INFO_LOG(Log::sceNet, "FriendFinder: Incoming OPCODE_CONNECT [%s][%s][%s]", mac2str(&packet->mac).c_str(), ip2str(*(in_addr*)&ipaddr).c_str(), packet->name.data);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:						// Make sure GameMode participants are all joined (including self MAC)
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:							if (std::find_if(gameModeMacs.begin(), gameModeMacs.end(),
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:									return isMacMatch(&e, &packet->mac);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:								}) == gameModeMacs.end()) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:								SceNetEtherAddr localMac;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:								getLocalMac(&localMac);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:								auto it = std::find_if(gameModeMacs.begin(), gameModeMacs.end(),
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:									[localMac](SceNetEtherAddr const& e) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:										return isMacMatch(&e, &localMac);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:								if (it != gameModeMacs.end()) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:									gameModeMacs.push_back(packet->mac);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:									it = gameModeMacs.begin() + 1;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:									gameModeMacs.insert(it, packet->mac);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:								// From JPCSP: Join complete when all the required MACs have joined
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:								if (netAdhocGameModeEntered && requiredGameModeMacs.size() > 0 && gameModeMacs.size() == requiredGameModeMacs.size()) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:									// TODO: Should we replace gameModeMacs contents with requiredGameModeMacs contents to make sure they are in the same order with macs from sceNetAdhocctlCreateEnterGameMode? But may not be consistent with the list on client side!
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:									//gameModeMacs = requiredGameModeMacs;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:								WARN_LOG(Log::sceNet, "GameMode Member [%s] Already Existed!", mac2str(&packet->mac).c_str());
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:								if (isMacMatch(&gma.mac, &peer->mac_addr)) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:						// Delete User by IP, should delete by MAC since IP can be shared (behind NAT) isn't?
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:							group->bssid.mac_addr = packet->mac;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:void getLocalMac(SceNetEtherAddr * addr){
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	// Read MAC Address from config
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	uint8_t mac[ETHER_ADDR_LEN] = {0};
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		memset(&mac, PPSSPP_ID, sizeof(mac));
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		mac[0] &= 0xfc;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	if (!ParseMacAddress(g_Config.sMACAddress, mac)) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		ERROR_LOG(Log::sceNet, "Error parsing mac address %s", g_Config.sMACAddress.c_str());
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		memset(&mac, 0, sizeof(mac));
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	memcpy(addr, mac, ETHER_ADDR_LEN);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		// TODO: May need to filter out packets from an IP that can't be translated to MAC address
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	if (timeout_usec > 0 && optval == 0) optval = 1; // Since there are games that use 100 usec timeout, we should set it to minimum value on Windows (1 msec) instead of using 0 (0 = indefinitely timeout)
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	// Set SIGPIPE when supported (ie. BSD/MacOS X)
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	// Note: Linux might have SO_NOSIGPIPE defined too, but using it on setsockopt will result to EINVAL error
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	// On Windows: Connection Reset error on UDP could cause a strange behavior https://stackoverflow.com/questions/34242622/windows-udp-sockets-recvfrom-fails-with-error-10054
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:#define TCP_KEEPIDLE	TCP_KEEPALIVE //TCP_KEEPIDLE on Linux is equivalent to TCP_KEEPALIVE on macOS
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	//getLocalMac(&parameter.bssid.mac_addr);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	getLocalMac(&addres);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	packet.mac = addres;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:bool isZeroMAC(const SceNetEtherAddr* addr) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:bool isBroadcastMAC(const SceNetEtherAddr * addr) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:bool resolveIP(uint32_t ip, SceNetEtherAddr * mac) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		getLocalMac(mac);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:			*mac = peer->mac_addr;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:bool resolveMAC(SceNetEtherAddr* mac, uint32_t* ip, u16* port_offset) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	// Get Local MAC Address
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	SceNetEtherAddr localMac;
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	getLocalMac(&localMac);
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	// Local MAC Requested
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:	if (isMacMatch(&localMac, mac)) {
./platform_references_code.txt:./Core/HLE/proAdhoc.cpp:		if (isMacMatch(&peer->mac_addr, mac)) {
./platform_references_code.txt:./Core/HLE/proAdhoc.h:// Broadcast MAC
./platform_references_code.txt:./Core/HLE/proAdhoc.h:extern uint8_t broadcastMAC[ETHER_ADDR_LEN];
./platform_references_code.txt:./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac_addr;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac_addr;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac_addr;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:	SceNetEtherAddr mac_addr;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:	SceNetEtherAddr mac_addr;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:	SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:  // MAC Address
./platform_references_code.txt:./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac; // peer //u32_le macaddr;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:  // Target MAC Address
./platform_references_code.txt:./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:  // Local MAC Address
./platform_references_code.txt:./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:  SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:	SceNetEtherAddr fromMAC;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:	SceNetEtherAddr toMAC;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:	u32_le numMACs; //number of peers
./platform_references_code.txt:./Core/HLE/proAdhoc.h:	/*u32_le*/PSPPointer<SceNetEtherAddr> MACsPtr; //peers //SceNetEtherAddr * MACs
./platform_references_code.txt:./Core/HLE/proAdhoc.h:extern std::vector<SceNetEtherAddr> requiredGameModeMacs;
./platform_references_code.txt:./Core/HLE/proAdhoc.h:extern std::vector<SceNetEtherAddr> gameModeMacs;
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * Compare MAC Addresses
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * @param addr1 & addr2 To-be-compared MAC Address
./platform_references_code.txt:./Core/HLE/proAdhoc.h:bool isMacMatch(const SceNetEtherAddr* addr1, const SceNetEtherAddr* addr2);
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * Local MAC Check
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * @param saddr To-be-checked MAC Address
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * @return True if it's local mac
./platform_references_code.txt:./Core/HLE/proAdhoc.h:bool isLocalMAC(const SceNetEtherAddr * addr);
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * @param dstmac destination address (non-listening only)
./platform_references_code.txt:./Core/HLE/proAdhoc.h:bool isPTPPortInUse(uint16_t port, bool forListen, SceNetEtherAddr* dstmac = nullptr, uint16_t dstport = 0);
./platform_references_code.txt:./Core/HLE/proAdhoc.h:// Convert MAC address to string
./platform_references_code.txt:./Core/HLE/proAdhoc.h:std::string mac2str(const SceNetEtherAddr *mac);
./platform_references_code.txt:./Core/HLE/proAdhoc.h://SceNetAdhocMatchingMemberInternal* findMember(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac); // findPeer
./platform_references_code.txt:./Core/HLE/proAdhoc.h:SceNetAdhocMatchingMemberInternal* addMember(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac);
./platform_references_code.txt:./Core/HLE/proAdhoc.h://void deleteMember(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac); // deletePeer
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * Find a Peer/Friend by MAC address
./platform_references_code.txt:./Core/HLE/proAdhoc.h:SceNetAdhocctlPeerInfo * findFriend(SceNetEtherAddr * MAC);
./platform_references_code.txt:./Core/HLE/proAdhoc.h:SceNetAdhocctlScanInfo * findGroup(SceNetEtherAddr * MAC);
./platform_references_code.txt:./Core/HLE/proAdhoc.h:* Find Peer in Context by MAC
./platform_references_code.txt:./Core/HLE/proAdhoc.h:* @param mac Peer MAC Address
./platform_references_code.txt:./Core/HLE/proAdhoc.h:SceNetAdhocMatchingMemberInternal * findPeer(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac);
./platform_references_code.txt:./Core/HLE/proAdhoc.h:* @param mac Event Source MAC
./platform_references_code.txt:./Core/HLE/proAdhoc.h:void spawnLocalEvent(SceNetAdhocMatchingContext * context, int event, SceNetEtherAddr * mac, int optlen, void * opt);
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * Returns the locall Ip of this machine
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * Returns the local mac
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * @param addr OUT: 6-bytes of Local Mac
./platform_references_code.txt:./Core/HLE/proAdhoc.h:void getLocalMac(SceNetEtherAddr * addr);
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * Zero MAC Check
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * @param addr To-be-checked MAC Address
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * @return true if MAC is all zeroes
./platform_references_code.txt:./Core/HLE/proAdhoc.h:bool isZeroMAC(const SceNetEtherAddr* addr);
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * Broadcast MAC Check
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * @param addr To-be-checked MAC Address
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * @return true if Broadcast MAC or... 0
./platform_references_code.txt:./Core/HLE/proAdhoc.h:bool isBroadcastMAC(const SceNetEtherAddr * addr);
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * Resolve IP to MAC
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * @param mac OUT: Peer MAC
./platform_references_code.txt:./Core/HLE/proAdhoc.h:bool resolveIP(uint32_t ip, SceNetEtherAddr * mac);
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * Resolve MAC to IP
./platform_references_code.txt:./Core/HLE/proAdhoc.h: * @param mac Peer MAC Address
./platform_references_code.txt:./Core/HLE/proAdhoc.h:bool resolveMAC(SceNetEtherAddr* mac, uint32_t* ip, u16* port_offset = nullptr);
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:	{ "ULES00368", "Micro Machines V4" },
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:	{ "ULUS10543", "WWE Smackdown vs. Raw 2011" },
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:	if(valid_product_code == 1 && memcmp(&data->mac, "\xFF\xFF\xFF\xFF\xFF\xFF", sizeof(data->mac)) != 0 && memcmp(&data->mac, "\x00\x00\x00\x00\x00\x00", sizeof(data->mac)) != 0 && data->name.data[0] != 0)
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:		// Check for duplicated MAC as most games identify Players by MAC
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:		while (u != NULL && !IsMatch(u->resolver.mac, data->mac)) u = u->next;
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:		if (u != NULL) { // MAC Already existed
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:			WARN_LOG(Log::sceNet, "AdhocServer: Already Existing MAC: %s [%s]\n", mac2str(&data->mac).c_str(), ip2str(*(in_addr*)&u->resolver.ip).c_str());
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:			// Save MAC
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:			user->resolver.mac = data->mac;
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:			INFO_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) started playing %s", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr);
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:		INFO_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) stopped playing %s", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr);
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:			bssid.mac = user->resolver.mac;
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:					// Set Player MAC
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:					packet.mac = user->resolver.mac;
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:					// Set Player MAC
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:					packet.mac = peer->resolver.mac;
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:					if(peer->group_next == NULL) bssid.mac = peer->resolver.mac;
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:				INFO_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) joined %s group %s", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr, safegroupstr);
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:			WARN_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) attempted to join %s group %s without disconnecting from %s first", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr, safegroupstr, safegroupstr2);
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:		WARN_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) attempted to join invalid %s group %s", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr, safegroupstr);
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:		INFO_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) left %s group %s", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr, safegroupstr);
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:		WARN_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) attempted to leave %s group without joining one first", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr);
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:					// Set Group Host MAC
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:					packet.mac = peer->resolver.mac;
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:		INFO_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) requested information on %d %s groups", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), user->game->groupcount, safegamestr);
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:		WARN_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) attempted to scan for %s groups without disconnecting from %s first", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr, safegroupstr);
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:			INFO_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) sent \"%s\" to %d players in %s group %s", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), message, counter, safegamestr, safegroupstr);
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:		WARN_LOG(Log::sceNet, "AdhocServer: %s (MAC: %s - IP: %s) attempted to send a text message without joining a %s group first", (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str(), safegamestr);
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:		// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:				// Alternative Accept Approach (some Linux Kernel don't support the accept4 Syscall... wtf?)
./platform_references_code.txt:./Core/HLE/proAdhocServer.cpp:						WARN_LOG(Log::sceNet, "AdhocServer: Invalid Opcode 0x%02X in Logged-In State from %s (MAC: %s - IP: %s)", user->rx[0], (char *)user->resolver.name.data, mac2str(&user->resolver.mac).c_str(), ip2str(*(in_addr*)&user->resolver.ip).c_str());
./platform_references_code.txt:./Core/HLE/proAdhocServer.h:// Ethernet Address (MAC)
./platform_references_code.txt:./Core/HLE/proAdhocServer.h:	SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/proAdhocServer.h:	SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/proAdhocServer.h:	SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/proAdhocServer.h:	SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/proAdhocServer.h:	// PSP MAC Address
./platform_references_code.txt:./Core/HLE/proAdhocServer.h:	SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:static u32 sceAudioSetChannelDataLen(u32 chan, u32 len) {
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:	__AudioSetSRCFrequency(0);
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:static u32 sceAudioSetFrequency(u32 freq) {
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:		INFO_LOG(Log::sceAudio, "sceAudioSetFrequency(%08x)", freq);
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:		__AudioSetOutputFrequency(freq);
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:		ERROR_LOG(Log::sceAudio, "sceAudioSetFrequency(%08x) - invalid frequency (must be 44.1 or 48 khz)", freq);
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:static u32 sceAudioSetVolumeOffset() {
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:	ERROR_LOG(Log::sceAudio, "UNIMPL sceAudioSetVolumeOffset()");
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:static u32 sceAudioSRCChReserve(u32 sampleCount, u32 freq, u32 format) {
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:	__AudioSetSRCFrequency(freq);
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:static u32 sceAudioSRCChRelease() {
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:static u32 sceAudioSRCOutputBlocking(u32 vol, u32 buf) {
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:	{0XA2BEAA6C, &WrapU_U<sceAudioSetFrequency>,            "sceAudioSetFrequency",          'x', "i"   },
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:	{0X927AC32B, &WrapU_V<sceAudioSetVolumeOffset>,         "sceAudioSetVolumeOffset",       'x', ""    },
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:	{0XCB2E439E, &WrapU_UU<sceAudioSetChannelDataLen>,      "sceAudioSetChannelDataLen",     'x', "ii"  },
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:	{0X38553111, &WrapU_UUU<sceAudioSRCChReserve>,          "sceAudioSRCChReserve",          'x', "iii" },
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:	{0X5C37C0AE, &WrapU_V<sceAudioSRCChRelease>,            "sceAudioSRCChRelease",          'x', ""    },
./platform_references_code.txt:./Core/HLE/sceAudio.cpp:	{0XE0727056, &WrapU_UU<sceAudioSRCOutputBlocking>,      "sceAudioSRCOutputBlocking",     'x', "xx"  },
./platform_references_code.txt:./Core/HLE/sceAudiocodec.cpp:// g_audioDecoderContexts is to store current playing audios.
./platform_references_code.txt:./Core/HLE/sceChnnlsv.cpp:	return hleLogDebug(Log::sceMisc, sceSdMacFinal(*ctx, hash, Memory::GetPointerWrite(addressKey)));
./platform_references_code.txt:./Core/HLE/sceChnnlsv.cpp:int sceSdMacFinal(pspChnnlsvContext1& ctx, u8* in_hash, const u8* in_key)
./platform_references_code.txt:./Core/HLE/sceChnnlsv.cpp:	sceSdMacInit(ctx, 0);
./platform_references_code.txt:./Core/HLE/sceChnnlsv.cpp:	return hleLogDebug(Log::sceMisc, sceSdMacInit(*ctx, value));
./platform_references_code.txt:./Core/HLE/sceChnnlsv.cpp:int sceSdMacInit(pspChnnlsvContext1& ctx, int value)
./platform_references_code.txt:./Core/HLE/sceChnnlsv.cpp:	return hleLogDebug(Log::sceMisc, sceSdMacUpdate(*ctx, Memory::GetPointerWrite(addressData), length));
./platform_references_code.txt:./Core/HLE/sceChnnlsv.cpp:int sceSdMacUpdate(pspChnnlsvContext1& ctx, const u8* data, int length)
./platform_references_code.txt:./Core/HLE/sceChnnlsv.h:int sceSdMacInit(pspChnnlsvContext1& ctx, int value);
./platform_references_code.txt:./Core/HLE/sceChnnlsv.h:int sceSdMacUpdate(pspChnnlsvContext1& ctx, const u8* data, int length);
./platform_references_code.txt:./Core/HLE/sceChnnlsv.h:int sceSdMacFinal(pspChnnlsvContext1& ctx, u8* in_hash, const u8* in_key);
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:#include "Core/HLE/sceDmac.h"
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:u64 dmacMemcpyDeadline;
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:void __DmacInit() {
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:	dmacMemcpyDeadline = 0;
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:void __DmacDoState(PointerWrap &p) {
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:	auto s = p.Section("sceDmac", 0, 1);
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:		dmacMemcpyDeadline = 0;
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:	Do(p, dmacMemcpyDeadline);
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:static int __DmacMemcpy(u32 dst, u32 src, u32 size) {
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:			NotifyMemInfoCopy(dst, src, size, "DmacMemcpy/");
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:		dmacMemcpyDeadline = CoreTiming::GetTicks() + usToCycles(delayUs);
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:static u32 sceDmacMemcpy(u32 dst, u32 src, u32 size) {
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:	if (dmacMemcpyDeadline > CoreTiming::GetTicks()) {
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:		WARN_LOG(Log::HLE, "sceDmacMemcpy(dest=%08x, src=%08x, size=%d): overlapping read", dst, src, size);
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:	int delay = __DmacMemcpy(dst, src, size);
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:	return delay ? hleDelayResult(result, "dmac-memcpy", delay) : delay;
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:static u32 sceDmacTryMemcpy(u32 dst, u32 src, u32 size) {
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:	if (dmacMemcpyDeadline > CoreTiming::GetTicks()) {
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:	int delay = __DmacMemcpy(dst, src, size);
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:	return delay ? hleDelayResult(result, "dmac-memcpy", delay) : delay;
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:const HLEFunction sceDmac[] = {
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:	{0X617F3FE6, &WrapU_UUU<sceDmacMemcpy>,          "sceDmacMemcpy",    'x', "xxx"},
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:	{0XD97F94D8, &WrapU_UUU<sceDmacTryMemcpy>,       "sceDmacTryMemcpy", 'x', "xxx"},
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:void Register_sceDmac() {
./platform_references_code.txt:./Core/HLE/sceDmac.cpp:	RegisterHLEModule("sceDmac", ARRAY_SIZE(sceDmac), sceDmac);
./platform_references_code.txt:./Core/HLE/sceDmac.h:void __DmacInit();
./platform_references_code.txt:./Core/HLE/sceDmac.h:void __DmacDoState(PointerWrap &p);
./platform_references_code.txt:./Core/HLE/sceDmac.h:void Register_sceDmac();
./platform_references_code.txt:./Core/HLE/sceGe.cpp:		DLResult result = gpu->ProcessDLQueue();
./platform_references_code.txt:./Core/HLE/sceGe.cpp:			DLResult result = gpu->ProcessDLQueue();
./platform_references_code.txt:./Core/HLE/sceGe.cpp:			gpu->ProcessDLQueue();
./platform_references_code.txt:./Core/HLE/sceGe.cpp:			gpu->ProcessDLQueue();
./platform_references_code.txt:./Core/HLE/sceGe.cpp:			gpu->ProcessDLQueue();
./platform_references_code.txt:./Core/HLE/sceGe.cpp:			gpu->ProcessDLQueue();
./platform_references_code.txt:./Core/HLE/sceIo.cpp:struct SceIoStat {
./platform_references_code.txt:./Core/HLE/sceIo.cpp:	SceIoStat d_stat;
./platform_references_code.txt:./Core/HLE/sceIo.cpp:static void __IoSyncNotify(u64 userdata, int cyclesLate) {
./platform_references_code.txt:./Core/HLE/sceIo.cpp:		ERROR_LOG_REPORT(Log::sceIo, "__IoSyncNotify: file no longer exists?");
./platform_references_code.txt:./Core/HLE/sceIo.cpp:	syncNotifyEvent = CoreTiming::RegisterEvent("IoSyncNotify", __IoSyncNotify);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:	CoreTiming::RestoreRegisterEvent(syncNotifyEvent, "IoSyncNotify", __IoSyncNotify);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:void __IoShutdown() {
./platform_references_code.txt:./Core/HLE/sceIo.cpp:static void IoStartAsyncThread(int id, FileNode *f) {
./platform_references_code.txt:./Core/HLE/sceIo.cpp:static void __IoGetStat(SceIoStat *stat, PSPFileInfo &info) {
./platform_references_code.txt:./Core/HLE/sceIo.cpp:	memset(stat, 0xfe, sizeof(SceIoStat));
./platform_references_code.txt:./Core/HLE/sceIo.cpp:static void __IoSchedAsync(FileNode *f, int fd, int usec) {
./platform_references_code.txt:./Core/HLE/sceIo.cpp:static void __IoSchedSync(FileNode *f, int fd, int usec) {
./platform_references_code.txt:./Core/HLE/sceIo.cpp:	auto stat = PSPPointer<SceIoStat>::Create(addr);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:static u32 sceIoChstat(const char *filename, u32 iostatptr, u32 changebits) {
./platform_references_code.txt:./Core/HLE/sceIo.cpp:	auto iostat = PSPPointer<SceIoStat>::Create(iostatptr);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:	if (!iostat.IsValid())
./platform_references_code.txt:./Core/HLE/sceIo.cpp:	ERROR_LOG(Log::sceIo, "UNIMPL sceIoChstat(%s, %08x, %08x)", filename, iostatptr, changebits);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:		ERROR_LOG_REPORT(Log::sceIo, "sceIoChstat: change mode to %03o requested", iostat->st_mode);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:		ERROR_LOG_REPORT(Log::sceIo, "sceIoChstat: change attr to %04x requested", iostat->st_attr);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:		ERROR_LOG_REPORT(Log::sceIo, "sceIoChstat: change modification time to %04d-%02d-%02d requested", iostat->st_m_time.year, iostat->st_m_time.month, iostat->st_m_time.day);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:		__IoSchedSync(f, id, us);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:		IoStartAsyncThread(id, f);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:		__IoSchedSync(f, id, us);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:		IoStartAsyncThread(id, f);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:		IoStartAsyncThread(id, f);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:		IoStartAsyncThread(id, f);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:static u32 sceIoSync(const char *devicename, int flag) {
./platform_references_code.txt:./Core/HLE/sceIo.cpp:	IoStartAsyncThread(id, f);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:static u32 sceIoSetAsyncCallback(int id, u32 clbckId, u32 clbckArg) {
./platform_references_code.txt:./Core/HLE/sceIo.cpp:	IoStartAsyncThread(fd, f);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:		IoStartAsyncThread(id, f);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:		__IoSchedAsync(f, id, us);
./platform_references_code.txt:./Core/HLE/sceIo.cpp:	{0XA12A0514, &WrapU_IUU<sceIoSetAsyncCallback>,     "sceIoSetAsyncCallback",       'i', "ixx"   },
./platform_references_code.txt:./Core/HLE/sceIo.cpp:	{0xAB96437F, &WrapU_CI<sceIoSync>,                  "sceIoSync",                   'i', "si"    },
./platform_references_code.txt:./Core/HLE/sceIo.cpp:	{0xAB96437F, &WrapU_CI<sceIoSync>,                  "sceIoSync",                   'i', "si",     HLE_KERNEL_SYSCALL },
./platform_references_code.txt:./Core/HLE/sceIo.cpp:	{0XA46785C9, nullptr,                               "sceKernelStdioSendChar",      '?', ""      },
./platform_references_code.txt:./Core/HLE/sceIo.h:void __IoShutdown();
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:#include "sceDmac.h"
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	__DmacInit();
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	__AudioShutdown();
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	__IoShutdown();
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	{0X6D212BAC, &WrapI_IIU<sceKernelWaitSemaCB>,                    "sceKernelWaitSemaCB",                       'i', "iix",    HLE_NOT_IN_INTERRUPT | HLE_NOT_DISPATCH_SUSPENDED },
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202bc: return "DMAC_REQUEST_FAILED";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202bd: return "DMAC_REQUEST_DENIED";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202be: return "DMAC_OP_QUEUED";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202bf: return "DMAC_OP_NOT_QUEUED";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202c0: return "DMAC_OP_RUNNING";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202c1: return "DMAC_OP_NOT_ASSIGNED";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202c2: return "DMAC_OP_TIMEOUT";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202c3: return "DMAC_OP_FREED";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202c4: return "DMAC_OP_USED";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202c5: return "DMAC_OP_EMPTY";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202c6: return "DMAC_OP_ABORTED";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202c7: return "DMAC_OP_ERROR";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202c8: return "DMAC_CHANNEL_RESERVED";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202c9: return "DMAC_CHANNEL_EXCLUDED";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202ca: return "DMAC_PRIVILEGE_ADDRESS";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202cb: return "DMAC_NO_ENOUGHSPACE";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202cc: return "DMAC_CHANNEL_NOT_ASSIGNED";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202cd: return "DMAC_CHILD_OPERATION";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202ce: return "DMAC_TOO_MUCH_SIZE";
./platform_references_code.txt:./Core/HLE/sceKernel.cpp:	case 0x800202cf: return "DMAC_INVALID_ARGUMENT";
./platform_references_code.txt:./Core/HLE/sceKernelInterrupt.h:	PSP_DMACPLUS_INTR  = 21,
./platform_references_code.txt:./Core/HLE/sceKernelModule.cpp:				// Seen in WWE: Smackdown vs Raw 2009. See #17435.
./platform_references_code.txt:./Core/HLE/sceKernelSemaphore.cpp:		DEBUG_LOG(Log::sceKernel, "sceKernelWaitSemaCB: Suspending sema wait for callback");
./platform_references_code.txt:./Core/HLE/sceKernelSemaphore.cpp:		WARN_LOG_REPORT(Log::sceKernel, "sceKernelWaitSemaCB: beginning callback with bad wait id?");
./platform_references_code.txt:./Core/HLE/sceKernelSemaphore.cpp:		DEBUG_LOG(Log::sceKernel, "sceKernelWaitSemaCB: Resuming sema wait for callback");
./platform_references_code.txt:./Core/HLE/sceKernelSemaphore.cpp:int sceKernelWaitSemaCB(SceUID id, int wantedCount, u32 timeoutPtr) {
./platform_references_code.txt:./Core/HLE/sceKernelSemaphore.h:int sceKernelWaitSemaCB(SceUID semaid, int signal, u32 timeoutPtr);
./platform_references_code.txt:./Core/HLE/sceKernelTime.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/HLE/sceMpeg.cpp:		ctx->mediaengine->setAudioStream(streamNum);
./platform_references_code.txt:./Core/HLE/sceMpeg.cpp:		ctx->mediaengine->setAudioStream(streamInfo->second.num);
./platform_references_code.txt:./Core/HLE/sceMpeg.cpp:	ctx->mediaengine->setAudioStream(atracAu.esBuffer);
./platform_references_code.txt:./Core/HLE/sceMpeg.cpp:	ctx->mediaengine->getAudioSamples(bufferAddr);
./platform_references_code.txt:./Core/HLE/sceNet.cpp:#include "Core/MIPS/MIPSCodeUtils.h" // for macros to implement __CreateHLELoop
./platform_references_code.txt:./Core/HLE/sceNet.cpp:	// Windows: Assuming WSAStartup already called beforehand
./platform_references_code.txt:./Core/HLE/sceNet.cpp:	SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/sceNet.cpp:	getLocalMac(&mac);
./platform_references_code.txt:./Core/HLE/sceNet.cpp:	INFO_LOG(Log::sceNet, "LocalHost IP will be %s [%s]", ip2str(g_localhostIP.in.sin_addr).c_str(), mac2str(&mac).c_str());
./platform_references_code.txt:./Core/HLE/sceNet.cpp:	// For libretro we don't have a better place. On other platforms, we just init/shutdown it with the rest of the emu (NativeInit / NativeShutdown).
./platform_references_code.txt:./Core/HLE/sceNet.cpp:#ifdef __LIBRETRO__
./platform_references_code.txt:./Core/HLE/sceNet.cpp:#ifdef __LIBRETRO__
./platform_references_code.txt:./Core/HLE/sceNet.cpp:		// Read MAC Address from config
./platform_references_code.txt:./Core/HLE/sceNet.cpp:		if (!ParseMacAddress(g_Config.sMACAddress, addr)) {
./platform_references_code.txt:./Core/HLE/sceNet.cpp:			ERROR_LOG(Log::sceNet, "Error parsing mac address %s", g_Config.sMACAddress.c_str());
./platform_references_code.txt:./Core/HLE/sceNet.cpp:	return hleDelayResult(hleLogDebug(Log::sceNet, 0), "get ether mac", 200);
./platform_references_code.txt:./Core/HLE/sceNet.cpp:static void sceNetEtherNtostr(u32 macPtr, u32 bufferPtr) {
./platform_references_code.txt:./Core/HLE/sceNet.cpp:	DEBUG_LOG(Log::sceNet, "sceNetEtherNtostr(%08x, %08x) at %08x", macPtr, bufferPtr, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNet.cpp:	if (Memory::IsValidAddress(bufferPtr) && Memory::IsValidAddress(macPtr)) {
./platform_references_code.txt:./Core/HLE/sceNet.cpp:		const u8 *mac = Memory::GetPointerUnchecked(macPtr);
./platform_references_code.txt:./Core/HLE/sceNet.cpp:		// MAC address is always 6 bytes / 48 bits.
./platform_references_code.txt:./Core/HLE/sceNet.cpp:			mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
./platform_references_code.txt:./Core/HLE/sceNet.cpp:static void sceNetEtherStrton(u32 bufferPtr, u32 macPtr) {
./platform_references_code.txt:./Core/HLE/sceNet.cpp:	DEBUG_LOG(Log::sceNet, "sceNetEtherStrton(%08x, %08x)", bufferPtr, macPtr);
./platform_references_code.txt:./Core/HLE/sceNet.cpp:	if (Memory::IsValidAddress(bufferPtr) && Memory::IsValidAddress(macPtr)) {
./platform_references_code.txt:./Core/HLE/sceNet.cpp:		u8 *mac = Memory::GetPointerWrite(macPtr);
./platform_references_code.txt:./Core/HLE/sceNet.cpp:		// MAC address is always 6 pairs of hex digits.
./platform_references_code.txt:./Core/HLE/sceNet.cpp:			*mac++ = value;
./platform_references_code.txt:./Core/HLE/sceNet.cpp:		VERBOSE_LOG(Log::sceNet, "sceNetEtherStrton - [%s]", mac2str((SceNetEtherAddr*)Memory::GetPointer(macPtr)).c_str());
./platform_references_code.txt:./Core/HLE/sceNet.cpp:	memcpy(netApctlInfo.bssid, "\1\1\2\2\3\3", sizeof(netApctlInfo.bssid)); // fake AP's mac address
./platform_references_code.txt:./Core/HLE/sceNet.cpp:		DEBUG_LOG(Log::sceNet, "ApctlInfo - BSSID: %s", mac2str((SceNetEtherAddr*)&netApctlInfo.bssid).c_str());
./platform_references_code.txt:./Core/HLE/sceNet.cpp:			// Generate a BSSID/MAC address
./platform_references_code.txt:./Core/HLE/sceNet.cpp:			char dummyMAC[ETHER_ADDR_LEN];
./platform_references_code.txt:./Core/HLE/sceNet.cpp:			memset(dummyMAC, entryId, sizeof(dummyMAC));
./platform_references_code.txt:./Core/HLE/sceNet.cpp:			dummyMAC[0] &= 0xfc;
./platform_references_code.txt:./Core/HLE/sceNet.cpp:			Memory::Memcpy(resultAddr, dummyMAC, sizeof(dummyMAC), "GetBSSDescEntryUser");
./platform_references_code.txt:./Core/HLE/sceNet.cpp:static int sceNetApctl_lib2_C20A144C(int connIndex, u32 ps3MacAddressPtr) {
./platform_references_code.txt:./Core/HLE/sceNet.cpp:	ERROR_LOG(Log::sceNet, "UNIMPL %s(%i, %08x)", __FUNCTION__, connIndex, ps3MacAddressPtr);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		if (replicaGameModeAreas.size() == (gameModeMacs.size() - 1)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			if (gameModeSocket < 0 && !isZeroMAC(&masterGameModeArea.mac)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:				if ((gameModeSocket = sceNetAdhocPdpCreate((const char*)&masterGameModeArea.mac, ADHOC_GAMEMODE_PORT, gameModeBuffSize, 0)) < 0) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						auto it = gameModePeerPorts.find(gma.mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						int sent = hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, gameModeSocket, (const char*)&gma.mac, port, masterGameModeArea.data, masterGameModeArea.size, 0, ADHOC_F_NONBLOCK);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:							DEBUG_LOG(Log::sceNet, "GameMode: Master data Sent %d bytes to Area #%d [%s]", masterGameModeArea.size, gma.id, mac2str(&gma.mac).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:								auto it = gameModePeerPorts.find(gma.mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:								hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, gameModeSocket, (const char*)&gma.mac, port, masterGameModeArea.data, masterGameModeArea.size, 0, ADHOC_F_NONBLOCK);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:				SceNetEtherAddr sendermac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:				int ret = sceNetAdhocPdpRecv(gameModeSocket, &sendermac, &senderport, gameModeBuffer, &bufsz, 0, ADHOC_F_NONBLOCK);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					if (senderport != ADHOC_GAMEMODE_PORT && senderport != gameModePeerPorts[sendermac]) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						SceNetAdhocctlPeerInfo* peer = findFriend(&sendermac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						WARN_LOG(Log::sceNet, "GameMode: Unknown Source Port from [%s][%s:%u -> %u] (Result=%i, Size=%i)", name, mac2str(&sendermac).c_str(), senderport, ADHOC_GAMEMODE_PORT, ret, bufsz);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					gameModePeerPorts[sendermac] = senderport;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						if (IsMatch(gma.mac, sendermac)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:							DEBUG_LOG(Log::sceNet, "GameMode: Replica data Received %d bytes for Area #%d [%s]", bufsz, gma.id, mac2str(&sendermac).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// On Windows: MSG_TRUNC are not supported on recvfrom (socket error WSAEOPNOTSUPP), so we use dummy buffer as an alternative
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// Discard packets from IP that can't be translated into MAC address to prevent confusing the game, since the sender MAC won't be updated and may contains invalid/undefined value.
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// TODO: In order to discard packets from unresolvable IP (can't be translated into player's MAC) properly, we'll need to manage the socket buffer ourself,
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	if (ret != SOCKET_ERROR && !resolveIP(sin.sin_addr.s_addr, &mac)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			// Find Peer MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			if (resolveIP(sin.sin_addr.s_addr, &mac)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:				*req.remoteMAC = mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:				auto peer = findFriend(&mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// On Windows: recvfrom on UDP can get error WSAECONNRESET when previous sendto's destination is unreachable (or destination port is not bound yet), may need to disable SIO_UDP_CONNRESET error
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		// Find Peer MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		if (resolveIP(sin.sin_addr.s_addr, &mac)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			*req.remoteMAC = mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			auto peer = findFriend(&mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		DEBUG_LOG(Log::sceNet, "sceNetAdhocPtpSend[%i:%u]: Sent %u bytes to %s:%u\n", req.id, ptpsocket.lport, ret, mac2str(&ptpsocket.paddr).c_str(), ptpsocket.pport);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		DEBUG_LOG(Log::sceNet, "sceNetAdhocPtpRecv[%i:%u]: Received %u bytes from %s:%u\n", req.id, ptpsocket.lport, ret, mac2str(&ptpsocket.paddr).c_str(), ptpsocket.pport);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		int newid = AcceptPtpSocket(req.id, ret, sin, req.remoteMAC, req.remotePort);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// Note: On Linux "select" can return > 0 (with SO_ERROR = 0) even when the connection is not accepted yet, thus need "getpeername" to ensure
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			ret = SOCKET_ERROR; // Ensure returned value from select to be negative when the socket is not ready yet, due to a possibility for "getpeername" to succeed on Windows even when "connect" hasn't been accepted yet
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		// Note: "getpeername" shouldn't failed if the connection has been established, but on Windows it may succeed even when "connect" is still in-progress and not accepted yet (ie. "Tales of VS" on Windows)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// On Windows you can call connect again using the same socket after ECONNREFUSED/ETIMEDOUT/ENETUNREACH error, but on non-Windows you'll need to recreate the socket first
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:int WaitBlockingAdhocSocket(u64 threadSocketId, int type, int pspSocketId, void* buffer, s32_le* len, u32 timeoutUS, SceNetEtherAddr* remoteMAC, u16_le* remotePort, const char* reason) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	adhocSocketRequests[threadSocketId] = { type, pspSocketId, buffer, len, tmout, startTime, remoteMAC, remotePort };
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp: * @param saddr Local MAC (Unused)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:int sceNetAdhocPdpCreate(const char *mac, int port, int bufferSize, u32 flag) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	INFO_LOG(Log::sceNet, "sceNetAdhocPdpCreate(%s, %u, %u, %u) at %08x", mac2str((SceNetEtherAddr*)mac).c_str(), port, bufferSize, flag, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr * saddr = (SceNetEtherAddr *)mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		if (mac != NULL && bufferSize > 0) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			// Some games (ie. DBZ Shin Budokai 2) might be getting the saddr/srcmac content from SaveState and causing problems :( So we try to fix it here
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:				getLocalMac(saddr);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			// Valid MAC supplied. FIXME: MAC only valid after successful attempt to Create/Connect/Join a Group? (ie. adhocctlCurrentMode != ADHOCCTL_MODE_NONE)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			if ((adhocctlCurrentMode != ADHOCCTL_MODE_NONE) && isLocalMAC(saddr)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					// Disable Connection Reset error on UDP to avoid strange behavior https://stackoverflow.com/questions/34242622/windows-udp-sockets-recvfrom-fails-with-error-10054
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			// Invalid MAC supplied
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	DEBUG_LOG(Log::sceNet, "sceNetAdhocctlGetParameter(%08x) [Ch=%i][Group=%s][BSSID=%s][name=%s]", paramAddr, parameter.channel, grpName, mac2str(&parameter.bssid.mac_addr).c_str(), parameter.nickname.data);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp: * @param daddr Target MAC Address
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:int sceNetAdhocPdpSend(int id, const char *mac, u32 port, void *data, int len, int timeout, int flag) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		DEBUG_LOG(Log::sceNet, "sceNetAdhocPdpSend(%i, %s, %i, %p, %i, %i, %i) at %08x", id, mac2str((SceNetEtherAddr*)mac).c_str(), port, data, len, timeout, flag, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		VERBOSE_LOG(Log::sceNet, "sceNetAdhocPdpSend(%i, %s, %i, %p, %i, %i, %i) at %08x", id, mac2str((SceNetEtherAddr*)mac).c_str(), port, data, len, timeout, flag, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr * daddr = (SceNetEtherAddr *)mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						if (daddr != NULL && !isZeroMAC(daddr)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:							if (!isBroadcastMAC(daddr)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:								// Get Peer IP. Some games (ie. Vulcanus Seek and Destroy) seems to try to send to zero-MAC (ie. 00:00:00:00:00:00) first before sending to the actual destination MAC.. So may be sending to zero-MAC has a special meaning? (ie. to peek send buffer availability may be?)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:								if (resolveMAC((SceNetEtherAddr *)daddr, (uint32_t *)&target.sin_addr.s_addr, &finalPortOffset)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:								VERBOSE_LOG(Log::sceNet, "sceNetAdhocPdpSend[%i:%u]: Unknown Target Peer %s:%u (faking success)\n", id, getLocalPort(pdpsocket.id), mac2str(daddr).c_str(), ntohs(target.sin_port));
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp: * @param saddr OUT: Source MAC Address
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:				SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					// On Windows: MSG_TRUNC are not supported on recvfrom (socket error WSAEOPNOTSUPP), so we use dummy buffer as an alternative
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					// Discard packets from IP that can't be translated into MAC address to prevent confusing the game, since the sender MAC won't be updated and may contains invalid/undefined value.
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					// TODO: In order to discard packets from unresolvable IP (can't be translated into player's MAC) properly, we'll need to manage the socket buffer ourself,
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					if (received != SOCKET_ERROR && !resolveIP(sin.sin_addr.s_addr, &mac)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					*saddr = mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					auto peer = findFriend(&mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:				// On Windows: Socket Error 10014 may happen when buffer size is less than the minimum allowed/required (ie. negative number on Vulcanus Seek and Destroy), the address is not a valid part of the user address space (ie. on the stack or when buffer overflow occurred), or the address is not properly aligned (ie. multiple of 4 on 32bit and multiple of 8 on 64bit) https://stackoverflow.com/questions/861154/winsock-error-code-10014
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:				// On Windows: recvfrom on UDP can get error WSAECONNRESET when previous sendto's destination is unreachable (or destination port is not bound), may need to disable SIO_UDP_CONNRESET
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					// Find Peer MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					if (resolveIP(sin.sin_addr.s_addr, &mac)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						*saddr = mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						auto peer = findFriend(&mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	//WSAPoll only available for Vista or newer, so we'll use an alternative way for XP since Windows doesn't have poll function like *NIX
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					for (; group != NULL && (!excludeSelf || !isLocalMAC(&group->bssid.mac_addr)) && discovered < requestcount; group = group->next) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:static int sceNetAdhocctlGetNameByAddr(const char *mac, u32 nameAddr) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	DEBUG_LOG(Log::sceNet, "UNTESTED sceNetAdhocctlGetNameByAddr(%s, %08x) at %08x", mac2str((SceNetEtherAddr*)mac).c_str(), nameAddr, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		if (mac != NULL && Memory::IsValidAddress(nameAddr))
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			// Get Local MAC Address
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			SceNetEtherAddr localmac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			getLocalMac(&localmac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			// Local MAC Matches
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			if (isMacMatch(&localmac, (const SceNetEtherAddr*)mac))
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:				if (peer->last_recv != 0 && isMacMatch(&peer->mac_addr, (const SceNetEtherAddr*)mac))
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:int sceNetAdhocctlGetPeerInfo(const char *mac, int size, u32 peerInfoAddr) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	VERBOSE_LOG(Log::sceNet, "sceNetAdhocctlGetPeerInfo(%s, %i, %08x) at %08x", mac2str((SceNetEtherAddr*)mac).c_str(), size, peerInfoAddr, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr * maddr = (SceNetEtherAddr *)mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		// Local MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		if (isLocalMAC(maddr)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			buf->mac_addr = *maddr;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		// Find Peer by MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:				buf->mac_addr = *maddr;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr* addrs = PSPPointer<SceNetEtherAddr>::Create(membersAddr); // List of participating MAC addresses (started from host)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		requiredGameModeMacs.push_back(*addrs);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		DEBUG_LOG(Log::sceNet, "GameMode macAddress#%d=%s", i, mac2str(addrs).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// Add local MAC (Host) first
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr localMac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	getLocalMac(&localMac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	gameModeMacs.push_back(localMac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// 1). PtpListen (srcMacAddress=0x09F20CB4, srcPort=0x8001, bufSize=0x2000, retryDelay=0x30D40, retryCount=0x33, queue=0x1, unk1=0x0)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// 2). PtpAccpet (peerMacAddr=0x09FE2020, peerPortAddr=0x09FE2010, timeout=0x765BB0, nonblock=0x0) - probably for each clients
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// We have to wait for all the MACs to have joined to go into CONNECTED state
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:* @param membersmacAddr - A pointer to a list of the participating mac addresses, host first, then clients.
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:* @param hostmacAddr - The mac address of the host.
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:static int sceNetAdhocctlJoinEnterGameMode(const char * group_name, const char *hostMac, int timeout, int flag) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	WARN_LOG_REPORT_ONCE(sceNetAdhocctlJoinEnterGameMode, Log::sceNet, "UNTESTED sceNetAdhocctlJoinEnterGameMode(%s, %s, %i, %i) at %08x", grpName, mac2str((SceNetEtherAddr*)hostMac).c_str(), timeout, flag, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	if (!hostMac)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// Add host mac first
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	gameModeMacs.push_back(*(SceNetEtherAddr*)hostMac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// 1). PtpOpen (srcMacAddress=0x09FE2080, srcPort=0x8001, destMacAddress=0x09F20CB4, destPort=0x8001, bufSize=0x2000, retryDelay=0x30D40, retryCount=0x33, unk1=0x0)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:* @param members MAC Address List of Peers (own MAC at Index 0)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						// TODO: May need to filter out packets from an IP that can't be translated to MAC address
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp: * @param saddr Local MAC (Unused)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp: * @param daddr Target MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:static int sceNetAdhocPtpOpen(const char *srcmac, int sport, const char *dstmac, int dport, int bufsize, int rexmt_int, int rexmt_cnt, int flag) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	INFO_LOG(Log::sceNet, "sceNetAdhocPtpOpen(%s, %d, %s, %d, %d, %d, %d, %d) at %08x", mac2str((SceNetEtherAddr*)srcmac).c_str(), sport, mac2str((SceNetEtherAddr*)dstmac).c_str(),dport,bufsize, rexmt_int, rexmt_cnt, flag, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr* saddr = (SceNetEtherAddr*)srcmac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr* daddr = (SceNetEtherAddr*)dstmac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		// Some games (ie. DBZ Shin Budokai 2) might be getting the saddr/srcmac content from SaveState and causing problems if current MAC is different :( So we try to fix it here
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			getLocalMac(saddr);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		// Valid Addresses. FIXME: MAC only valid after successful attempt to Create/Connect/Join a Group? (ie. adhocctlCurrentMode != ADHOCCTL_MODE_NONE)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		if ((adhocctlCurrentMode != ADHOCCTL_MODE_NONE) && saddr != NULL && isLocalMAC(saddr) && daddr != NULL && !isBroadcastMAC(daddr) && !isZeroMAC(daddr)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:								// TODO: Need to handle ECONNREFUSED better on non-Windows, if there are games that never called PtpConnect and only relies on [blocking?] PtpOpen to get connected
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		// Peer MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		// Find Peer MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		if (resolveIP(peeraddr.sin_addr.s_addr, &mac)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					getLocalMac(&internal->data.ptp.laddr);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					internal->data.ptp.paddr = mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp: * @param addr OUT: Peer MAC Address
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:static int sceNetAdhocPtpAccept(int id, u32 peerMacAddrPtr, u32 peerPortPtr, int timeout, int flag) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	if (Memory::IsValidAddress(peerMacAddrPtr)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		addr = PSPPointer<SceNetEtherAddr>::Create(peerMacAddrPtr);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		DEBUG_LOG(Log::sceNet, "sceNetAdhocPtpAccept(%d, [%08x]=%s, [%08x]=%u, %d, %u) at %08x", id, peerMacAddrPtr, mac2str(addr).c_str(), peerPortPtr, port ? *port : -1, timeout, flag, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		VERBOSE_LOG(Log::sceNet, "sceNetAdhocPtpAccept(%d, [%08x]=%s, [%08x]=%u, %d, %u) at %08x", id, peerMacAddrPtr, mac2str(addr).c_str(), peerPortPtr, port ? *port : -1, timeout, flag, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		// TODO: Validate Arguments. GTA:VCS seems to use 0/null for the peerPortPtr, and Bomberman Panic Bomber is using null/0 on both peerMacAddrPtr & peerPortPtr, so i guess it's optional.
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:				if (resolveMAC(&ptpsocket.paddr, (uint32_t*)&sin.sin_addr.s_addr, &finalPortOffset)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						// ECONNREFUSED = No connection could be made because the target device actively refused it (on Windows/Linux/Android), or no one listening on the remote address (on Linux/Android) thus should try to connect again later (treated similarly to ETIMEDOUT/ENETUNREACH).
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:							// On Windows you can call connect again using the same socket after ECONNREFUSED/ETIMEDOUT/ENETUNREACH error, but on non-Windows you'll need to recreate the socket first
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:								// Returning WOULD_BLOCK as Workaround for SCE_NET_ADHOC_ERROR_CONNECTION_REFUSED to be more cross-platform, since there is no way to simulate SCE_NET_ADHOC_ERROR_CONNECTION_REFUSED properly on Windows
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp: * @param saddr Local MAC (Unused)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:static int sceNetAdhocPtpListen(const char *srcmac, int sport, int bufsize, int rexmt_int, int rexmt_cnt, int backlog, int flag) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	INFO_LOG(Log::sceNet, "sceNetAdhocPtpListen(%s, %d, %d, %d, %d, %d, %d) at %08x", mac2str((SceNetEtherAddr*)srcmac).c_str(), sport,bufsize,rexmt_int,rexmt_cnt,backlog,flag, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr * saddr = (SceNetEtherAddr *)srcmac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		// Some games (ie. DBZ Shin Budokai 2) might be getting the saddr/srcmac content from SaveState and causing problems :( So we try to fix it here
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			getLocalMac(saddr);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		// Valid Address. FIXME: MAC only valid after successful attempt to Create/Connect/Join a Group? (ie. adhocctlCurrentMode != ADHOCCTL_MODE_NONE)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		if ((adhocctlCurrentMode != ADHOCCTL_MODE_NONE) && saddr != NULL && isLocalMAC(saddr)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						DEBUG_LOG(Log::sceNet, "sceNetAdhocPtpSend[%i:%u]: Sent %u bytes to %s:%u\n", id, ptpsocket.lport, sent, mac2str(&ptpsocket.paddr).c_str(), ptpsocket.pport);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					DEBUG_LOG(Log::sceNet, "sceNetAdhocPtpSend[%i:%u -> %s:%u]: Result:%i (Error:%i)", id, ptpsocket.lport, mac2str(&ptpsocket.paddr).c_str(), ptpsocket.pport, sent, error);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						DEBUG_LOG(Log::sceNet, "sceNetAdhocPtpRecv[%i:%u]: Received %u bytes from %s:%u\n", id, ptpsocket.lport, received, mac2str(&ptpsocket.paddr).c_str(), ptpsocket.pport);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					DEBUG_LOG(Log::sceNet, "sceNetAdhocPtpFlush[%i:%u -> %s:%u]: Error:%i", id, ptpsocket.lport, mac2str(&ptpsocket.paddr).c_str(), ptpsocket.pport, error);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	SceNetEtherAddr localMac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	getLocalMac(&localMac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		masterGameModeArea = { 0, size, dataAddr, CoreTiming::GetGlobalTimeUsScaled(), 1, 0, localMac, data };
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		if (replicaGameModeAreas.size() == (gameModeMacs.size() - 1)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:* @param mac - The mac address of the peer.
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:static int sceNetAdhocGameModeCreateReplica(const char *mac, u32 dataAddr, int size) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	WARN_LOG(Log::sceNet, "UNTESTED sceNetAdhocGameModeCreateReplica(%s, %08x, %i) at %08x", mac2str((SceNetEtherAddr*)mac).c_str(), dataAddr, size, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	if (mac == nullptr || size < 0 || !Memory::IsValidAddress(dataAddr))
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		[mac, &maxid](GameModeArea const& e) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:			return IsMatch(e.mac, mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// MAC address already existed!
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		WARN_LOG(Log::sceNet, "sceNetAdhocGameModeCreateReplica - [%s] is already existed (id: %d)", mac2str((SceNetEtherAddr*)mac).c_str(), it->id);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		//int sock = sceNetAdhocPdpCreate(mac, ADHOC_GAMEMODE_PORT, size, 0);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		GameModeArea gma = { maxid + 1, size, dataAddr, CoreTiming::GetGlobalTimeUsScaled(), 0, 0, *(SceNetEtherAddr*)mac, data };
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		if (masterGameModeArea.data != NULL && replicaGameModeAreas.size() == (gameModeMacs.size() - 1)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	gameModePeerPorts.erase(masterGameModeArea.mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	if (isZeroMAC(&masterGameModeArea.mac))
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	gameModePeerPorts.erase(it->mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	if (replicaGameModeAreas.size() <= 0 && isZeroMAC(&masterGameModeArea.mac)) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:				for (auto& mac : gameModeMacs) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:					INFO_LOG(Log::sceNet, "GameMode macAddress#%d=%s", i++, mac2str(&mac).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	// Writes number of participants and each participating MAC address into infoAddr/gmInfo
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	gmInfo->num = static_cast<s32_le>(gameModeMacs.size());
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:	for (auto& mac : gameModeMacs) {
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		VERBOSE_LOG(Log::sceNet, "GameMode macAddress#%d=%s", i, mac2str(&mac).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:		gmInfo->members[i++] = mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:							buf[discovered].mac_addr = peer->mac_addr;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:							DEBUG_LOG(Log::sceNet, "Peer [%s][%s][%s][%llu]", mac2str(&peer->mac_addr).c_str(), ip2str(*(in_addr*)&ipaddr).c_str(), (const char*)&peer->nickname.data, peer->last_recv);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						getLocalMac(&mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						buf[discovered].mac_addr = mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:						DEBUG_LOG(Log::sceNet, "Peer [%s][%s][%s][%llu]", mac2str(&mac).c_str(), ip2str(addr.sin_addr).c_str(), nickName, lastrecv);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:							buf[discovered].mac_addr = peer->mac_addr;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.cpp:							DEBUG_LOG(Log::sceNet, "Peer [%s][%s][%s][%llu]", mac2str(&peer->mac_addr).c_str(), ip2str(*(in_addr*)&ipaddr).c_str(), (const char*)&peer->nickname.data, peer->last_recv);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.h:	SceNetEtherAddr* remoteMAC;
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.h:int sceNetAdhocPdpSend(int id, const char* mac, u32 port, void* data, int len, int timeout, int flag);
./platform_references_code.txt:./Core/HLE/sceNetAdhoc.h:int sceNetAdhocPdpCreate(const char* mac, int port, int bufferSize, u32 flag);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		memcpy(dataPtr, &msg->mac, sizeof(msg->mac));
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		//argsNew.data[2] = dataBufAddr; // FIXME: Is the MAC address mandatory (ie. can't be null pointer) even for EVENT_ERROR? Where should we put this MAC data in the case we failed to allocate the memory? may be on the memory pool?
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		auto it = (*context->peerPort).find(peer->mac_addr);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)&peer->mac_addr, port, &ping, (u32)sizeof(ping), 0, ADHOC_F_NONBLOCK);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		auto it = (*context->peerPort).find(peer->mac_addr);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)&peer->mac_addr, port, hello, 5 + context->hellolen, 0, ADHOC_F_NONBLOCK);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param mac Target Player MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void sendAcceptPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac, int optlen, void * opt) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		// Create MAC Array Pointer
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		uint8_t * siblingmacs = (uint8_t *)(accept + 9 + optlen);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		// MAC Writing Pointer
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			// Copy Child MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:				// Clone MAC the stupid memcpy way to shut up PSP CPU
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:				memcpy(siblingmacs + sizeof(SceNetEtherAddr) * i++, &item->mac, sizeof(SceNetEtherAddr));
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)mac, (*context->peerPort)[*mac], accept, 9 + optlen + siblingbuflen, 0, ADHOC_F_NONBLOCK);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_ESTABLISHED, mac, 0, NULL);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param mac Target Player MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void sendJoinPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac, int optlen, void * opt) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)mac, (*context->peerPort)[*mac], join, 5 + optlen, 0, ADHOC_F_NONBLOCK);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param mac Target Player MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void sendCancelPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac, int optlen, void * opt) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)mac, (*context->peerPort)[*mac], cancel, 5 + optlen, 0, ADHOC_F_NONBLOCK);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param mac Target Player MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void sendBulkDataPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac, int datalen, void * data) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)mac, (*context->peerPort)[*mac], send, 5 + datalen, 0, ADHOC_F_NONBLOCK);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_DATA_ACK, mac, 0, NULL);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param mac New Child's MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void sendBirthPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * newborn = findPeer(context, mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	// Set Newborn MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	memcpy(packet + 1, mac, sizeof(SceNetEtherAddr));
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		int sent = hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)&peer->mac, (*context->peerPort)[peer->mac], packet, (u32)sizeof(packet), 0, ADHOC_F_NONBLOCK);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			INFO_LOG(Log::sceNet, "InputLoop: Sending BIRTH [%s] to %s", mac2str(mac).c_str(), mac2str(&peer->mac).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			WARN_LOG(Log::sceNet, "InputLoop: Failed to Send BIRTH [%s] to %s", mac2str(mac).c_str(), mac2str(&peer->mac).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param mac Dead Child's MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void sendDeathPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * mac) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * deadkid = findPeer(context, mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	// Set abandoned Child MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	memcpy(packet + 1, mac, sizeof(SceNetEtherAddr));
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)&peer->mac, (*context->peerPort)[peer->mac], packet, (u32)sizeof(packet[0]), 0, ADHOC_F_NONBLOCK);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:				hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)&peer->mac, (*context->peerPort)[peer->mac], packet, (u32)sizeof(packet), 0, ADHOC_F_NONBLOCK);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			hleCall(sceNetAdhoc, int, sceNetAdhocPdpSend, context->socket, (const char*)&peer->mac, (*context->peerPort)[peer->mac], &opcode, (u32)sizeof(opcode), 0, ADHOC_F_NONBLOCK);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void actOnPingPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void actOnHelloPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac, int32_t length) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:				// Copy Sender MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:				peer->mac = *sendermac;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_HELLO, sendermac, optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void actOnJoinPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac, int32_t length) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:				SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						// Copy Sender MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						peer->mac = *sendermac;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_REQUEST, sendermac, optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_REQUEST, sendermac, optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	sendCancelPacket(context, sendermac, 0, NULL);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void actOnAcceptPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac, uint32_t length) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		// Sibling MAC Array Null Data
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		// Extract Optional Sibling MAC Array
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			addMember(context, &context->mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_ESTABLISHED, sendermac, 0, NULL);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_ACCEPT, sendermac, optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void actOnCancelPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac, int32_t length) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_DENY, sendermac, optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_LEAVE, &item->mac, optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_CANCEL, sendermac, optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_LEAVE, sendermac, optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_DENY, sendermac, optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_LEAVE, sendermac, optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_CANCEL, sendermac, optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void actOnBulkDataPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac, int32_t length) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:				spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_DATA, sendermac, datalen, data);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void actOnBirthPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac, uint32_t length) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	// Extract Child MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	memcpy(&mac, context->rxbuf + 1, sizeof(SceNetEtherAddr));
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	// Save MAC Address
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	sibling->mac = mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	//spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_ESTABLISHED, &sibling->mac, 0, NULL);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void actOnDeathPacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac, uint32_t length) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	// Extract Child MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetEtherAddr mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	memcpy(&mac, context->rxbuf + 1, sizeof(SceNetEtherAddr));
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * deadkid = findPeer(context, &mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_LEAVE, &mac, 0, NULL);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:* @param sendermac Packet Sender MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:void actOnByePacket(SceNetAdhocMatchingContext * context, SceNetEtherAddr * sendermac) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, sendermac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_BYE, sendermac, 0, NULL);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		spawnLocalEvent(context, PSP_ADHOC_MATCHING_EVENT_BYE, sendermac, 0, NULL);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					INFO_LOG(Log::sceNet, "EventLoop[%d]: Matching Event [%d=%s][%s] OptSize=%d", matchingId, msg->opcode, getMatchingEventStr(msg->opcode), mac2str(&msg->mac).c_str(), msg->optlen);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					//context->handler(context->id, msg->opcode, &msg->mac, msg->optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:				//context->handler(context->id, msg->opcode, &msg->mac, msg->optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	static SceNetEtherAddr sendermac;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_ACCEPT) sendAcceptPacket(context, &msg->mac, msg->optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_JOIN) sendJoinPacket(context, &msg->mac, msg->optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_CANCEL) sendCancelPacket(context, &msg->mac, msg->optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_BULK) sendBulkDataPacket(context, &msg->mac, msg->optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_BIRTH) sendBirthPacket(context, &msg->mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_DEATH) sendDeathPacket(context, &msg->mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						//else if(msg->opcode == PSP_ADHOC_MATCHING_PACKET_BULK_ABORT) sendAbortBulkDataPacket(context, &msg->mac, msg->optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:				int recvresult = sceNetAdhocPdpRecv(context->socket, &sendermac, &senderport, context->rxbuf, &rxbuflen, 0, ADHOC_F_NONBLOCK);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					SceNetAdhocctlPeerInfo* peer = findFriend(&sendermac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						DEBUG_LOG(Log::sceNet, "Timestamp LastRecv Delta: %lld (%llu - %llu) from %s", delta, now, peer->last_recv, mac2str(&sendermac).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						WARN_LOG(Log::sceNet, "InputLoop[%d]: Unknown Peer[%s:%u] (Recved=%i, Length=%i)", matchingId, mac2str(&sendermac).c_str(), senderport, recvresult, rxbuflen);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					if (context->port != senderport && senderport != (*context->peerPort)[sendermac]) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						WARN_LOG(Log::sceNet, "InputLoop[%d]: Unknown Source Port from [%s][%s:%u -> %u] (Recved=%i, Length=%i)", matchingId, name, mac2str(&sendermac).c_str(), senderport, context->port, recvresult, rxbuflen);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					(*context->peerPort)[sendermac] = senderport;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_PING) actOnPingPacket(context, &sendermac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_HELLO) actOnHelloPacket(context, &sendermac, rxbuflen);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_JOIN) actOnJoinPacket(context, &sendermac, rxbuflen);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_ACCEPT) actOnAcceptPacket(context, &sendermac, rxbuflen);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_CANCEL) actOnCancelPacket(context, &sendermac, rxbuflen);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_BULK) actOnBulkDataPacket(context, &sendermac, rxbuflen);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					//else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_BULK_ABORT) actOnAbortBulkDataPacket(context, &sendermac, rxbuflen);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_BIRTH) actOnBirthPacket(context, &sendermac, rxbuflen);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_DEATH) actOnDeathPacket(context, &sendermac, rxbuflen);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					else if (context->rxbuf[0] == PSP_ADHOC_MATCHING_PACKET_BYE) actOnByePacket(context, &sendermac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_ACCEPT) sendAcceptPacket(context, &msg->mac, msg->optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_JOIN) sendJoinPacket(context, &msg->mac, msg->optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_CANCEL) sendCancelPacket(context, &msg->mac, msg->optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_BULK) sendBulkDataPacket(context, &msg->mac, msg->optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_BIRTH) sendBirthPacket(context, &msg->mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					else if (msg->opcode == PSP_ADHOC_MATCHING_PACKET_DEATH) sendDeathPacket(context, &msg->mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:					//else if(msg->opcode == PSP_ADHOC_MATCHING_PACKET_BULK_ABORT) sendAbortBulkDataPacket(context, &msg->mac, msg->optlen, opt);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	// Remove your own MAC, or All members, or don't remove at all or we should do this on MatchingDelete ?
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		SceNetEtherAddr localmac;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:		getLocalMac(&localmac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			context->mac = localmac;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	int sock = hleCall(sceNetAdhoc, int, sceNetAdhocPdpCreate, (const char*)&item->mac, static_cast<int>(item->port), item->rxbuflen, 0);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:static int sceNetAdhocMatchingSelectTarget(int matchingId, const char *macAddress, int optLen, u32 optDataPtr) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	WARN_LOG(Log::sceNet, "UNTESTED sceNetAdhocMatchingSelectTarget(%i, %s, %i, %08x) at %08x", matchingId, mac2str((SceNetEtherAddr*)macAddress).c_str(), optLen, optDataPtr, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	if (macAddress == NULL) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetEtherAddr * target = (SceNetEtherAddr *)macAddress;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:int NetAdhocMatching_CancelTargetWithOpt(int matchingId, const char* macAddress, int optLen, u32 optDataPtr) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetEtherAddr* target = (SceNetEtherAddr*)macAddress;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:int sceNetAdhocMatchingCancelTargetWithOpt(int matchingId, const char *macAddress, int optLen, u32 optDataPtr) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	WARN_LOG(Log::sceNet, "UNTESTED sceNetAdhocMatchingCancelTargetWithOpt(%i, %s, %i, %08x) at %08x", matchingId, mac2str((SceNetEtherAddr*)macAddress).c_str(), optLen, optDataPtr, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	return NetAdhocMatching_CancelTargetWithOpt(matchingId, macAddress, optLen, optDataPtr);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:int sceNetAdhocMatchingCancelTarget(int matchingId, const char *macAddress) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	WARN_LOG(Log::sceNet, "UNTESTED sceNetAdhocMatchingCancelTarget(%i, %s)", matchingId, mac2str((SceNetEtherAddr*)macAddress).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	return NetAdhocMatching_CancelTargetWithOpt(matchingId, macAddress, 0, 0);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:				// Add Local MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:				buf2[filledpeers++].mac_addr = context->mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:				DEBUG_LOG(Log::sceNet, "MemberSelf [%s]", mac2str(&context->mac).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						auto friendpeer = findFriend(&p2p->mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						// Add P2P Brother MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						buf2[filledpeers++].mac_addr = p2p->mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						DEBUG_LOG(Log::sceNet, "MemberP2P [%s]", mac2str(&p2p->mac).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						auto friendpeer = findFriend(&parentpeer->mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						// Add Parent MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						buf2[filledpeers++].mac_addr = parentpeer->mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:						DEBUG_LOG(Log::sceNet, "MemberParent [%s]", mac2str(&parentpeer->mac).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:							auto friendpeer = findFriend(&peer->mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:							// Add Peer MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:								// Add Child MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:								buf2[filledpeers++].mac_addr = peer->mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:								DEBUG_LOG(Log::sceNet, "MemberChild [%s]", mac2str(&peer->mac).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:								// Add Peer MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:								buf2[filledpeers++].mac_addr = peer->mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:								DEBUG_LOG(Log::sceNet, "MemberSibling [%s]", mac2str(&peer->mac).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:								// Add Local MAC
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:								buf2[filledpeers++].mac_addr = peer->mac;
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:								DEBUG_LOG(Log::sceNet, "MemberSelf [%s]", mac2str(&peer->mac).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:// Gran Turismo may replace the 1st bit of the 1st byte of MAC address's OUI with 0 (unicast bit), or replace the whole 6-bytes of MAC address with all 00 (invalid mac) for unknown reason
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:int sceNetAdhocMatchingSendData(int matchingId, const char *mac, int dataLen, u32 dataAddr) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	WARN_LOG(Log::sceNet, "UNTESTED sceNetAdhocMatchingSendData(%i, %s, %i, %08x) at %08x", matchingId, mac2str((SceNetEtherAddr*)mac).c_str(), dataLen, dataAddr, currentMIPS->pc);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	if (mac == NULL) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal* peer = findPeer(context, (SceNetEtherAddr*)mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	sendBulkDataPacket(context, &peer->mac, dataLen, data);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:int sceNetAdhocMatchingAbortSendData(int matchingId, const char *mac) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	WARN_LOG(Log::sceNet, "UNTESTED sceNetAdhocMatchingAbortSendData(%i, %s)", matchingId, mac2str((SceNetEtherAddr*)mac).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	if (mac == NULL) {
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:	SceNetAdhocMatchingMemberInternal * peer = findPeer(context, (SceNetEtherAddr *)mac);
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			DEBUG_LOG(Log::sceNet, "AdhocMatchingCallback: [ID=%i][EVENT=%i][%s]", args[0], args[1], mac2str((SceNetEtherAddr *)Memory::GetPointer(args[2])).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.cpp:			DEBUG_LOG(Log::sceNet, "AdhocMatching - Discarding Callback: [ID=%i][EVENT=%i][%s]", args[0], args[1], mac2str((SceNetEtherAddr*)Memory::GetPointer(args[2])).c_str());
./platform_references_code.txt:./Core/HLE/sceNetAdhocMatching.h:	u32_le data[6]; // ContextID, EventID, bufAddr[ to MAC], OptLen, OptAddr[, EntryPoint]
./platform_references_code.txt:./Core/HLE/sceNetInet.cpp:				FD_SET(sock, &rdfds); // This might pointed to a non-existing socket or sockets belonged to other programs on Windows, because most of the time Windows socket have an id above 1k instead of 0-255
./platform_references_code.txt:./Core/HLE/sceNetInet.cpp:	// Ignore SIGPIPE when supported (ie. BSD/MacOS)
./platform_references_code.txt:./Core/HLE/sceNetInet.cpp:	// FIXME: On non-Windows broadcast to INADDR_BROADCAST(255.255.255.255) might not be received by the sender itself when binded to specific IP (ie. 192.168.0.2) or INADDR_BROADCAST.
./platform_references_code.txt:./Core/HLE/sceNetInet.cpp:	// Discard if it came from APIPA address (ie. self-received broadcasts from 169.254.x.x when broadcasting to INADDR_BROADCAST on Windows) on Untold Legends The Warrior's Code / Twisted Metal Head On
./platform_references_code.txt:./Core/HLE/sceNetInet.cpp:		// FIXME: On non-Windows(including PSP too?) broadcast to INADDR_BROADCAST(255.255.255.255) might not be received by the sender itself when binded to specific IP (ie. 192.168.0.2) or INADDR_BROADCAST.
./platform_references_code.txt:./Core/HLE/sceNetInet.cpp:			// Replace Limited Broadcast(255.255.255.255) with Direct Broadcast(ie. 192.168.0.255) for accurate targetting when there are multiple interfaces, to avoid receiving it's own broadcasted data through IP 169.254.x.x on Windows (which is not recognized as it's own IP by the game)
./platform_references_code.txt:./Core/HLE/sceNetInet.cpp:			// TODO: Creates our own CMSG_* macros (32-bit version of it, similar to the one on PSP) to avoid alignment/size issue that can lead to memory corruption/out of bound issue.
./platform_references_code.txt:./Core/HLE/sceNetInet.cpp:		// FIXME: On non-Windows(including PSP too?) broadcast to INADDR_BROADCAST(255.255.255.255) might not be received by the sender itself when binded to specific IP (ie. 192.168.0.2) or INADDR_BROADCAST.
./platform_references_code.txt:./Core/HLE/sceNetInet.cpp:			// Replace Limited Broadcast(255.255.255.255) with Direct Broadcast(ie. 192.168.0.255) for accurate targetting when there are multiple interfaces, to avoid receiving it's own broadcasted data through IP 169.254.x.x on Windows (which is not recognized as it's own IP by the game)
./platform_references_code.txt:./Core/HLE/sceNetInet.h:#define		PSP_NET_INET_FD_SETSIZE		256		// PSP can support upto 256 fd(s) while the default FD_SETSIZE on Windows is only 64 
./platform_references_code.txt:./Core/HLE/sceNetInet.h:	s32_le nonblocking; // non-blocking flag (ie. FIONBIO) to keep track of the blocking mode since Windows doesn't have getter for this
./platform_references_code.txt:./Core/HLE/sceNetResolver.cpp:#if __linux__ || __APPLE__ || defined(__OpenBSD__)
./platform_references_code.txt:./Core/HLE/sceNetResolver.cpp:#include <iostream>
./platform_references_code.txt:./Core/HLE/sceOpenPSID.cpp:	getLocalMac((SceNetEtherAddr*)&dummyOpenPSID);
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:static const int audioSamples = 2048;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:static const int audioSamplesBytes = audioSamples * 4;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	s32_le audioStreamNum;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	s32_le numAudioStreams;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	int audioStreamNum;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	int totalAudioStreams;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	void readPrivateAudioStreamParams(const u8 *addr, Psmf *psmf) {
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:			stream->readPrivateAudioStreamParams(currentStreamAddr, this);
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	audioStreamNum = -1;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	Do(p, audioStreamNum);
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:		Do(p, totalAudioStreams);
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:		totalAudioStreams = 1;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	psmfplayer->totalAudioStreams = 0;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:			++psmfplayer->totalAudioStreams;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	return hleLogWarning(Log::ME, audioSamplesBytes);
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	if (psmfplayer->totalAudioStreams > 0) {
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:		if (playerData->audioStreamNum >= psmfplayer->totalAudioStreams) {
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:			ERROR_LOG_REPORT(Log::ME, "scePsmfPlayerStart(%08x, %08x, %d): unable to change audio stream to %d", psmfPlayer, psmfPlayerData, initPts, playerData->audioStreamNum);
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	if (psmfplayer->totalAudioStreams > 0) {
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:		psmfplayer->mediaengine->setAudioStream(playerData->audioStreamNum);
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:		psmfplayer->audioStreamNum = playerData->audioStreamNum;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	if (psmfplayer->mediaengine->getAudioSamples(audioDataAddr) == 0) {
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:		if (psmfplayer->totalAudioStreams > 0 && (s64)psmfplayer->psmfPlayerAvcAu.pts < (s64)psmfplayer->totalDurationTimestamp - VIDEO_FRAME_DURATION_TS) {
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:			Memory::Memset(audioDataAddr, 0, audioSamplesBytes, "PsmfAudioClear");
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	info->numAudioStreams = psmfplayer->totalAudioStreams;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:static u32 scePsmfPlayerGetCurrentAudioStream(u32 psmfPlayer, u32 audioCodecAddr, u32 audioStreamNumAddr)
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	if (Memory::IsValidAddress(audioStreamNumAddr)) {
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:		Memory::WriteUnchecked_U32(psmfplayer->audioStreamNum, audioStreamNumAddr);
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	int next = psmfplayer->audioStreamNum + 1;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	if (next >= psmfplayer->totalAudioStreams)
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	if (next == psmfplayer->audioStreamNum || !psmfplayer->mediaengine->setAudioStream(next)) {
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	psmfplayer->audioStreamNum = next;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:static u32 scePsmfPlayerSelectSpecificAudio(u32 psmfPlayer, int audioCodec, int audioStreamNum)
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	if (psmfplayer->totalAudioStreams < 2) {
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	if (audioStreamNum < 0 || audioStreamNum >= psmfplayer->totalAudioStreams) {
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	if (psmfplayer->totalAudioStreams < 2 || !psmfplayer->mediaengine->setAudioStream(audioStreamNum)) {
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	if (psmfplayer->audioStreamNum != audioStreamNum) {
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	psmfplayer->audioStreamNum = audioStreamNum;
./platform_references_code.txt:./Core/HLE/scePsmf.cpp:	{0X68F07175, &WrapU_UUU<scePsmfPlayerGetCurrentAudioStream>,       "scePsmfPlayerGetCurrentAudioStream",       'x', "xxx"},
./platform_references_code.txt:./Core/HLE/sceRtc.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:#include "Windows/CaptureDevice.h"
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:#elif PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:#elif PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:	return __mac_getDeviceList();
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:	#elif defined(USING_QT_UI) // Qt:macOS / Qt:Linux
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:		return __qt_getDeviceList();
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:	#elif PPSSPP_PLATFORM(LINUX) // SDL:Linux
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:				winCamera = new WindowsCaptureDevice(CAPTUREDEVIDE_TYPE::VIDEO);
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:	#elif PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(IOS) || defined(USING_QT_UI)
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:#elif PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:	__mac_startCapture(width, height);
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:	#elif PPSSPP_PLATFORM(LINUX)
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:#elif PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(IOS) || defined(USING_QT_UI)
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:#elif PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:		__mac_stopCapture();
./platform_references_code.txt:./Core/HLE/sceUsbCam.cpp:	#elif PPSSPP_PLATFORM(LINUX)
./platform_references_code.txt:./Core/HLE/sceUsbMic.cpp:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./platform_references_code.txt:./Core/HLE/sceUsbMic.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/HLE/sceUsbMic.cpp:#include "Windows/CaptureDevice.h"
./platform_references_code.txt:./Core/HLE/sceUtility.cpp:	// The windows aren't this regular, but close.
./platform_references_code.txt:./Core/HLE/sceVaudio.cpp:	__AudioSetSRCFrequency(freq);
./platform_references_code.txt:./Core/HLE/sceVaudio.cpp:static u32 sceVaudioSetEffectType(int effectType, int vol) {
./platform_references_code.txt:./Core/HLE/sceVaudio.cpp:	ERROR_LOG_REPORT(Log::sceAudio, "UNIMPL sceVaudioSetEffectType(%i, %i)", effectType, vol);
./platform_references_code.txt:./Core/HLE/sceVaudio.cpp:static u32 sceVaudioSetAlcMode(int alcMode) {
./platform_references_code.txt:./Core/HLE/sceVaudio.cpp:	ERROR_LOG_REPORT(Log::sceAudio, "UNIMPL sceVaudioSetAlcMode(%i)", alcMode);
./platform_references_code.txt:./Core/HLE/sceVaudio.cpp:	{0X346FBE94, &WrapU_II<sceVaudioSetEffectType>,  "sceVaudioSetEffectType",      'x', "ii" },
./platform_references_code.txt:./Core/HLE/sceVaudio.cpp:	{0XCBD4AC51, &WrapU_I<sceVaudioSetAlcMode>,      "sceVaudioSetAlcMode",         'x', "i"  },
./platform_references_code.txt:./Core/HW/Atrac3Standalone.cpp:			// We delay the codecOpen until the first decode, so the setChannels call from MediaEngine::getAudioSamples
./platform_references_code.txt:./Core/HW/Atrac3Standalone.cpp:		// We just call the decode function directly without going through the whole packet machinery.
./platform_references_code.txt:./Core/HW/Camera.cpp:#if defined(USING_QT_UI)
./platform_references_code.txt:./Core/HW/Camera.cpp:std::vector<std::string> __qt_getDeviceList() {
./platform_references_code.txt:./Core/HW/Camera.cpp:				qtc_ideal_width, qtc_ideal_height, &jpegData, &jpegLen);
./platform_references_code.txt:./Core/HW/Camera.cpp:				qtc_ideal_width, qtc_ideal_height, &jpegData, &jpegLen);
./platform_references_code.txt:./Core/HW/Camera.cpp:int __qt_startCapture(int width, int height) {
./platform_references_code.txt:./Core/HW/Camera.cpp:	if (qt_camera != nullptr) {
./platform_references_code.txt:./Core/HW/Camera.cpp:		delete qt_camera;
./platform_references_code.txt:./Core/HW/Camera.cpp:		qt_camera = nullptr;
./platform_references_code.txt:./Core/HW/Camera.cpp:			qt_camera = new QCamera(cameraInfo);
./platform_references_code.txt:./Core/HW/Camera.cpp:	if (qt_camera == nullptr) {
./platform_references_code.txt:./Core/HW/Camera.cpp:		qt_camera = new QCamera();
./platform_references_code.txt:./Core/HW/Camera.cpp:		if (qt_camera == nullptr) {
./platform_references_code.txt:./Core/HW/Camera.cpp:	qtc_ideal_width = width;
./platform_references_code.txt:./Core/HW/Camera.cpp:	qtc_ideal_height = height;
./platform_references_code.txt:./Core/HW/Camera.cpp:	qt_viewfinder = new MyViewfinder;
./platform_references_code.txt:./Core/HW/Camera.cpp:	QCameraViewfinderSettings viewfinderSettings = qt_camera->viewfinderSettings();
./platform_references_code.txt:./Core/HW/Camera.cpp:	qt_camera->setViewfinderSettings(viewfinderSettings);
./platform_references_code.txt:./Core/HW/Camera.cpp:	qt_camera->setViewfinder(qt_viewfinder);
./platform_references_code.txt:./Core/HW/Camera.cpp:	qt_camera->start();
./platform_references_code.txt:./Core/HW/Camera.cpp:int __qt_stopCapture() {
./platform_references_code.txt:./Core/HW/Camera.cpp:	if (qt_camera != nullptr) {
./platform_references_code.txt:./Core/HW/Camera.cpp:		qt_camera->stop();
./platform_references_code.txt:./Core/HW/Camera.cpp:		qt_camera->unload();
./platform_references_code.txt:./Core/HW/Camera.cpp:		delete qt_camera;
./platform_references_code.txt:./Core/HW/Camera.cpp:		delete qt_viewfinder;
./platform_references_code.txt:./Core/HW/Camera.cpp:		qt_camera = nullptr;
./platform_references_code.txt:./Core/HW/Camera.cpp://endif defined(USING_QT_UI)
./platform_references_code.txt:./Core/HW/Camera.cpp:#elif PPSSPP_PLATFORM(LINUX) && !PPSSPP_PLATFORM(ANDROID)
./platform_references_code.txt:./Core/HW/Camera.cpp:#endif // PPSSPP_PLATFORM(LINUX) && !PPSSPP_PLATFORM(ANDROID)
./platform_references_code.txt:./Core/HW/Camera.h:#if defined(USING_QT_UI)
./platform_references_code.txt:./Core/HW/Camera.h:	static int        qtc_ideal_width;
./platform_references_code.txt:./Core/HW/Camera.h:	static int        qtc_ideal_height;
./platform_references_code.txt:./Core/HW/Camera.h:	static QCamera *qt_camera;
./platform_references_code.txt:./Core/HW/Camera.h:	static QAbstractVideoSurface *qt_viewfinder;
./platform_references_code.txt:./Core/HW/Camera.h:	std::vector<std::string> __qt_getDeviceList();
./platform_references_code.txt:./Core/HW/Camera.h:	int __qt_startCapture(int width, int height);
./platform_references_code.txt:./Core/HW/Camera.h:	int __qt_stopCapture();
./platform_references_code.txt:./Core/HW/Camera.h:#elif PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./Core/HW/Camera.h:std::vector<std::string> __mac_getDeviceList();
./platform_references_code.txt:./Core/HW/Camera.h:int __mac_startCapture(int width, int height);
./platform_references_code.txt:./Core/HW/Camera.h:int __mac_stopCapture();
./platform_references_code.txt:./Core/HW/Camera.h:#elif PPSSPP_PLATFORM(LINUX) && !PPSSPP_PLATFORM(ANDROID)
./platform_references_code.txt:./Core/HW/Camera.h:#include <linux/videodev2.h>
./platform_references_code.txt:./Core/HW/MediaEngine.cpp:	Do(p, m_audioStream);
./platform_references_code.txt:./Core/HW/MediaEngine.cpp:	m_demux->demux(m_audioStream);
./platform_references_code.txt:./Core/HW/MediaEngine.cpp:int MediaEngine::getAudioSamples(u32 bufferPtr) {
./platform_references_code.txt:./Core/HW/MediaEngine.cpp:	m_demux->demux(m_audioStream);
./platform_references_code.txt:./Core/HW/MediaEngine.h:	bool setAudioStream(int streamNum) { m_audioStream = streamNum; return true; }
./platform_references_code.txt:./Core/HW/MediaEngine.h:	int getAudioSamples(u32 bufferPtr);
./platform_references_code.txt:./Core/HW/MediaEngine.h:	int m_audioStream = -1;
./platform_references_code.txt:./Core/HW/MpegDemux.cpp:MpegDemux::MpegDemux(int size, int offset) : m_audioStream(size) {
./platform_references_code.txt:./Core/HW/MpegDemux.cpp:	DoClass(p, m_audioStream);
./platform_references_code.txt:./Core/HW/MpegDemux.cpp:			m_audioStream.push(m_buf + m_index, length, pesHeader.pts);
./platform_references_code.txt:./Core/HW/MpegDemux.cpp:static bool isHeader(const u8 *audioStream, int offset)
./platform_references_code.txt:./Core/HW/MpegDemux.cpp:	return (audioStream[offset] == header1) && (audioStream[offset+1] == header2);
./platform_references_code.txt:./Core/HW/MpegDemux.cpp:static int getNextHeaderPosition(u8* audioStream, int curpos, int limit, int frameSize)
./platform_references_code.txt:./Core/HW/MpegDemux.cpp:	if (offset < endScan && isHeader(audioStream, offset))
./platform_references_code.txt:./Core/HW/MpegDemux.cpp:		if (isHeader(audioStream, scan))
./platform_references_code.txt:./Core/HW/MpegDemux.cpp:	m_audioStream.pop_front(0, audioPos, pts);
./platform_references_code.txt:./Core/HW/MpegDemux.cpp:	int gotsize = m_audioStream.get_front(m_audioFrame, 0x2000);
./platform_references_code.txt:./Core/HW/MpegDemux.h:	BufferQueue m_audioStream;
./platform_references_code.txt:./Core/HW/SimpleAudioDec.h:	// NOTE: This can come late (MediaEngine::getAudioSample)! But it will come before the first Decode.
./platform_references_code.txt:./Core/Instance.cpp:#if !PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(ANDROID) && !defined(__LIBRETRO__) && !PPSSPP_PLATFORM(SWITCH)
./platform_references_code.txt:./Core/Instance.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/Instance.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/Instance.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/Instance.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/Instance.cpp:#elif PPSSPP_PLATFORM(ANDROID) || defined(__LIBRETRO__) || PPSSPP_PLATFORM(SWITCH)
./platform_references_code.txt:./Core/Instance.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/Instance.cpp:#elif PPSSPP_PLATFORM(ANDROID) || defined(__LIBRETRO__) || PPSSPP_PLATFORM(SWITCH)
./platform_references_code.txt:./Core/Instance.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/Instance.cpp:#elif PPSSPP_PLATFORM(ANDROID) || defined(__LIBRETRO__) || PPSSPP_PLATFORM(SWITCH)
./platform_references_code.txt:./Core/KeyMap.cpp:	{NKCODE_WINDOW, "Windows"},
./platform_references_code.txt:./Core/KeyMap.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/KeyMap.cpp:#elif PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Core/KeyMap.cpp:	SetDefaultKeyMap(DEFAULT_MAPPING_IOS_PAD, false);
./platform_references_code.txt:./Core/KeyMap.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/KeyMapDefaults.cpp:static const DefMappingStruct defaultPadMapIOS[] = {
./platform_references_code.txt:./Core/KeyMapDefaults.cpp:	case DEFAULT_MAPPING_IOS_PAD:
./platform_references_code.txt:./Core/KeyMapDefaults.cpp:		SetDefaultKeyMap(DEVICE_ID_PAD_0, defaultPadMapIOS, ARRAY_SIZE(defaultPadMapIOS), replace);
./platform_references_code.txt:./Core/KeyMapDefaults.h:	DEFAULT_MAPPING_IOS_PAD,
./platform_references_code.txt:./Core/Loaders.cpp:		// Ignore macos metadata stuff
./platform_references_code.txt:./Core/Loaders.cpp:		if (startsWith(zippedName, "__macosx/")) {
./platform_references_code.txt:./Core/MIPS/ARM/ArmAsm.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Core/MIPS/ARM/ArmAsm.cpp:				// On iOS, R9 (JITBASEREG) is volatile.  We have to reload it.
./platform_references_code.txt:./Core/MIPS/ARM/ArmJit.cpp:	// TODO: Not used by anything yet (except the modified VerySleepy on Windows)
./platform_references_code.txt:./Core/MIPS/ARM/ArmRegCacheFPU.cpp:	qTime_++;
./platform_references_code.txt:./Core/MIPS/ARM/ArmRegCacheFPU.h:	int qTime_;
./platform_references_code.txt:./Core/MIPS/ARM64/Arm64Asm.cpp:// Apple: https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Articles/ARM64FunctionCallingConventions.html
./platform_references_code.txt:./Core/MIPS/ARM64/Arm64Asm.cpp:// x18: unavailable (reserved for use by the OS or linker or whatever - iOS, for example, uses it)
./platform_references_code.txt:./Core/MIPS/ARM64/Arm64IRAsm.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./platform_references_code.txt:./Core/MIPS/ARM64/Arm64IRCompALU.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./platform_references_code.txt:./Core/MIPS/ARM64/Arm64IRCompBranch.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./platform_references_code.txt:./Core/MIPS/ARM64/Arm64IRCompFPU.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./platform_references_code.txt:./Core/MIPS/ARM64/Arm64IRCompLoadStore.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./platform_references_code.txt:./Core/MIPS/ARM64/Arm64IRCompSystem.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./platform_references_code.txt:./Core/MIPS/ARM64/Arm64IRCompVec.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./platform_references_code.txt:./Core/MIPS/ARM64/Arm64IRJit.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./platform_references_code.txt:./Core/MIPS/ARM64/Arm64IRJit.h:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./platform_references_code.txt:./Core/MIPS/ARM64/Arm64IRRegCache.cpp:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./platform_references_code.txt:./Core/MIPS/ARM64/Arm64IRRegCache.h:#if PPSSPP_ARCH(ARM64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./platform_references_code.txt:./Core/MIPS/IR/IRInst.h:// But this gets rid of a lot of MIPS idiosyncrasies that makes it tricky, like
./platform_references_code.txt:./Core/MIPS/IR/IRInterpreter.cpp:#if PPSSPP_PLATFORM(WINDOWS) && PPSSPP_ARCH(ARM64)
./platform_references_code.txt:./Core/MIPS/IR/IRInterpreter.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/MIPS/IR/IRInterpreter.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/MIPS/JitCommon/JitBlockCache.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/MIPS/JitCommon/JitCommon.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__)
./platform_references_code.txt:./Core/MIPS/JitCommon/JitState.cpp:		// iOS/etc. may disable at runtime if Memory::base is not nicely aligned.
./platform_references_code.txt:./Core/MIPS/MIPSAnalyst.cpp:#if !PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Core/MIPS/MIPSInt.cpp:			// Will cause garbage on the real machine so we just ignore it, the app will overwrite the cacheline.
./platform_references_code.txt:./Core/MIPS/MIPSVFPUFallbacks.cpp:// Was measured to be around 0x68, but GTA on Mac is somehow super sensitive
./platform_references_code.txt:./Core/MIPS/MIPSVFPUFallbacks.cpp:#if defined(__linux__)
./platform_references_code.txt:./Core/MIPS/RiscV/RiscVJit.cpp:#if PPSSPP_ARCH(RISCV64) || (PPSSPP_PLATFORM(WINDOWS) && !defined(__LIBRETRO__))
./platform_references_code.txt:./Core/MIPS/x86/CompVFPU.cpp:		mask_nosign_arg = MAccessibleDisp(TEMPREG, &mask_nosign[0], &mask_nosign[0]);
./platform_references_code.txt:./Core/MIPS/x86/CompVFPU.cpp:		nan_mantissa_arg = MAccessibleDisp(TEMPREG, &mask_nosign[0], &nan_mantissa[0]);
./platform_references_code.txt:./Core/MIPS/x86/CompVFPU.cpp:		magic_arg = MAccessibleDisp(TEMPREG, &mask_nosign[0], &magic[0]);
./platform_references_code.txt:./Core/MIPS/x86/CompVFPU.cpp:		was_infnan_arg = MAccessibleDisp(TEMPREG, &mask_nosign[0], &was_infnan[0]);
./platform_references_code.txt:./Core/MIPS/x86/CompVFPU.cpp:		exp_infnan_arg = MAccessibleDisp(TEMPREG, &mask_nosign[0], &exp_infnan[0]);
./platform_references_code.txt:./Core/MIPS/x86/CompVFPU.cpp:		// TODO: This reg might be different on Linux...
./platform_references_code.txt:./Core/MIPS/x86/JitSafeMem.cpp:	if (!g_Config.bIgnoreBadMemAccess) {
./platform_references_code.txt:./Core/MIPS/x86/JitSafeMem.cpp:		if (!g_Config.bIgnoreBadMemAccess) {
./platform_references_code.txt:./Core/MIPS/x86/JitSafeMem.cpp:	if (!g_Config.bIgnoreBadMemAccess) {
./platform_references_code.txt:./Core/MIPS/x86/JitSafeMem.cpp:	if (needsCheck_ && !g_Config.bIgnoreBadMemAccess)
./platform_references_code.txt:./Core/MIPS/x86/X64IRJit.h:#if PPSSPP_PLATFORM(WINDOWS) && (defined(_MSC_VER) || defined(__clang__) || defined(__INTEL_COMPILER))
./platform_references_code.txt:./Core/MemFault.cpp:#include "Common/MachineContext.h"
./platform_references_code.txt:./Core/MemFault.cpp:#ifdef MACHINE_CONTEXT_SUPPORTED
./platform_references_code.txt:./Core/MemFault.cpp:#if PPSSPP_ARCH(AMD64) && PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./Core/MemFault.cpp:	if (success && (g_Config.bIgnoreBadMemAccess || g_ignoredAddresses.find(codePtr) != g_ignoredAddresses.end())) {
./platform_references_code.txt:./Core/MemFault.cpp:		// Either bIgnoreBadMemAccess is off, or we failed recovery analysis.
./platform_references_code.txt:./Core/MemMap.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/MemMap.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/MemMap.cpp:#if PPSSPP_PLATFORM(IOS) && PPSSPP_ARCH(64BIT)
./platform_references_code.txt:./Core/MemMap.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/MemMap.cpp:#if PPSSPP_PLATFORM(WINDOWS) && PPSSPP_ARCH(32BIT)
./platform_references_code.txt:./Core/MemMap.cpp:#elif PPSSPP_ARCH(ARM64) && PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Core/MemMap.cpp:		// iOS
./platform_references_code.txt:./Core/MemMap.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/MemMap.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/MemMap.cpp:	// On some 32 bit platforms (like Android, iOS, etc.), you can only map < 32 megs at a time.
./platform_references_code.txt:./Core/MemMap.h:// UWP has such limited memory management that we need to mask
./platform_references_code.txt:./Core/MemMap.h:#if PPSSPP_ARCH(32BIT) || PPSSPP_PLATFORM(UWP) || USE_ASAN || PPSSPP_PLATFORM(IOS) || defined(__EMSCRIPTEN__)
./platform_references_code.txt:./Core/PSPLoaders.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/Reporting.cpp:		return "Windows ARM64";
./platform_references_code.txt:./Core/Reporting.cpp:		return "Windows 64";
./platform_references_code.txt:./Core/Reporting.cpp:		return "Windows ARM32";
./platform_references_code.txt:./Core/Reporting.cpp:		return "Windows";
./platform_references_code.txt:./Core/Reporting.cpp:#elif PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Core/Reporting.cpp:		return "iOS";
./platform_references_code.txt:./Core/Reporting.cpp:		return "Mac";
./platform_references_code.txt:./Core/Reporting.cpp:#elif defined(__linux__)
./platform_references_code.txt:./Core/Reporting.cpp:		return "Linux";
./platform_references_code.txt:./Core/RetroAchievements.cpp:#include "Windows/MainWindow.h"
./platform_references_code.txt:./Core/Screenshot.cpp:// Technically only needed on Windows.
./platform_references_code.txt:./Core/System.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/System.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/System.cpp:#include "Windows/W32Util/ShellUtil.h"
./platform_references_code.txt:./Core/System.cpp:#ifndef __LIBRETRO__
./platform_references_code.txt:./Core/System.cpp:#ifdef __LIBRETRO__
./platform_references_code.txt:./Core/System.cpp:// while repeatedly calling PSP_InitUpdate. This is basically just for libretro convenience.
./platform_references_code.txt:./Core/System.cpp:	// Reduce the risk for weird races with the Windows GE debugger.
./platform_references_code.txt:./Core/TiltEventProcessor.cpp:	const double oldPollInterval = 1.0 / 250.0;  // See Windows "PollControllers".
./platform_references_code.txt:./Core/Util/GameManager.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./Core/Util/MemStick.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/Util/MemStick.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./Core/Util/PPGeDraw.cpp:	// Should we pass a draw_? Yes! UWP requires it.
./platform_references_code.txt:./Core/Util/PPGeDraw.cpp:	// If the atlas is larger than 512x512, need to use windows into it.
./platform_references_code.txt:./Core/Util/PathUtil.cpp:// On iOS, the path to the app documents directory changes on each launch.
./platform_references_code.txt:./Core/Util/PathUtil.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./Core/Util/PathUtil.cpp:#if !PPSSPP_PLATFORM(ANDROID) && (PPSSPP_PLATFORM(LINUX) || PPSSPP_PLATFORM(MAC))
./platform_references_code.txt:./Core/Util/PortManager.cpp:	// FIXME: On Windows it seems using any UPnP functions in this destructor that gets triggered when exiting PPSSPP will resulting to UPNPCOMMAND_HTTP_ERROR due to early WSACleanup (miniupnpc was getting WSANOTINITIALISED internally)
./platform_references_code.txt:./Core/Util/PortManager.cpp:	// Windows: Assuming WSAStartup already called beforehand
./platform_references_code.txt:./Core/Util/RecentFiles.cpp:				// iOS only stuff
./platform_references_code.txt:./Core/WaveFile.h:	uint32_t GetAudioSize() const { return audio_size; }
./platform_references_code.txt:./Core/WebServer.cpp:		// First reject backslashes, in case of any Windows shenanigans.
./platform_references_code.txt:./Dockerfile:RUN apk add build-base wget git bash cmake python3 glu-dev sdl2-dev
./platform_references_code.txt:./Dockerfile:RUN cd src/ffmpeg && ./linux_x86-64.sh
./platform_references_code.txt:./Dockerfile:RUN apk add --no-cache sdl2 libstdc++ glu-dev
./platform_references_code.txt:./GPU/Common/DepalettizeShaderCommon.cpp:		// TODO: I think we can handle most scenarios here, but texturing from depth buffers requires an extension on ES 2.0 anyway.
./platform_references_code.txt:./GPU/Common/SoftwareTransformCommon.h:enum SoftwareTransformAction {
./platform_references_code.txt:./GPU/Common/SoftwareTransformCommon.h:	SoftwareTransformAction action;
./platform_references_code.txt:./GPU/Common/TextureCacheCommon.cpp:		// Do the computation in bytes so that it's valid even in case of weird reinterpret scenarios.
./platform_references_code.txt:./GPU/Common/TextureCacheCommon.h:// Texture replacement state machine:
./platform_references_code.txt:./GPU/Common/TextureDecoder.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_ARCH(ARM64) || defined(_MSC_VER) || !PPSSPP_ARCH(ARMV7)
./platform_references_code.txt:./GPU/Common/TextureDecoder.cpp:		// TODO: Why does this crash on iOS, but only certain devices?
./platform_references_code.txt:./GPU/Common/TextureReplacer.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./GPU/Common/VertexDecoderArm.cpp:// NOTE: Avoid R9, it's dangerous on iOS.
./platform_references_code.txt:./GPU/Common/VertexDecoderCommon.cpp:		// We've compiled the steps into optimized machine code, so just jump!
./platform_references_code.txt:./GPU/Common/VertexDecoderX86.cpp:// XMM0-XMM5 are volatile on Windows X64
./platform_references_code.txt:./GPU/Common/VertexShaderGenerator.cpp:// Now, the regular machinery will take over and do the calculation again.
./platform_references_code.txt:./GPU/D3D11/D3D11Util.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./GPU/D3D11/StateMappingD3D11.cpp:	// we go through Draw here because it automatically handles screen rotation, as needed in UWP on mobiles.
./platform_references_code.txt:./GPU/D3D11/TextureCacheD3D11.h:#include "Common/CommonWindows.h"
./platform_references_code.txt:./GPU/Debugger/Playback.cpp:#if !defined(__LIBRETRO__)
./platform_references_code.txt:./GPU/GLES/GPU_GLES.cpp:#include "Windows/GPU/WindowsGLContext.h"
./platform_references_code.txt:./GPU/GLES/GPU_GLES.cpp:	// If we're here during app shutdown (exiting the Windows app in-game, for example)
./platform_references_code.txt:./GPU/GLES/ShaderManagerGLES.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./GPU/GLES/StateMappingGLES.cpp:#elif !PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./GPU/GPU.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./GPU/GPU.cpp:		// Disable GLES on ARM Windows (but leave it enabled on other ARM platforms).
./platform_references_code.txt:./GPU/GPU.vcxproj:    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
./platform_references_code.txt:./GPU/GPU.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./GPU/GPU.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./GPU/GPU.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./GPU/GPU.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./GPU/GPU.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./GPU/GPU.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./GPU/GPU.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./platform_references_code.txt:./GPU/GPU.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./platform_references_code.txt:./GPU/GPU.vcxproj:  <PropertyGroup Label="UserMacros" />
./platform_references_code.txt:./GPU/GPU.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./platform_references_code.txt:./GPU/GPU.vcxproj:    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSdk_LibraryPath_x86);</LibraryPath>
./platform_references_code.txt:./GPU/GPU.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./platform_references_code.txt:./GPU/GPU.vcxproj:    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSdk_LibraryPath_x64);</LibraryPath>
./platform_references_code.txt:./GPU/GPU.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./platform_references_code.txt:./GPU/GPU.vcxproj:    <LibraryPath>$(VC_LibraryPath_ARM64);$(WindowsSdk_LibraryPath_ARM64);</LibraryPath>
./platform_references_code.txt:./GPU/GPU.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./platform_references_code.txt:./GPU/GPU.vcxproj:    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSdk_LibraryPath_x64);</LibraryPath>
./platform_references_code.txt:./GPU/GPU.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./platform_references_code.txt:./GPU/GPU.vcxproj:    <LibraryPath>$(VC_LibraryPath_ARM64);$(WindowsSdk_LibraryPath_ARM64);</LibraryPath>
./platform_references_code.txt:./GPU/GPU.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./platform_references_code.txt:./GPU/GPU.vcxproj:    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSdk_LibraryPath_x86);</LibraryPath>
./platform_references_code.txt:./GPU/GPUCommon.cpp:	// you'd expect due to the int64 field, but the Linux ABI apparently does not require that.
./platform_references_code.txt:./GPU/GPUCommon.cpp:DLResult GPUCommon::ProcessDLQueue() {
./platform_references_code.txt:./GPU/GPUCommon.cpp:		if (g_Config.bIgnoreBadMemAccess) {
./platform_references_code.txt:./GPU/GPUCommon.h:	DLResult ProcessDLQueue();
./platform_references_code.txt:./GPU/Math3D.h:#if PPSSPP_PLATFORM(WINDOWS) && (defined(_MSC_VER) || defined(__clang__) || defined(__INTEL_COMPILER))
./platform_references_code.txt:./GPU/Math3D.h:// There's probably a better place to define these macros.
./platform_references_code.txt:./GPU/Math3D.h:// spills, but that, hopefully, does not affect PPSSPP (modern GCC+Linux
./platform_references_code.txt:./GPU/Software/DrawPixel.cpp:#if PPSSPP_ARCH(AMD64) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./GPU/Software/DrawPixelX86.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./GPU/Software/DrawPixelX86.cpp:	// RET + Windows reserves space to save args, half of 1 xmm + 4 ints before the id.
./platform_references_code.txt:./GPU/Software/DrawPixelX86.cpp:					MOV(PTRBITS, R(depthTemp), MAccessibleDisp(depthTemp, &fb.data, &depthbuf.data));
./platform_references_code.txt:./GPU/Software/Lighting.cpp:	Vec4<int> mac = state.colorForAmbient ? colorFactor : state.material.ambientColorFactor;
./platform_references_code.txt:./GPU/Software/Lighting.cpp:	Vec4<int> ambient = (mac * state.baseAmbientColorFactor) >> 10;
./platform_references_code.txt:./GPU/Software/Lighting.cpp:			Vec4<int> lambient = LightColorScaleBy512<useSSE4>(lstate.ambientColorFactor, mac, attspot512);
./platform_references_code.txt:./GPU/Software/RasterizerRectangle.cpp:			// We might be able to compare ratios, but let's expect 1:1.
./platform_references_code.txt:./GPU/Software/RasterizerRegCache.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./GPU/Software/RasterizerRegCache.cpp:	// The Windows convention is annoying, as it wastes registers and keeps to "positions."
./platform_references_code.txt:./GPU/Software/RasterizerRegCache.cpp:#if defined(_WIN32) && (PPSSPP_ARCH(X86) || PPSSPP_ARCH(AMD64)) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./GPU/Software/RasterizerRegCache.h:#if PPSSPP_ARCH(AMD64) && PPSSPP_PLATFORM(WINDOWS) && (defined(_MSC_VER) || defined(__clang__) || defined(__INTEL_COMPILER))
./platform_references_code.txt:./GPU/Software/RasterizerRegCache.h:	// Note: Assumes __vectorcall on Windows.
./platform_references_code.txt:./GPU/Software/Sampler.cpp:#if PPSSPP_ARCH(AMD64) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./GPU/Software/SamplerX86.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./GPU/Software/SamplerX86.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./GPU/Software/SamplerX86.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./GPU/Software/SamplerX86.cpp:		// On Linux, RCX is currently levelFrac, but we'll need it for other things.
./platform_references_code.txt:./GPU/Software/SamplerX86.cpp:#if !PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./GPU/Software/SamplerX86.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./GPU/Software/SamplerX86.cpp:	// Free up some more vector regs on Windows too, where we're a bit tight.
./platform_references_code.txt:./GPU/Software/SamplerX86.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./GPU/Software/SamplerX86.cpp:		// Leave level/levelFrac, we just always load from RAM on Windows and lock on POSIX.
./platform_references_code.txt:./GPU/Software/SamplerX86.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./GPU/Software/SoftGpu.cpp:		if (g_Config.bIgnoreBadMemAccess) {
./platform_references_code.txt:./GPU/Vulkan/DebugVisVulkan.cpp:		vmaCalculateStatistics(vulkan->Allocator(), &vmaStats);
./platform_references_code.txt:./GPU/Vulkan/ShaderManagerVulkan.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./LICENSE.TXT:    a) Accompany it with the complete corresponding machine-readable
./platform_references_code.txt:./LICENSE.TXT:    machine-readable copy of the corresponding source code, to be
./platform_references_code.txt:./README.md:No BIOS file required to play, PPSSPP is an "HLE" emulator.  Default settings balance good compatibility and speed.
./platform_references_code.txt:./README.md:To download fresh development builds for Android, Windows and Mac, [go to the /devbuilds page](https://www.ppsspp.org/devbuilds)
./platform_references_code.txt:./README.md:- Fix exiting not functioning correctly on Windows in some circumstances ([#20607])
./platform_references_code.txt:./README.md:- Fix bug in Mac/Linux builds where the mouse got hidden and stuck if you enabled mouse input mapping ([#20612])
./platform_references_code.txt:./README.md:- Fixed some hangs in the Windows debugger ([#20510])
./platform_references_code.txt:./README.md:- Possible fix for Mac audio device selection issue ([#20482])
./platform_references_code.txt:./README.md:	- More precise sleep function on Windows ([#20054])
./platform_references_code.txt:./README.md:	- Minor features: Asks for confirmation on exit in most scenarios ([#19996], [#20023]), DPI scaling ([#20013]), can pause without menu ([#19883])
./platform_references_code.txt:./README.md:	- Allow picking a background image on iOS ([#20370])
./platform_references_code.txt:./README.md:	- Exclude older Macs from using Vulkan (too many black screens, hangs) ([#20236])
./platform_references_code.txt:./README.md:	- Use portable-file-dialogs to provide file-open dialogs on Linux ([#20175])
./platform_references_code.txt:./README.md:	- Now rendering at proper resolution on newer Macs ([#20011])
./platform_references_code.txt:./README.md:	- Use the correct font again on Mac/iOS ([#19874])
./platform_references_code.txt:./README.md:	- Improved iOS/Mac support, Game Mode support ([#19287], [#19281], [#19269], [#19270], [#19257], [#19254], [#19244], [#19227], [#19224], [#19213], [#19200], [#19187], [#19184], [#19161], [#19118])
./platform_references_code.txt:./README.md:	- SDL fixes: ([#19131])
./platform_references_code.txt:./README.md:	- Android and Windows shortcuts - add icons and bugfixes: ([#19139], [#19142], [#19138])
./platform_references_code.txt:./README.md:[#19287]: https://github.com/hrydgard/ppsspp/issues/19287 "iOS: Enable \"double-swipe\" to switch apps"
./platform_references_code.txt:./README.md:[#19281]: https://github.com/hrydgard/ppsspp/issues/19281 "iOS: Disable the swipe-back gesture in-game, to maximize touch responsiveness"
./platform_references_code.txt:./README.md:[#19269]: https://github.com/hrydgard/ppsspp/issues/19269 "Set the games category in plists for Mac and iOS."
./platform_references_code.txt:./README.md:[#19270]: https://github.com/hrydgard/ppsspp/issues/19270 "Set GCSupportsGameMode in info.plist files for iOS and Mac"
./platform_references_code.txt:./README.md:[#19257]: https://github.com/hrydgard/ppsspp/issues/19257 "iOS: Implement basic physical keyboard support"
./platform_references_code.txt:./README.md:[#19254]: https://github.com/hrydgard/ppsspp/issues/19254 "iOS: Fix \"Home\" button on controllers (like the PS logo button on a PS4 controller)"
./platform_references_code.txt:./README.md:[#19227]: https://github.com/hrydgard/ppsspp/issues/19227 "More text fixes on iOS/Mac"
./platform_references_code.txt:./README.md:[#19224]: https://github.com/hrydgard/ppsspp/issues/19224 "More iOS fixes"
./platform_references_code.txt:./README.md:[#19213]: https://github.com/hrydgard/ppsspp/issues/19213 "iOS: Prevent the Recents list from disappearing a lot"
./platform_references_code.txt:./README.md:[#19200]: https://github.com/hrydgard/ppsspp/issues/19200 "iOS: Add audio session mode controls"
./platform_references_code.txt:./README.md:[#19187]: https://github.com/hrydgard/ppsspp/issues/19187 "iOS: Fix issue with keyboard popping up after file picker."
./platform_references_code.txt:./README.md:[#19184]: https://github.com/hrydgard/ppsspp/issues/19184 "Native text drawing on macOS/iOS"
./platform_references_code.txt:./README.md:[#19161]: https://github.com/hrydgard/ppsspp/issues/19161 "Add basic soft-keyboard support on iOS"
./platform_references_code.txt:./README.md:[#19118]: https://github.com/hrydgard/ppsspp/issues/19118 "macOS: Update VulkanLoader for MoltenVK 1.2.8-style framework finding"
./platform_references_code.txt:./README.md:[#19243]: https://github.com/hrydgard/ppsspp/issues/19243 "iOS: Implement accelerometer support"
./platform_references_code.txt:./README.md:[#19131]: https://github.com/hrydgard/ppsspp/issues/19131 "CPU at 100% in menu in Vulkan on Linux"
./platform_references_code.txt:./README.md:[#19138]: https://github.com/hrydgard/ppsspp/issues/19138 "Windows: When using \"Create shortcut\", use the game's icon instead of PPSSPP's"
./platform_references_code.txt:./README.md:[#19505]: https://github.com/hrydgard/ppsspp/issues/19505 "iOS: Chat input fix, Mac text input fix"
./platform_references_code.txt:./README.md:[#20023]: https://github.com/hrydgard/ppsspp/issues/20023 "Add confirmation popup support on Exit App key, libretro buildfix"
./platform_references_code.txt:./README.md:[#20230]: https://github.com/hrydgard/ppsspp/issues/20230 "Move to trash instead of deleting important files like savedata (Windows only so far)"
./platform_references_code.txt:./README.md:[#19973]: https://github.com/hrydgard/ppsspp/issues/19973 "Add support for displaying the battery percentage on Windows."
./platform_references_code.txt:./README.md:[#19967]: https://github.com/hrydgard/ppsspp/issues/19967 "Support battery percentage display on SDL"
./platform_references_code.txt:./README.md:[#20370]: https://github.com/hrydgard/ppsspp/issues/20370 "iOS: Implement a background image picker"
./platform_references_code.txt:./README.md:[#20236]: https://github.com/hrydgard/ppsspp/issues/20236 "Blacklist older Intel GPUs from using Vulkan on Mac"
./platform_references_code.txt:./README.md:[#20175]: https://github.com/hrydgard/ppsspp/issues/20175 "Add Linux file dialog support through \"portable-file-dialogs\""
./platform_references_code.txt:./README.md:[#20011]: https://github.com/hrydgard/ppsspp/issues/20011 "macOS SDL: Set the metal layer resolution properly, remove DPI hacks."
./platform_references_code.txt:./README.md:[#19874]: https://github.com/hrydgard/ppsspp/issues/19874 "macOS/iOS: register font with CoreText"
./platform_references_code.txt:./README.md:[#20482]: https://github.com/hrydgard/ppsspp/issues/20482 "SDL audio: Improve logging, don't auto-switch device during the first 3 seconds of execution"
./platform_references_code.txt:./README.md:[#20612]: https://github.com/hrydgard/ppsspp/issues/20612 "SDL: Fix bug where the mouse got stuck in relative mode when mapping mouse inputs"
./platform_references_code.txt:./Tools/SaveTool/main.c:	SceIoStat fileStat;
./platform_references_code.txt:./Tools/SaveTool/main.c:	SceIoStat fileStat;
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-registry",
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "linux-raw-sys"
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "openssl-macros",
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "openssl-macros"
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "proc-macro2"
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-sys 0.52.0",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "linux-raw-sys",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-sys 0.60.2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-sys 0.61.2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "wasm-bindgen-macro",
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "wasm-bindgen-macro"
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "wasm-bindgen-macro-support",
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "wasm-bindgen-macro-support"
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "winapi-i686-pc-windows-gnu",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "winapi-x86_64-pc-windows-gnu",
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "winapi-i686-pc-windows-gnu"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "winapi-x86_64-pc-windows-gnu"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows-link"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows-registry"
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-link",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-result",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-strings",
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows-result"
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-link",
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows-strings"
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-link",
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows-sys"
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-targets 0.52.6",
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows-sys"
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-targets 0.53.5",
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows-sys"
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-link",
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows-targets"
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_aarch64_gnullvm 0.52.6",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_aarch64_msvc 0.52.6",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_i686_gnu 0.52.6",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_i686_gnullvm 0.52.6",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_i686_msvc 0.52.6",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_x86_64_gnu 0.52.6",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_x86_64_gnullvm 0.52.6",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_x86_64_msvc 0.52.6",
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows-targets"
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows-link",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_aarch64_gnullvm 0.53.1",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_aarch64_msvc 0.53.1",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_i686_gnu 0.53.1",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_i686_gnullvm 0.53.1",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_i686_msvc 0.53.1",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_x86_64_gnu 0.53.1",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_x86_64_gnullvm 0.53.1",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "windows_x86_64_msvc 0.53.1",
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_aarch64_gnullvm"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_aarch64_gnullvm"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_aarch64_msvc"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_aarch64_msvc"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_i686_gnu"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_i686_gnu"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_i686_gnullvm"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_i686_gnullvm"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_i686_msvc"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_i686_msvc"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_x86_64_gnu"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_x86_64_gnu"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_x86_64_gnullvm"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_x86_64_gnullvm"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_x86_64_msvc"
./platform_references_code.txt:./Tools/langtool/Cargo.lock:name = "windows_x86_64_msvc"
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/Cargo.lock: "proc-macro2",
./platform_references_code.txt:./Tools/langtool/unused-heuristic.sh:folders=('../../UI/' '../../Core/' '../../Common/' '../../GPU/' '../../Windows/' '../../assets/shaders' '../../assets/themes')
./platform_references_code.txt:./UI/AudioCommon.cpp:	if (g_Config.iAudioPlaybackMode == (int)AudioSyncMode::GRANULAR) {
./platform_references_code.txt:./UI/AudioCommon.cpp:		if (g_Config.iAudioPlaybackMode == (int)AudioSyncMode::GRANULAR) {
./platform_references_code.txt:./UI/AudioCommon.cpp:		if (g_Config.iAudioPlaybackMode == (int)AudioSyncMode::GRANULAR) {
./platform_references_code.txt:./UI/Background.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/Background.cpp:	// iOS uses an old screenshot when restoring the task, so to avoid an ugly
./platform_references_code.txt:./UI/DarwinFileSystemServices.h:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/DarwinFileSystemServices.h:	// iOS only, needed for UIDocumentPickerViewController
./platform_references_code.txt:./UI/DarwinFileSystemServices.h:#endif // PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/DarwinFileSystemServices.h:void RestartMacApp();
./platform_references_code.txt:./UI/DarwinFileSystemServices.mm:#include "../ios/ViewControllerCommon.h"
./platform_references_code.txt:./UI/DarwinFileSystemServices.mm:#if PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./UI/DarwinFileSystemServices.mm:			INFO_LOG(Log::System, "Mac: Received OK response from modal");
./platform_references_code.txt:./UI/DarwinFileSystemServices.mm:			INFO_LOG(Log::System, "Mac: Received Cancel response from modal");
./platform_references_code.txt:./UI/DarwinFileSystemServices.mm:			WARN_LOG(Log::System, "Mac: Received unknown responsde from modal");
./platform_references_code.txt:./UI/DarwinFileSystemServices.mm:#elif PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/DarwinFileSystemServices.mm:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/DarwinFileSystemServices.mm:#elif PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./UI/DarwinFileSystemServices.mm:void RestartMacApp() {
./platform_references_code.txt:./UI/DarwinFileSystemServices.mm:#if PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./UI/DebugOverlay.cpp:#if !PPSSPP_PLATFORM(UWP) && !PPSSPP_PLATFORM(SWITCH)
./platform_references_code.txt:./UI/DevScreens.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/DeveloperToolsScreen.cpp:	// iOS can now use JIT on all modes, apparently.
./platform_references_code.txt:./UI/DeveloperToolsScreen.cpp:	// The bool may come in handy for future non-jit platforms though (UWP XB1?)
./platform_references_code.txt:./UI/DeveloperToolsScreen.cpp:	// In iOS App Store builds, we disable the JIT.
./platform_references_code.txt:./UI/DeveloperToolsScreen.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/DeveloperToolsScreen.cpp:	list->Add(new NoticeView(NoticeLevel::WARN, ms->T("Moving the memstick directory is NOT recommended on iOS"), ""));
./platform_references_code.txt:./UI/DeveloperToolsScreen.cpp:	// Makes it easy to get savestates out of an iOS device. The file listing shown in MacOS doesn't allow
./platform_references_code.txt:./UI/DeveloperToolsScreen.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/DeveloperToolsScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/DeveloperToolsScreen.cpp:#if !PPSSPP_PLATFORM(ANDROID) && !PPSSPP_PLATFORM(IOS) && !PPSSPP_PLATFORM(SWITCH)
./platform_references_code.txt:./UI/DiscordIntegration.cpp:#if (PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(LINUX)) && !PPSSPP_PLATFORM(ANDROID) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/DisplayLayoutScreen.cpp:#elif PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/EmuScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/EmuScreen.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/EmuScreen.cpp:#include "Windows/MainWindow.h"
./platform_references_code.txt:./UI/EmuScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/EmuScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/EmuScreen.cpp:	// External commands, like from the Windows UI.
./platform_references_code.txt:./UI/EmuScreen.cpp:#if PPSSPP_PLATFORM(WINDOWS) || defined(USING_QT_UI) || defined(SDL)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#include "Windows/MainWindow.h"
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#include "Windows/W32Util/ShellUtil.h"
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:extern AndroidAudioState *g_audioState;
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:		CreateAudioSettings(parent);
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	// If only one mode is supported (like FIFO on iOS), no need to show the options.
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:void GameSettingsScreen::CreateAudioSettings(UI::ViewGroup *audioSettings) {
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	CheckBox *respectSilentMode = audioSettings->Add(new CheckBox(&g_Config.bAudioRespectSilentMode, a->T("Respect silent mode")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	CheckBox *mixWithOthers = audioSettings->Add(new CheckBox(&g_Config.bAudioMixWithOthers, a->T("Mix audio with other apps")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	audioSettings->Add(new ItemHeader(a->T("Audio playback")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	audioSettings->Add(new PopupMultiChoice(&g_Config.iAudioPlaybackMode, a->T("Playback mode"), syncModes, 0, ARRAY_SIZE(syncModes), I18NCat::AUDIO, screenManager()));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	audioSettings->Add(new CheckBox(&g_Config.bFillAudioGaps, a->T("Fill audio gaps")))->SetEnabledFunc([]() {
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:		return g_Config.iAudioPlaybackMode == (int)AudioSyncMode::GRANULAR;
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	audioSettings->Add(new ItemHeader(a->T("Game volume")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	CheckBox *enableSound = audioSettings->Add(new CheckBox(&g_Config.bEnableSound, a->T("Enable Sound")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	PopupSliderChoice *volume = audioSettings->Add(new PopupSliderChoice(&g_Config.iGameVolume, VOLUME_OFF, VOLUMEHI_FULL, VOLUMEHI_FULL, a->T("Game volume"), screenManager()));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	PopupSliderChoice *reverbVolume = audioSettings->Add(new PopupSliderChoice(&g_Config.iReverbVolume, VOLUME_OFF, 2 * VOLUMEHI_FULL, VOLUMEHI_FULL, a->T("Reverb volume"), screenManager()));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	PopupSliderChoice *altVolume = audioSettings->Add(new PopupSliderChoice(&g_Config.iAltSpeedVolume, VOLUME_OFF, VOLUMEHI_FULL, NO_DEFAULT_INT, a->T("Alternate speed volume"), screenManager()));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	PopupSliderChoice *achievementVolume = audioSettings->Add(new PopupSliderChoice(&g_Config.iAchievementVolume, VOLUME_OFF, VOLUMEHI_FULL, MultiplierToVolume100(0.6f), ac->T("Achievement sound volume"), screenManager()));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	audioSettings->Add(new ItemHeader(a->T("UI sound")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	audioSettings->Add(new CheckBox(&g_Config.bUISound, a->T("UI sound")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	PopupSliderChoice *uiVolume = audioSettings->Add(new PopupSliderChoice(&g_Config.iUIVolume, 0, VOLUMEHI_FULL, VOLUMEHI_FULL, a->T("UI volume"), screenManager()));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	PopupSliderChoice *gamePreviewVolume = audioSettings->Add(new PopupSliderChoice(&g_Config.iGamePreviewVolume, VOLUME_OFF, VOLUMEHI_FULL, 75, a->T("Game preview volume"), screenManager()));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	bool sdlAudio = false;
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if defined(SDL)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	audioSettings->Add(new ItemHeader(a->T("Audio backend")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	PopupMultiChoiceDynamic *audioDevice = audioSettings->Add(new PopupMultiChoiceDynamic(&g_Config.sAudioDevice, a->T("Device"), audioDeviceList, I18NCat::NONE, screenManager()));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	sdlAudio = true;
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	PopupSliderChoice *bufferSize = audioSettings->Add(new PopupSliderChoice(&g_Config.iSDLAudioBufferSize, 0, 2048, 256, a->T("Buffer size"), screenManager()));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	audioSettings->Add(new SettingHint(di->T("This change will not take effect until PPSSPP is restarted.")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:		audioSettings->Add(new ItemHeader(a->T("Audio backend")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:		PopupMultiChoiceDynamic *audioDevice = audioSettings->Add(new PopupMultiChoiceDynamic(&g_Config.sAudioDevice, a->T("Device"), audioDeviceNames, I18NCat::NONE, screenManager(), &audioDeviceIds));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:		CheckBox *autoAudio = audioSettings->Add(new CheckBox(&g_Config.bAutoAudioDevice, a->T("Use new audio devices automatically")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	const bool isWindows = true;
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	const bool isWindows = false;
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	audioSettings->Add(new ItemHeader(a->T("Audio backend")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	if (sdlAudio) {
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:		audioSettings->Add(new CheckBox(&g_Config.bAutoAudioDevice, a->T("Use new audio devices automatically")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	CheckBox *extraAudio = audioSettings->Add(new CheckBox(&g_Config.bExtraAudioBuffering, a->T("AudioBufferingForBluetooth", "Bluetooth-friendly buffer (slower)")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	const std::string audioErrorStr = AndroidAudio_GetErrorString(g_audioState);
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:		audioSettings->Add(new InfoItem(a->T("Audio Error"), audioErrorStr));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:		audioSettings->Add(new ItemHeader(a->T("Microphone")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:		PopupMultiChoiceDynamic *MicChoice = audioSettings->Add(new PopupMultiChoiceDynamic(&g_Config.sMicDevice, a->T("Microphone Device"), micList, I18NCat::NONE, screenManager()));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if defined(USING_WIN_UI) || (PPSSPP_PLATFORM(LINUX) && !PPSSPP_PLATFORM(ANDROID))
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:		controlsSettings->Add(new CheckBox(&g_Config.bIgnoreWindowsKey, co->T("Ignore Windows Key")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if defined(USING_WIN_UI) || defined(SDL) || PPSSPP_PLATFORM(ANDROID)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:class MacAddressChooser : public UI::LinearLayout {
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	MacAddressChooser(RequesterToken token, Path gamePath, std::string *value, std::string_view title, ScreenManager *screenManager, UI::LayoutParams *layoutParams = nullptr);
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:MacAddressChooser::MacAddressChooser(RequesterToken token, Path gamePath, std::string *value, std::string_view title, ScreenManager *screenManager, UI::LayoutParams *layoutParams) : UI::LinearLayout(ORIENT_HORIZONTAL, layoutParams) {
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	Add(new PopupTextInputChoice(token, value, title, g_Config.sMACAddress, 17, screenManager, new LinearLayoutParams(1.0f)))->OnChange.Add([=](UI::EventParams &e) {
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:		if (g_Config.sMACAddress.size() != 17) {
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:		std::string_view confirmMessage = n->T("ChangeMacSaveConfirm", "Generate a new MAC address?");
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:		std::string_view warningMessage = n->T("ChangeMacSaveWarning", "Some games verify the MAC address when loading savedata, so this may break old saves.");
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:		std::string combined = g_Config.sMACAddress + "\n\n" + std::string(confirmMessage) + "\n\n" + std::string(warningMessage);
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:					g_Config.sMACAddress = CreateRandMAC();
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	networkingSettings->Add(new MacAddressChooser(GetRequesterToken(), gamePath_, &g_Config.sMACAddress, n->T("Change Mac Address"), screenManager()));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if (!defined(MOBILE_DEVICE) && !defined(USING_QT_UI)) || defined(USING_QT_UI) || PPSSPP_PLATFORM(ANDROID) // Missing only iOS?
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if !defined(MOBILE_DEVICE) && !defined(USING_QT_UI)  // TODO: Add all platforms where KEY_CHAR support is added
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#elif defined(USING_QT_UI)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if (!defined(MOBILE_DEVICE) && !defined(USING_QT_UI)) || defined(USING_QT_UI) || PPSSPP_PLATFORM(ANDROID)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if defined(USING_QT_UI) || PPSSPP_PLATFORM(ANDROID)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	systemSettings->Add(new CheckBox(&g_Config.bIgnoreBadMemAccess, sy->T("Ignore bad memory accesses")));
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:	// TODO: Make this setting available on Mac too.
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if defined(_WIN32) || (defined(USING_QT_UI) && !defined(MOBILE_DEVICE))
./platform_references_code.txt:./UI/GameSettingsScreen.cpp:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/GameSettingsScreen.h:	void CreateAudioSettings(UI::ViewGroup *audioSettings);
./platform_references_code.txt:./UI/GameSettingsScreen.h:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/GameSettingsScreen.h:#if PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/GamepadEmu.cpp:// On IOS, nudge the bottom button up a little to avoid the task switcher.
./platform_references_code.txt:./UI/GamepadEmu.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/IAPScreen.cpp:// NOTE: This currently only used on iOS, to present the availablility of getting PPSSPP Gold through IAP.
./platform_references_code.txt:./UI/IAPScreen.cpp:#elif PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/IAPScreen.cpp:		System_LaunchUrl(LaunchUrlType::BROWSER_URL, "https://www.ppsspp.org/buygold_ios");
./platform_references_code.txt:./UI/IAPScreen.h:// NOTE: This is only used on iOS, to present the availablility of getting PPSSPP Gold through IAP.
./platform_references_code.txt:./UI/ImDebugger/ImConsole.cpp:	ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(420, 300), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(420, 300), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(320, 600), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(320, 600), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(320, 600), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(420, 300), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(420, 300), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(420, 500), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:	if (g_Config.iAudioPlaybackMode == (int)AudioSyncMode::GRANULAR) {
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:	if (ImGui::BeginTable("audios", 7, ImGuiTableFlags_RowBg | ImGuiTableFlags_BordersH)) {
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:	ImGui::SetNextWindowSize(ImVec2(500, 400), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:		"On a real PSP, these would be loaded from the BIOS.\n");
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:	reqToken_ = g_requestManager.GenerateRequesterToken();
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:			ImGui::MenuItem("Ignore bad memory accesses", nullptr, &g_Config.bIgnoreBadMemAccess);
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:				System_BrowseForFile(reqToken_, "Load PPSSPP symbol map", BrowseFileType::SYMBOL_MAP, [&](const char *responseString, int) {
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:				System_BrowseForFileSave(reqToken_, "Save PPSSPP symbol map", "symbols.ppmap", BrowseFileType::SYMBOL_MAP, [](const char *responseString, int) {
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:				System_BrowseForFile(reqToken_, "Load No$ symbol map", BrowseFileType::SYMBOL_MAP, [&](const char *responseString, int) {
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:				System_BrowseForFileSave(reqToken_, "Save No$ symbol map", "symbols.sym", BrowseFileType::SYMBOL_MAP, [](const char *responseString, int) {
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.cpp:	sync.SetSection(ini->GetOrCreateSection("Windows"));
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.h:// * If windows/objects need state, prefix the class name with Im and just store straight in parent struct
./platform_references_code.txt:./UI/ImDebugger/ImDebugger.h:	RequesterToken reqToken_;
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	windowStart_ = curAddress_;
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	g_disassemblyManager.analyze(windowStart_, g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_) - windowStart_);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	u32 windowEnd = g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	if (line.first < windowStart_) {
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	if (line.second < windowStart_) {
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	const bool is_active = ImGui::IsItemActive();   // Held
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	unsigned int address = windowStart_;
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	std::vector<BranchLine> branchLines = g_disassemblyManager.getBranchLines(windowStart_, address - windowStart_);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:			windowStart_ = g_disassemblyManager.getNthPreviousAddress(windowStart_, 4);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:			windowStart_ = g_disassemblyManager.getNthNextAddress(windowStart_, 4);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:		windowStart_ = g_disassemblyManager.getNthNextAddress(windowStart_, amount);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:		windowStart_ = g_disassemblyManager.getNthPreviousAddress(windowStart_, amount);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	if (line.type == DISTYPE_OPCODE || line.type == DISTYPE_MACRO) {
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	u32 windowEnd = g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:			setCurAddress(windowStart_, ImGui::IsKeyDown(ImGuiKey_LeftShift));
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:			windowStart_ = g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:			windowStart_ = g_disassemblyManager.getNthPreviousAddress(windowStart_, visibleRows_);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:			if (curAddress_ != windowStart_ && curAddressIsVisible()) {
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:				setCurAddress(windowStart_, KeyDownAsync(VK_SHIFT));
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:				setCurAddress(g_disassemblyManager.getNthPreviousAddress(windowStart_, visibleRows_), KeyDownAsync(VK_SHIFT));
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	u32 windowEnd = g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	if (curAddress_ < windowStart_)
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:		windowStart_ = curAddress_;
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:		windowStart_ = g_disassemblyManager.getNthPreviousAddress(curAddress_, visibleRows_ - 1);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	u32 windowEnd = g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	return curAddress_ >= windowStart_ && curAddress_ < windowEnd;
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	if (line.type == DISTYPE_OPCODE || line.type == DISTYPE_MACRO) {
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	return g_disassemblyManager.getNthNextAddress(windowStart_, line);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	u32 windowEnd = g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:		windowStart_ = g_disassemblyManager.getNthPreviousAddress(newPc, visibleRows_ - 2);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.cpp:	ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.h:		u32 windowEnd = g_disassemblyManager.getNthNextAddress(windowStart_, visibleRows_);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.h:		if (newAddress < windowStart_ || newAddress >= windowEnd) {
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.h:			windowStart_ = g_disassemblyManager.getNthPreviousAddress(newAddress, visibleRows_ / 2);
./platform_references_code.txt:./UI/ImDebugger/ImDisasmView.h:	u32 windowStart_ = 0;
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(300, 500), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(600, 500), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:	u32 windowStartAddr = selectedAddr_ - (numLines / 2) * instrWidth;
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:	float pcY = canvas_p0.y + ((pc - windowStartAddr) / instrWidth) * lineHeight;
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:	float stallY = canvas_p0.y + ((stallAddr - windowStartAddr) / instrWidth) * lineHeight;
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:	u32 addr = windowStartAddr;
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:	int selectedY = canvas_p0.y + ((selectedAddr_ - windowStartAddr) / instrWidth) * lineHeight;
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:		int dragY = canvas_p0.y + ((dragAddr_ - windowStartAddr) / instrWidth) * lineHeight;
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:	const bool is_active = ImGui::IsItemActive();   // Held
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:		dragAddr_ = windowStartAddr + ((int)mouse_pos_in_canvas.y / lineHeight) * instrWidth;
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(300, 500), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImGe.cpp:	ImGui::SetNextWindowSize(ImVec2(300, 500), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImGe.h:// GE-related windows of the ImDebugger
./platform_references_code.txt:./UI/ImDebugger/ImJitViewer.cpp:	ImGui::SetNextWindowSize(ImVec2(500, 400), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:	windowStart_ = curAddress_;
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:	const bool is_active = ImGui::IsItemActive();   // Held
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:	std::vector<MemBlockInfo> memRangeInfo = FindMemInfoByFlag(highlightFlags_, windowStart_, (visibleRows_ + 1) * rowSize_);
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:	_assert_msg_(((windowStart_ | rowSize_) & 3) == 0, "readMemory() can't handle unaligned reads");
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:		uint32_t address = windowStart_ + i * rowSize_;
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:			windowStart_ -= rowSize_ * 4;
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:			windowStart_ += rowSize_ * 4;
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:	int lineAddress = windowStart_ + line * rowSize_;
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:	u32 windowEnd = windowStart_ + lines * rowSize_;
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:	if (curAddress_ < windowStart_ || curAddress_ >= windowEnd) {
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:		windowStart_ = curAddress_ & ~15;
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:	windowStart_ += lines * rowSize_;
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:	u32 windowEnd = windowStart_ + visibleRows_ * rowSize_;
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:	if (curAddress_ < windowStart_) {
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:		windowStart_ = curAddress_ & ~15;
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:		windowStart_ = (curAddress_ - (visibleRows_ - 1) * rowSize_) & ~15;
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:	ImGui::SetNextWindowSize(ImVec2(200, 300), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:		// SDL/SDLMain.cpp
./platform_references_code.txt:./UI/ImDebugger/ImMemView.cpp:	ImGui::SetNextWindowSize(ImVec2(520, 600), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/ImDebugger/ImMemView.h:	uint32_t windowStart_ = 0x08800000;
./platform_references_code.txt:./UI/ImDebugger/ImStructViewer.cpp:	ImGui::SetNextWindowSize(ImVec2(750, 550), ImGuiCond_FirstUseEver);
./platform_references_code.txt:./UI/MainScreen.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./UI/MainScreen.cpp:#if PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(SWITCH) || defined(USING_WIN_UI) || PPSSPP_PLATFORM(UWP) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/MainScreen.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./UI/MainScreen.cpp:#elif PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./UI/MainScreen.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/MainScreen.cpp:constexpr std::string_view getGamesUri = "https://www.ppsspp.org/getgames_ios";
./platform_references_code.txt:./UI/MainScreen.cpp:constexpr std::string_view getHomebrewUri = "https://www.ppsspp.org/gethomebrew_ios";
./platform_references_code.txt:./UI/MainScreen.cpp:#if !PPSSPP_PLATFORM(IOS_APP_STORE) && !PPSSPP_PLATFORM(ANDROID)
./platform_references_code.txt:./UI/MainScreen.cpp:	// Officially, iOS apps should not have exit buttons. Remove it to maximize app store review chances.
./platform_references_code.txt:./UI/MainScreen.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./UI/MainScreen.cpp:		System_LaunchUrl(LaunchUrlType::BROWSER_URL, "https://www.ppsspp.org/buygold_ios");
./platform_references_code.txt:./UI/MemStickScreen.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/MemStickScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/MemStickScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/MemStickScreen.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/MemStickScreen.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/MemStickScreen.h:#if PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./platform_references_code.txt:./UI/MemStickScreen.h:#if PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./platform_references_code.txt:./UI/MiscScreens.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./UI/MiscScreens.cpp:		// On Windows, we put the yes button on the left.
./platform_references_code.txt:./UI/MiscScreens.cpp:#if !(defined(USING_QT_UI) || PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(ANDROID))
./platform_references_code.txt:./UI/MiscScreens.cpp:#if !PPSSPP_PLATFORM(UWP) || defined(_DEBUG)
./platform_references_code.txt:./UI/MiscScreens.cpp:	// Draw the graphics API, except on UWP where it's always D3D11
./platform_references_code.txt:./UI/MiscScreens.cpp:	specialthanksangelxwind += cr->T("iOS builds");
./platform_references_code.txt:./UI/MiscScreens.cpp:	specialthanksW_MS += cr->T("iOS builds");
./platform_references_code.txt:./UI/MiscScreens.cpp:#if defined(USING_QT_UI)
./platform_references_code.txt:./UI/MiscScreens.cpp:		"Qt",
./platform_references_code.txt:./UI/MiscScreens.cpp:#if defined(SDL)
./platform_references_code.txt:./UI/MiscScreens.cpp:		"SDL",
./platform_references_code.txt:./UI/NativeApp.cpp:// Android, Linux, MacOSX.
./platform_references_code.txt:./UI/NativeApp.cpp:// Windows has its own code that bypasses the framework entirely.
./platform_references_code.txt:./UI/NativeApp.cpp:#include "Windows/WindowsAudio.h"
./platform_references_code.txt:./UI/NativeApp.cpp:#include "Windows/MainWindow.h"
./platform_references_code.txt:./UI/NativeApp.cpp:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/NativeApp.cpp:#include "Windows/CaptureDevice.h"
./platform_references_code.txt:./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/NativeApp.cpp:#include "UWP/UWPHelpers/InputHelpers.h"
./platform_references_code.txt:./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/NativeApp.cpp:#include "ios/iOSCoreAudio.h"
./platform_references_code.txt:./UI/NativeApp.cpp:#include <mach-o/dyld.h>
./platform_references_code.txt:./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./UI/NativeApp.cpp:#if !defined(__LIBRETRO__)
./platform_references_code.txt:./UI/NativeApp.cpp:#if defined(USING_WIN_UI) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/NativeApp.cpp:#if !PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/NativeApp.cpp:	net::Init();  // This needs to happen before we load the config. So on Windows we also run it in Main. It's fine to call multiple times.
./platform_references_code.txt:./UI/NativeApp.cpp:	// on iOS it's even the path to bundled app assets. It's a mess.
./platform_references_code.txt:./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(IOS) || PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./UI/NativeApp.cpp:#if !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/NativeApp.cpp:#elif PPSSPP_PLATFORM(UWP) && !defined(__LIBRETRO__)
./platform_references_code.txt:./UI/NativeApp.cpp:#elif PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/NativeApp.cpp:#elif PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./UI/NativeApp.cpp:#elif !PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./UI/NativeApp.cpp:#if !PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./UI/NativeApp.cpp:#if defined(_WIN32) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/NativeApp.cpp:		winCamera = new WindowsCaptureDevice(CAPTUREDEVIDE_TYPE::VIDEO);
./platform_references_code.txt:./UI/NativeApp.cpp:		winMic = new WindowsCaptureDevice(CAPTUREDEVIDE_TYPE::Audio);
./platform_references_code.txt:./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/NativeApp.cpp:	// This can only be accessed from Windows currently, and causes linking errors with headless etc.
./platform_references_code.txt:./UI/NativeApp.cpp:			// OSX 10.6 and SDL 1.2 bug.
./platform_references_code.txt:./UI/NativeApp.cpp:#if defined(__APPLE__) && !defined(USING_QT_UI)
./platform_references_code.txt:./UI/NativeApp.cpp:#if !PPSSPP_PLATFORM(WINDOWS) && !defined(ANDROID)
./platform_references_code.txt:./UI/NativeApp.cpp:#if PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/NativeApp.cpp:#if !PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/NativeApp.cpp:// name should be simple alphanumerics to avoid problems on Windows.
./platform_references_code.txt:./UI/NativeApp.cpp:static bool IsWindowSmall(int pixelWidth, int pixelHeight) {
./platform_references_code.txt:./UI/NativeApp.cpp:	if (!g_Config.bShrinkIfWindowSmall) {
./platform_references_code.txt:./UI/NativeApp.cpp:	// Can't take this from config as it will not be set if windows is maximized.
./platform_references_code.txt:./UI/NativeApp.cpp:	bool smallWindow = IsWindowSmall(pixel_width, pixel_height);
./platform_references_code.txt:./UI/RemoteISOScreen.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/RemoteISOScreen.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./UI/RemoteISOScreen.cpp:#if PPSSPP_PLATFORM(WINDOWS) && !PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/RemoteISOScreen.cpp:	firewallWarning_ = tab->Add(new TextView(ri->T("RemoteISOWinFirewall", "WARNING: Windows Firewall is blocking sharing"), new LinearLayoutParams(Margins(12, 5, 0, 5))));
./platform_references_code.txt:./UI/Store.cpp:#if PPSSPP_PLATFORM(IOS_APP_STORE)
./platform_references_code.txt:./UI/Store.h:	int contentRating;  // 100 means to hide it on iOS. No other values defined yet.
./platform_references_code.txt:./UI/SystemInfoScreen.cpp:#elif PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./UI/SystemInfoScreen.cpp:#if PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./UI/SystemInfoScreen.cpp:#if PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(UWP)
./platform_references_code.txt:./UI/SystemInfoScreen.cpp:	// Don't show on Windows, since it's always treated as 60 there.
./platform_references_code.txt:./UI/UI.vcxproj:    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
./platform_references_code.txt:./UI/UI.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./UI/UI.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./UI/UI.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./UI/UI.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./UI/UI.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./UI/UI.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./UI/UI.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./platform_references_code.txt:./UI/UI.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./platform_references_code.txt:./UI/UI.vcxproj:  <PropertyGroup Label="UserMacros" />
./platform_references_code.txt:./UI/UI.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/zlib;../ext</AdditionalIncludeDirectories>
./platform_references_code.txt:./UI/UI.vcxproj:      <SubSystem>Windows</SubSystem>
./platform_references_code.txt:./UI/UI.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/zlib;../ext</AdditionalIncludeDirectories>
./platform_references_code.txt:./UI/UI.vcxproj:      <SubSystem>Windows</SubSystem>
./platform_references_code.txt:./UI/UI.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/zlib;../ext</AdditionalIncludeDirectories>
./platform_references_code.txt:./UI/UI.vcxproj:      <SubSystem>Windows</SubSystem>
./platform_references_code.txt:./UI/UI.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/zlib;../ext</AdditionalIncludeDirectories>
./platform_references_code.txt:./UI/UI.vcxproj:      <SubSystem>Windows</SubSystem>
./platform_references_code.txt:./UI/UI.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\x86_64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/zlib;../ext</AdditionalIncludeDirectories>
./platform_references_code.txt:./UI/UI.vcxproj:      <SubSystem>Windows</SubSystem>
./platform_references_code.txt:./UI/UI.vcxproj:      <AdditionalIncludeDirectories>..\ffmpeg\WindowsInclude;..\ffmpeg\Windows\aarch64\include;../common;..;../ext/native;../ext/glew;../ext/snappy;../ext/zlib;../ext</AdditionalIncludeDirectories>
./platform_references_code.txt:./UI/UI.vcxproj:      <SubSystem>Windows</SubSystem>
./platform_references_code.txt:./UI/UIAtlas.cpp:#if PPSSPP_PLATFORM(WINDOWS) || PPSSPP_PLATFORM(ANDROID) || PPSSPP_PLATFORM(MAC) || PPSSPP_PLATFORM(IOS)
./platform_references_code.txt:./b.sh:		--qt) echo "Qt enabled"
./platform_references_code.txt:./b.sh:			QT=1
./platform_references_code.txt:./b.sh:			CMAKE_ARGS="-DUSING_QT_UI=ON ${CMAKE_ARGS}"
./platform_references_code.txt:./b.sh:		--qtbrew) echo "Qt enabled (homebrew)"
./platform_references_code.txt:./b.sh:			QT=1
./platform_references_code.txt:./b.sh:			CMAKE_ARGS="-DUSING_QT_UI=ON -DCMAKE_PREFIX_PATH=$(brew --prefix qt5) ${CMAKE_ARGS}"
./platform_references_code.txt:./b.sh:		--ios) CMAKE_ARGS="-DCMAKE_TOOLCHAIN_FILE=cmake/Toolchains/ios.cmake ${CMAKE_ARGS}"
./platform_references_code.txt:./b.sh:			TARGET_OS=iOS
./platform_references_code.txt:./b.sh:		--ios-xcode) CMAKE_ARGS="-DCMAKE_TOOLCHAIN_FILE=cmake/Toolchains/ios.cmake -DIOS_PLATFORM=OS -GXcode ${CMAKE_ARGS}"
./platform_references_code.txt:./b.sh:			TARGET_OS=iOS-xcode
./platform_references_code.txt:./b.sh:		--no-sdl2) CMAKE_ARGS="-DUSE_SYSTEM_LIBSDL2=OFF ${CMAKE_ARGS}"
./platform_references_code.txt:./b.sh:		--libretro) echo "Build Libretro core"
./platform_references_code.txt:./b.sh:			CMAKE_ARGS="-DLIBRETRO=ON ${CMAKE_ARGS}"
./platform_references_code.txt:./b.sh:		--libretro_android) echo "Build Libretro Android core"
./platform_references_code.txt:./b.sh:		        CMAKE_ARGS="-DLIBRETRO=ON -DCMAKE_TOOLCHAIN_FILE=${NDK}/build/cmake/android.toolchain.cmake -DANDROID_ABI=${APP_ABI} ${CMAKE_ARGS}"
./platform_references_code.txt:./b.sh:if [[ "$OSTYPE" == "linux-gnu"* ]]; then
./platform_references_code.txt:./build_fontatlas.sh:# TOOL=Windows/ARM64/Debug/AtlasTool.exe
./platform_references_code.txt:./cmake/Modules/FindLIBZIP.cmake:    [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session\ Manager\\Environment;OSG_ROOT]/include
./platform_references_code.txt:./cmake/Modules/FindLIBZIP.cmake:    [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session\ Manager\\Environment;OSG_ROOT]/lib
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:# IOS_PLATFORM = OS (default)
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:# CMAKE_IOS_SDK_ROOT = automatic(default) or /path/to/platform/Developer/SDKs/SDK folder
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:#   By default this location is automatcially chosen based on the CMAKE_IOS_DEVELOPER_ROOT value.
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:#   In this case it will always be the most up-to-date SDK found in the CMAKE_IOS_DEVELOPER_ROOT path.
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:if(IOS_PLATFORM STREQUAL "TVOS")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -mios-version-min=${IPHONEOS_DEPLOYMENT_TARGET}")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mios-version-min=${IPHONEOS_DEPLOYMENT_TARGET}")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:set(IOS ON)
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:set(CMAKE_MACOSX_BUNDLE YES)
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:if(IOS_PLATFORM STREQUAL "TVOS")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:# Setup iOS platform unless specified manually with IOS_PLATFORM
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:if(NOT DEFINED IOS_PLATFORM)
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:  set(IOS_PLATFORM "OS")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:set(IOS_PLATFORM ${IOS_PLATFORM} CACHE STRING "Type of iOS Platform")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:if(IOS_PLATFORM STREQUAL "OS")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:  set(IOS_SDK_NAME "iphoneos")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:elseif(IOS_PLATFORM STREQUAL "SIMULATOR")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:  set(IOS_SDK_NAME "iphonesimulator")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:elseif(IOS_PLATFORM STREQUAL "TVOS")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:  set(IOS_SDK_NAME "appletvos")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:  message (FATAL_ERROR "Unsupported IOS_PLATFORM value selected '${IOS_PLATFORM}'. Please choose OS or leave default")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:# Setup iOS developer location unless specified manually with CMAKE_IOS_DEVELOPER_ROOT
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:if(NOT CMAKE_IOS_SDK_ROOT)
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:  execute_process(COMMAND xcrun --sdk ${IOS_SDK_NAME} --show-sdk-path
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:    OUTPUT_VARIABLE CMAKE_IOS_SDK_ROOT
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:  message (STATUS "Toolchain using default iOS SDK: ${CMAKE_IOS_SDK_ROOT}")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:set(CMAKE_IOS_SDK_ROOT ${CMAKE_IOS_SDK_ROOT} CACHE PATH "Location of the selected iOS SDK")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:set(CMAKE_OSX_SYSROOT ${CMAKE_IOS_SDK_ROOT} CACHE PATH "Sysroot used for iOS support")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:# set the architecture for iOS 
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:if(IOS_PLATFORM STREQUAL "OS" OR IOS_PLATFORM STREQUAL "TVOS")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:  set(IOS_ARCH "arm64")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:  set(IOS_ARCH "i386;x86_64")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:set(CMAKE_OSX_ARCHITECTURES "${IOS_ARCH}" CACHE STRING "Build architecture for iOS")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:foreach(arch ${IOS_ARCH})
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:# Set the find root to the iOS developer roots and to user defined paths
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:set(CMAKE_FIND_ROOT_PATH ${CMAKE_IOS_SDK_ROOT} ${CMAKE_PREFIX_PATH} CACHE STRING "iOS find search path root")
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:  ${CMAKE_IOS_SDK_ROOT}/System/Library/Frameworks
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:  ${CMAKE_IOS_SDK_ROOT}/System/Library/PrivateFrameworks
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:  ${CMAKE_IOS_SDK_ROOT}/Developer/Library/Frameworks
./platform_references_code.txt:./cmake/Toolchains/ios.cmake:# only search the iOS sdks, not the remainder of the host filesystem
./platform_references_code.txt:./cmake/Toolchains/nvidiajetsonsdl.armv8.cmake:if(NOT EXISTS "/usr/lib/aarch64-linux-gnu/tegra")
./platform_references_code.txt:./cmake/Toolchains/nvidiajetsonsdl.armv8.cmake:set (CMAKE_EXE_LINKER_FLAGS "-Wl,-rpath,/usr/lib/aarch64-linux-gnu/tegra" CACHE STRING "" FORCE)
./platform_references_code.txt:./cmake/Toolchains/nvidiajetsonsdl.armv8.cmake:set(OPENGL_LIBRARIES  /usr/lib/aarch64-linux-gnu/tegra/libGLX_nvidia.so.0)
./platform_references_code.txt:./cmake/Toolchains/raspberry.armv6.cmake:  /opt/vc/include/interface/vmcx_host/linux
./platform_references_code.txt:./cmake/Toolchains/raspberry.armv7.cmake:  /opt/vc/include/interface/vmcx_host/linux
./platform_references_code.txt:./cmake/Toolchains/raspberry.armv8.cmake:  /opt/vc/include/interface/vmcx_host/linux
./platform_references_code.txt:./copyrelease.sh:cp PPSSPPWindows.exe $TARGETPATH/
./platform_references_code.txt:./copyrelease.sh:cp PPSSPPWindows64.exe $TARGETPATH/
./platform_references_code.txt:./copysym.sh:DSYM_PATH="build-ios/Release-iphoneos/${APP_NAME}.app.dSYM"
./platform_references_code.txt:./gradlew:# For Cygwin, switch paths to Windows format before running java
./platform_references_code.txt:./headless/Compare.cpp:#include <iostream>
./platform_references_code.txt:./headless/Headless.cpp:// To build on non-windows systems, just run CMake in the SDL directory, it will build both a normal ppsspp and the headless version.
./platform_references_code.txt:./headless/Headless.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./headless/Headless.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./headless/Headless.cpp:#include "WindowsHeadlessHost.h"
./platform_references_code.txt:./headless/Headless.cpp:#elif defined(SDL)
./platform_references_code.txt:./headless/Headless.cpp:#include "SDLHeadlessHost.h"
./platform_references_code.txt:./headless/Headless.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./headless/Headless.cpp:	g_Config.bIgnoreBadMemAccess = true;  // NOTE: A few tests rely on this, which is BAD: threads/mbx/refer/refer , threads/mbx/send/send, threads/vtimers/interrupt
./platform_references_code.txt:./headless/Headless.cpp:	g_Config.sMACAddress = "12:34:56:78:9A:BC";
./platform_references_code.txt:./headless/Headless.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./headless/Headless.cpp:#elif PPSSPP_PLATFORM(LINUX)
./platform_references_code.txt:./headless/Headless.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./headless/Headless.vcxproj:    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
./platform_references_code.txt:./headless/Headless.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./headless/Headless.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./headless/Headless.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./headless/Headless.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./headless/Headless.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./headless/Headless.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./headless/Headless.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./platform_references_code.txt:./headless/Headless.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./platform_references_code.txt:./headless/Headless.vcxproj:  <PropertyGroup Label="UserMacros" />
./platform_references_code.txt:./headless/Headless.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./platform_references_code.txt:./headless/Headless.vcxproj:    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSdk_LibraryPath_x86);</LibraryPath>
./platform_references_code.txt:./headless/Headless.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./platform_references_code.txt:./headless/Headless.vcxproj:    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSdk_LibraryPath_x64);</LibraryPath>
./platform_references_code.txt:./headless/Headless.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./platform_references_code.txt:./headless/Headless.vcxproj:    <LibraryPath>$(VC_LibraryPath_ARM64);$(WindowsSdk_LibraryPath_ARM64);</LibraryPath>
./platform_references_code.txt:./headless/Headless.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./platform_references_code.txt:./headless/Headless.vcxproj:    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSdk_LibraryPath_x86);</LibraryPath>
./platform_references_code.txt:./headless/Headless.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./platform_references_code.txt:./headless/Headless.vcxproj:    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSdk_LibraryPath_x64);</LibraryPath>
./platform_references_code.txt:./headless/Headless.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./platform_references_code.txt:./headless/Headless.vcxproj:    <LibraryPath>$(VC_LibraryPath_ARM64);$(WindowsSdk_LibraryPath_ARM64);</LibraryPath>
./platform_references_code.txt:./headless/Headless.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86/include;../Common;..;../Core;../ext/glew;../ext/libpng17</AdditionalIncludeDirectories>
./platform_references_code.txt:./headless/Headless.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86/lib</AdditionalLibraryDirectories>
./platform_references_code.txt:./headless/Headless.vcxproj:      <Command>../Windows/git-version-gen.cmd Headless</Command>
./platform_references_code.txt:./headless/Headless.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86_64/include;../Common;..;../Core;../ext/glew;../ext/libpng17</AdditionalIncludeDirectories>
./platform_references_code.txt:./headless/Headless.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86_64/lib</AdditionalLibraryDirectories>
./platform_references_code.txt:./headless/Headless.vcxproj:      <Command>../Windows/git-version-gen.cmd Headless</Command>
./platform_references_code.txt:./headless/Headless.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/aarch64/include;../Common;..;../Core;../ext/glew;../ext/libpng17</AdditionalIncludeDirectories>
./platform_references_code.txt:./headless/Headless.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/aarch64/lib</AdditionalLibraryDirectories>
./platform_references_code.txt:./headless/Headless.vcxproj:      <Command>../Windows/git-version-gen.cmd Headless</Command>
./platform_references_code.txt:./headless/Headless.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86/include;../Common;..;../Core;../ext/glew;../ext/libpng17</AdditionalIncludeDirectories>
./platform_references_code.txt:./headless/Headless.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86/lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
./platform_references_code.txt:./headless/Headless.vcxproj:      <Command>../Windows/git-version-gen.cmd Headless</Command>
./platform_references_code.txt:./headless/Headless.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86_64/include;../Common;..;../Core;../ext/glew;../ext/libpng17</AdditionalIncludeDirectories>
./platform_references_code.txt:./headless/Headless.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86_64/lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
./platform_references_code.txt:./headless/Headless.vcxproj:      <Command>../Windows/git-version-gen.cmd Headless</Command>
./platform_references_code.txt:./headless/Headless.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/aarch64/include;../Common;..;../Core;../ext/glew;../ext/libpng17</AdditionalIncludeDirectories>
./platform_references_code.txt:./headless/Headless.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/aarch64/lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
./platform_references_code.txt:./headless/Headless.vcxproj:      <Command>../Windows/git-version-gen.cmd Headless</Command>
./platform_references_code.txt:./headless/Headless.vcxproj:    <ClCompile Include="..\Windows\CaptureDevice.cpp" />
./platform_references_code.txt:./headless/Headless.vcxproj:    <ClCompile Include="..\Windows\GPU\D3D11Context.cpp" />
./platform_references_code.txt:./headless/Headless.vcxproj:    <ClCompile Include="..\Windows\GPU\WindowsGLContext.cpp">
./platform_references_code.txt:./headless/Headless.vcxproj:    <ClCompile Include="..\Windows\GPU\WindowsVulkanContext.cpp" />
./platform_references_code.txt:./headless/Headless.vcxproj:    <ClCompile Include="..\Windows\W32Util\Misc.cpp" />
./platform_references_code.txt:./headless/Headless.vcxproj:    <ClCompile Include="SDLHeadlessHost.cpp">
./platform_references_code.txt:./headless/Headless.vcxproj:    <ClCompile Include="WindowsHeadlessHost.cpp" />
./platform_references_code.txt:./headless/Headless.vcxproj:    <ClInclude Include="SDLHeadlessHost.h" />
./platform_references_code.txt:./headless/Headless.vcxproj:    <ClInclude Include="WindowsHeadlessHost.h" />
./platform_references_code.txt:./headless/Headless.vcxproj.filters:    <ClCompile Include="..\Windows\GPU\WindowsGLContext.cpp">
./platform_references_code.txt:./headless/Headless.vcxproj.filters:      <Filter>Windows</Filter>
./platform_references_code.txt:./headless/Headless.vcxproj.filters:    <ClCompile Include="WindowsHeadlessHost.cpp">
./platform_references_code.txt:./headless/Headless.vcxproj.filters:      <Filter>Windows</Filter>
./platform_references_code.txt:./headless/Headless.vcxproj.filters:    <ClCompile Include="..\Windows\GPU\WindowsVulkanContext.cpp">
./platform_references_code.txt:./headless/Headless.vcxproj.filters:      <Filter>Windows</Filter>
./platform_references_code.txt:./headless/Headless.vcxproj.filters:    <ClCompile Include="..\Windows\W32Util\Misc.cpp">
./platform_references_code.txt:./headless/Headless.vcxproj.filters:      <Filter>Windows</Filter>
./platform_references_code.txt:./headless/Headless.vcxproj.filters:    <ClCompile Include="..\Windows\GPU\D3D11Context.cpp">
./platform_references_code.txt:./headless/Headless.vcxproj.filters:      <Filter>Windows</Filter>
./platform_references_code.txt:./headless/Headless.vcxproj.filters:    <ClCompile Include="SDLHeadlessHost.cpp">
./platform_references_code.txt:./headless/Headless.vcxproj.filters:    <ClCompile Include="..\Windows\CaptureDevice.cpp">
./platform_references_code.txt:./headless/Headless.vcxproj.filters:      <Filter>Windows</Filter>
./platform_references_code.txt:./headless/Headless.vcxproj.filters:    <ClInclude Include="WindowsHeadlessHost.h">
./platform_references_code.txt:./headless/Headless.vcxproj.filters:      <Filter>Windows</Filter>
./platform_references_code.txt:./headless/Headless.vcxproj.filters:    <ClInclude Include="SDLHeadlessHost.h">
./platform_references_code.txt:./headless/Headless.vcxproj.filters:    <Filter Include="Windows">
./platform_references_code.txt:./headless/WindowsHeadlessHost.cpp:#include "headless/WindowsHeadlessHost.h"
./platform_references_code.txt:./headless/WindowsHeadlessHost.cpp:#include "Common/CommonWindows.h"
./platform_references_code.txt:./headless/WindowsHeadlessHost.cpp:#include "Windows/GPU/WindowsGLContext.h"
./platform_references_code.txt:./headless/WindowsHeadlessHost.cpp:#include "Windows/GPU/D3D11Context.h"
./platform_references_code.txt:./headless/WindowsHeadlessHost.cpp:#include "Windows/GPU/WindowsVulkanContext.h"
./platform_references_code.txt:./headless/WindowsHeadlessHost.cpp:void WindowsHeadlessHost::SendDebugOutput(const std::string &output) {
./platform_references_code.txt:./headless/WindowsHeadlessHost.cpp:bool WindowsHeadlessHost::InitGraphics(std::string *error_message, GraphicsContext **ctx, GPUCore core) {
./platform_references_code.txt:./headless/WindowsHeadlessHost.cpp:	WindowsGraphicsContext *graphicsContext = nullptr;
./platform_references_code.txt:./headless/WindowsHeadlessHost.cpp:		graphicsContext = new WindowsGLContext();
./platform_references_code.txt:./headless/WindowsHeadlessHost.cpp:		graphicsContext = new WindowsVulkanContext();
./platform_references_code.txt:./headless/WindowsHeadlessHost.cpp:void WindowsHeadlessHost::ShutdownGraphics() {
./platform_references_code.txt:./headless/WindowsHeadlessHost.cpp:void WindowsHeadlessHost::SwapBuffers() {}
./platform_references_code.txt:./headless/WindowsHeadlessHost.h:#define HEADLESSHOST_CLASS WindowsHeadlessHost
./platform_references_code.txt:./headless/WindowsHeadlessHost.h:#include "Common/CommonWindows.h"
./platform_references_code.txt:./headless/WindowsHeadlessHost.h:class WindowsHeadlessHost : public HeadlessHost
./platform_references_code.txt:./history.md:	- SDL: Improve input latency in Vulkan mode by running rendering on a separate thread ([#18268])
./platform_references_code.txt:./history.md:- Fix the store on iOS ([#18323])
./platform_references_code.txt:./history.md:- Fix problem when changing backend from the Windows menu ([#18182])
./platform_references_code.txt:./history.md:- Fix for HTTP support on Linux on networks with shaky or incomplete IPv6 support
./platform_references_code.txt:./history.md:  - Fix flicker in WWE Smackdown vs Raw 2006 ([#18009]), video flicker in Naruto 2 ([#18008])
./platform_references_code.txt:./history.md:  - Allow disabling V-sync on Android with Vulkan, more SDL platforms ([#17903], [#18087])
./platform_references_code.txt:./history.md:  - HTTPS support now enabled in store and for RA on Windows, Android, Mac, iOS ([#17744], ...)
./platform_references_code.txt:./history.md:  - Use TTF fonts on SDL where available (macOS, Linux/Steam Deck) ([#17844]), support HiDPI ([#17651])
./platform_references_code.txt:./history.md:  - Allow setting the PSP's MAC address directly ([#17755])
./platform_references_code.txt:./history.md:  - UWP keyboard support, many other updates ([#17952], [#17974])
./platform_references_code.txt:./history.md:  - Windows Dark Mode support ([#16704])
./platform_references_code.txt:./history.md:  - GTA math issue on macOS/iOS fixed, playable again ([#16928])
./platform_references_code.txt:./history.md:  - IR Jit fixes - helps iOS when native jit is unavailable ([#17129])
./platform_references_code.txt:./history.md:  - macOS native menu bar ([#16922])
./platform_references_code.txt:./history.md:  - UI fixes: Vertical use of space ([#16795]), scrollbars ([#16785]), touchpad scroll on Windows ([#16699])
./platform_references_code.txt:./history.md:  - Misshitsu no Sacrifice intro animation and Macross water rendering fixed (3D texture) ([#15727])
./platform_references_code.txt:./history.md:* IR interpreter (iOS, etc.) bug fixes
./platform_references_code.txt:./history.md:* Confirmation dialog added before change of MAC address ([#15738])
./platform_references_code.txt:./history.md:* Windows/Xbox UWP directory navigation improvements ([#15652])
./platform_references_code.txt:./history.md:* Bug fixes (control mapping fix, popup menus in the Windows debugger, a few crashfixes)
./platform_references_code.txt:./history.md:* iOS: Fix multitouch tracking ([#5099])
./platform_references_code.txt:./history.md:* Linux: Improve support for system FFmpeg 3.1+ ([#14176], [#14188], [#14199])
./platform_references_code.txt:./history.md:* libretro: Always enable function hooks ([#14145])
./platform_references_code.txt:./history.md:* Add iOS version detection, turn off JIT on bootup if >= 14.3. ([#14201])
./platform_references_code.txt:./history.md:* iOS: Try a different JIT detection method, thanks Halo-Michael ([#14241])
./platform_references_code.txt:./history.md:* Windows: Restore window size correctly ([#14317])
./platform_references_code.txt:./history.md:* Option to switch to new devices or not, on Windows.
./platform_references_code.txt:./history.md:* Fix socket error 10014 on Windows when hosting a game of Vulcanus Seek and Destroy ([#14849])
./platform_references_code.txt:./history.md:* Workaround for rendering bugs with flat shading in iOS 14
./platform_references_code.txt:./history.md:* Audio and multiple hangs fixes in UWP version ([#13792], ...)
./platform_references_code.txt:./history.md:* Added "Lower resolution for effects" on libretro ([#13654])
./platform_references_code.txt:./history.md:* Fixed audio glitches in SDL builds ([#12916], [#12920])
./platform_references_code.txt:./history.md:* Mac build now supports Vulkan on top of MoltenVK ([#12583])
./platform_references_code.txt:./history.md:* Camera supported on Windows, Linux and Mac (still no microphone though) ([#12572], [#12580], [#12607])
./platform_references_code.txt:./history.md:* SDL mouse support, Qt menu upgrades ([#12612], [#12817])
./platform_references_code.txt:./history.md:* Fixed fullscreen toggling with Vulkan in SDL builds ([#11974])
./platform_references_code.txt:./history.md:* Multiple fixes for the UWP build ([#12036], others)
./platform_references_code.txt:./history.md:* Added Visual Studio 2019 support. Windows XP is no longer supported ([#11995], others)
./platform_references_code.txt:./history.md:* Improved mouse control (Windows only) ([#12173], [#12176])
./platform_references_code.txt:./history.md:* Support for resizing Vulkan on Linux ([#11451])
./platform_references_code.txt:./history.md:* Improved support for GLES on Linux/IoT ([#11507], [#11537], [#11541], [#11632], [#11746], [#11806], [#11845])
./platform_references_code.txt:./history.md:* Fix Motorstorm freeze on non-Windows ([#11618])
./platform_references_code.txt:./history.md:* Fix some Qt port issues with recent performance improvements ([#11720], [#11807], [#11808])
./platform_references_code.txt:./history.md:* UWP Xbox One: fix X/Back button confusion ([#11740])
./platform_references_code.txt:./history.md:* Bundle SDL in binary for macOS builds ([#11831])
./platform_references_code.txt:./history.md:* Prevent keeping games open on Windows ([#11842])
./platform_references_code.txt:./history.md:* Fixes to sound output switching on Windows (WASAPI) ([#11438])
./platform_references_code.txt:./history.md:* Multiple iOS fixes, including JIT ([#10465]) and file browser ([#10921]).
./platform_references_code.txt:./history.md:* Improved compatibility on Mac ([#10113])
./platform_references_code.txt:./history.md:* Vulkan support on Linux/SDL ([#10413])
./platform_references_code.txt:./history.md:* Linux controller mapping fixes ([#9997])
./platform_references_code.txt:./history.md:* Basic mouse input support on Windows
./platform_references_code.txt:./history.md:* Windows desktop touch fixes ([#9560])
./platform_references_code.txt:./history.md:* Fix JIT problems on Galaxy S7 and iOS 9+ devices. ([#8965], [#8937])
./platform_references_code.txt:./history.md:* Direct3D 9 supported as a rendering backend on Windows, helps on old GPUs and can be faster than OpenGL in many cases
./platform_references_code.txt:./history.md:* Improved audio output code on both Windows and Android, reducing audio latency on Windows and on some Android systems
./platform_references_code.txt:./history.md:* Updated to SDL2 where applicable (Linux, Mac)
./platform_references_code.txt:./history.md:* Initial multitouch support on Windows 8 for on-screen controls.
./platform_references_code.txt:./history.md:* Qt audio has been fixed.
./platform_references_code.txt:./history.md:yet. Also, it uses a port < 1000 and thats reserved for admin apps on linux, running the emu
./platform_references_code.txt:./history.md:* Now compiles on both Mac OSX and Windows. For more details on how to play and build
./platform_references_code.txt:./history.md:* Got it tested windows <-> mac osx <-> psp, it works
./platform_references_code.txt:./history.md:[#10921]: https://github.com/hrydgard/ppsspp/issues/10921 "Add support for File app (file browser) on iOS 11"
./platform_references_code.txt:./history.md:[#10413]: https://github.com/hrydgard/ppsspp/issues/10413 "SDL/X11 Vulkan init"
./platform_references_code.txt:./history.md:[#9997]: https://github.com/hrydgard/ppsspp/issues/9997 "Create default mapping for unknown control pads in SDL's controller database"
./platform_references_code.txt:./history.md:[#8937]: https://github.com/hrydgard/ppsspp/issues/8937 "Implement W^X-compatible JIT. Hopefully makes JIT work on iOS again"
./platform_references_code.txt:./history.md:[#8801]: https://github.com/hrydgard/ppsspp/issues/8801 "Improve performance on Raspberry Pi (and maybe other Linux)"
./platform_references_code.txt:./history.md:[#8949]: https://github.com/hrydgard/ppsspp/issues/8949 "Adds --PS3 comand line option for PS3 controller support on SDL."
./platform_references_code.txt:./history.md:[#12036]: https://github.com/hrydgard/ppsspp/issues/12036 "Several UWP fixes"
./platform_references_code.txt:./history.md:[#11802]: https://github.com/hrydgard/ppsspp/issues/11802 "Windows: Detect Vulkan in separate process"
./platform_references_code.txt:./history.md:[#11451]: https://github.com/hrydgard/ppsspp/issues/11451 "SDL/Vulkan window resize improvements"
./platform_references_code.txt:./history.md:[#11507]: https://github.com/hrydgard/ppsspp/issues/11507 "Improve support of Qt + USING_GLES2"
./platform_references_code.txt:./history.md:[#11632]: https://github.com/hrydgard/ppsspp/issues/11632 "SDL: Allow toggling fullscreen for GLES2 on desktops."
./platform_references_code.txt:./history.md:[#11806]: https://github.com/hrydgard/ppsspp/issues/11806 "SDL: Force fullscreen desktop for USING_FBDEV"
./platform_references_code.txt:./history.md:[#11658]: https://github.com/hrydgard/ppsspp/issues/11658 "Windows: Hide Vulkan/D3D11 if not available"
./platform_references_code.txt:./history.md:[#11720]: https://github.com/hrydgard/ppsspp/issues/11720 "Try to support Qt keyboard input directly. Fixes #11653"
./platform_references_code.txt:./history.md:[#11807]: https://github.com/hrydgard/ppsspp/issues/11807 "Qt: Re-enable Load button to browse for file"
./platform_references_code.txt:./history.md:[#11808]: https://github.com/hrydgard/ppsspp/issues/11808 "Qt: Correct text bind on first draw of string"
./platform_references_code.txt:./history.md:[#11831]: https://github.com/hrydgard/ppsspp/issues/11831 "Bundle libSDL inside app on macOS, fixes #11830"
./platform_references_code.txt:./history.md:[#11461]: https://github.com/hrydgard/ppsspp/issues/11461 "Windows: Detect DirectInput devices after launch"
./platform_references_code.txt:./history.md:[#11307]: https://github.com/hrydgard/ppsspp/issues/11307 "Enable Discord integration for Mac and Linux."
./platform_references_code.txt:./history.md:[#12817]: https://github.com/hrydgard/ppsspp/issues/12817 "Unification of the menu of Linux and Windows versions"
./platform_references_code.txt:./history.md:[#12612]: https://github.com/hrydgard/ppsspp/issues/12612 "SDL analog mouse input"
./platform_references_code.txt:./history.md:[#12552]: https://github.com/hrydgard/ppsspp/issues/12552 "Qt/macOS: enable HiDPI ( retina display ) support"
./platform_references_code.txt:./history.md:[#12607]: https://github.com/hrydgard/ppsspp/issues/12607 "QT API for camera (Linux/macOS)"
./platform_references_code.txt:./history.md:[#12580]: https://github.com/hrydgard/ppsspp/issues/12580 "Add camera support for linux (V4L2)"
./platform_references_code.txt:./history.md:[#12572]: https://github.com/hrydgard/ppsspp/issues/12572 "Add camera support for windows."
./platform_references_code.txt:./history.md:[#12583]: https://github.com/hrydgard/ppsspp/issues/12583 "macOS: Initial support for vulkan on macOS ( MoltenVK )"
./platform_references_code.txt:./history.md:[#12876]: https://github.com/hrydgard/ppsspp/issues/12876 "Windows: Add safety checks to WASAPI code"
./platform_references_code.txt:./history.md:[#12916]: https://github.com/hrydgard/ppsspp/issues/12916 "More audio buffering fixes (primarily affects SDL)"
./platform_references_code.txt:./history.md:[#13654]: https://github.com/hrydgard/ppsspp/issues/13654 "Expose the \"Lower resolution for effects\" setting in libretro."
./platform_references_code.txt:./history.md:[#13792]: https://github.com/hrydgard/ppsspp/issues/13792 "Fix UWP audio and a hang bug"
./platform_references_code.txt:./history.md:[#13897]: https://github.com/hrydgard/ppsspp/issues/13897 "LittleBigPlanet - Game Not Loading, Blue Screen (iOS, Unplayable)"
./platform_references_code.txt:./history.md:[#5099]: https://github.com/hrydgard/ppsspp/issues/5099 "IOS touch controls problems."
./platform_references_code.txt:./history.md:[#14145]: https://github.com/hrydgard/ppsspp/issues/14145 "libretro: Remove \"Unsafe FuncReplacements\" option."
./platform_references_code.txt:./history.md:[#14201]: https://github.com/hrydgard/ppsspp/issues/14201 "Add iOS version detection, turn off JIT on bootup if >= 14.3."
./platform_references_code.txt:./history.md:[#14241]: https://github.com/hrydgard/ppsspp/issues/14241 "iOS: Try a different JIT detection method, thanks Halo-Michael."
./platform_references_code.txt:./history.md:[#14768]: https://github.com/hrydgard/ppsspp/issues/14768 "Fix the math in cardboard VR mode for wide aspect ratios"
./platform_references_code.txt:./history.md:[#14849]: https://github.com/hrydgard/ppsspp/issues/14849 "[Adhoc] Fix Socket error 10014 on Windows when hosting a game of Vulcanus Seek and Destroy"
./platform_references_code.txt:./history.md:[#11974]: https://github.com/hrydgard/ppsspp/issues/11974 "[Linux] [Vulkan] Toggle fullscreen doesn't update display properly"
./platform_references_code.txt:./history.md:[#15748]: https://github.com/hrydgard/ppsspp/issues/15748 "Windows: Add a simple window message to get the base pointer."
./platform_references_code.txt:./history.md:[#15738]: https://github.com/hrydgard/ppsspp/issues/15738 "Add confirmation dialog when generating a new Mac address"
./platform_references_code.txt:./history.md:[#12949]: https://github.com/hrydgard/ppsspp/issues/12949 "Star Wars: The Clone Wars - Graphic glitch [Android/Windows]"
./platform_references_code.txt:./history.md:[#15652]: https://github.com/hrydgard/ppsspp/issues/15652 "Replace Win32 file IO with UWP safe variants and add support for getting drives to UWP build"
./platform_references_code.txt:./history.md:[#15424]: https://github.com/hrydgard/ppsspp/issues/15424 "Windows: Create SYSTEM directory early"
./platform_references_code.txt:./history.md:[#17422]: https://github.com/hrydgard/ppsspp/issues/17422 "Windows: Fix initial window show for all displays"
./platform_references_code.txt:./history.md:[#16704]: https://github.com/hrydgard/ppsspp/issues/16704 "Windows Dark Mode: initial support"
./platform_references_code.txt:./history.md:[#16928]: https://github.com/hrydgard/ppsspp/issues/16928 "Workaround for sin/cos issue in GTA on Mac (and maybe others)"
./platform_references_code.txt:./history.md:[#17203]: https://github.com/hrydgard/ppsspp/issues/17203 "Added new option \"Copy Float (32 bit)\" to Windows Debugger UI"
./platform_references_code.txt:./history.md:[#16922]: https://github.com/hrydgard/ppsspp/issues/16922 "macOS native bar button items"
./platform_references_code.txt:./history.md:[#16699]: https://github.com/hrydgard/ppsspp/issues/16699 "Fix smooth touchpad scrolling on Windows"
./platform_references_code.txt:./history.md:[#18323]: https://github.com/hrydgard/ppsspp/issues/18323 "Turn off HTTPS support for iOS."
./platform_references_code.txt:./history.md:[#18126]: https://github.com/hrydgard/ppsspp/issues/18126 "PPGe: Use texture windows for atlas text"
./platform_references_code.txt:./history.md:[#18087]: https://github.com/hrydgard/ppsspp/issues/18087 "Vulkan: Fix disabling VSync on SDL platforms that support IMMEDIATE but not MAILBOX"
./platform_references_code.txt:./history.md:[#17856]: https://github.com/hrydgard/ppsspp/issues/17856 "Windows UWP: Enable color emoji rendering through DirectWrite"
./platform_references_code.txt:./history.md:[#17844]: https://github.com/hrydgard/ppsspp/issues/17844 "SDL: text renderer fixes, and CI"
./platform_references_code.txt:./history.md:[#17651]: https://github.com/hrydgard/ppsspp/issues/17651 "SDL: support HiDPI on wayland"
./platform_references_code.txt:./history.md:[#17755]: https://github.com/hrydgard/ppsspp/issues/17755 "Allow entering an exact Mac address, while keeping the randomization ability"
./platform_references_code.txt:./history.md:[#17952]: https://github.com/hrydgard/ppsspp/issues/17952 "[UWP] Improvements 2 (Configs, Render, Input)"
./platform_references_code.txt:./history.md:[#17974]: https://github.com/hrydgard/ppsspp/issues/17974 "(UWP) Another Round of Code Cleanups"
./platform_references_code.txt:./history.md:[#18732]: https://github.com/hrydgard/ppsspp/issues/18732 "SDL fonts: Add \"Droid Sans Fallback\" to the list of fallback fonts."
./platform_references_code.txt:./history.md:[#18734]: https://github.com/hrydgard/ppsspp/issues/18734 "SDL fallback fonts: Add more font names"
./platform_references_code.txt:./history.md:[#18268]: https://github.com/hrydgard/ppsspp/issues/18268 "SDL: Use an \"EmuThread\" in Vulkan mode"
./platform_references_code.txt:./ppge_atlasscript.txt:font UBUNTU24 C:/Windows/Fonts/KozGoPro-Medium.otf UWkhcJGRS 24
./platform_references_code.txt:./ppge_atlasscript.txt:font UBUNTU24 C:/Windows/Fonts/ARIALUNI.ttf UWEhkcRGHKVTeS 24 0
./platform_references_code.txt:./ppsspp_config.h:    // Covers both 32 and 64bit Windows
./platform_references_code.txt:./ppsspp_config.h:    #define PPSSPP_PLATFORM_WINDOWS 1
./platform_references_code.txt:./ppsspp_config.h:	// UWP trickery
./platform_references_code.txt:./ppsspp_config.h:            #define PPSSPP_PLATFORM_UWP 1
./platform_references_code.txt:./ppsspp_config.h:        #define PPSSPP_PLATFORM_IOS 1
./platform_references_code.txt:./ppsspp_config.h:        #define PPSSPP_PLATFORM_IOS_SIMULATOR 1
./platform_references_code.txt:./ppsspp_config.h:        #define PPSSPP_PLATFORM_IOS 1
./platform_references_code.txt:./ppsspp_config.h:    #elif TARGET_OS_MAC
./platform_references_code.txt:./ppsspp_config.h:        #define PPSSPP_PLATFORM_MAC 1
./platform_references_code.txt:./ppsspp_config.h:    #define PPSSPP_PLATFORM_LINUX 1
./platform_references_code.txt:./ppsspp_config.h:#elif defined(__linux__)
./platform_references_code.txt:./ppsspp_config.h:    #define PPSSPP_PLATFORM_LINUX 1
./platform_references_code.txt:./ppsspp_config.h:// Windows ARM/ARM64, and Windows UWP (all), are the only platform that don't do GL at all (until Apple finally removes it)
./platform_references_code.txt:./ppsspp_config.h:#if !PPSSPP_PLATFORM(WINDOWS) || ((!PPSSPP_ARCH(ARM) && !PPSSPP_ARCH(ARM64)) && !PPSSPP_PLATFORM(UWP))
./platform_references_code.txt:./ppsspp_config.h:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./scripts/makeappimage_64-bit.sh:if [ -d /usr/lib/"$ARCH"-linux-gnu ]; then
./platform_references_code.txt:./scripts/makeappimage_64-bit.sh:	SYS_LIB_DIR=/usr/lib/"$ARCH"-linux-gnu
./platform_references_code.txt:./scripts/makeappimage_64-bit.sh:cp -v  ../SDL/PPSSPPSDL.desktop ./
./platform_references_code.txt:./scripts/makeappimage_64-bit.sh:	../build/PPSSPPSDL \
./platform_references_code.txt:./scripts/makeappimage_64-bit.sh:	"$SYS_LIB_DIR"/libSDL* \
./platform_references_code.txt:./scripts/makeappimage_64-bit.sh:ln -s ./bin/PPSSPPSDL ./AppRun
./platform_references_code.txt:./scripts/makeappimage_64-bit.sh:	-i ./AppDir -o PPSSPP-"$VERSION"-anylinux-"$ARCH".AppImage
./platform_references_code.txt:./test.py:  # Windows
./platform_references_code.txt:./test.py:  "Windows\\Debug\\PPSSPPHeadless.exe",
./platform_references_code.txt:./test.py:  "Windows\\Release\\PPSSPPHeadless.exe",
./platform_references_code.txt:./test.py:  "Windows\\x64\\Debug\\PPSSPPHeadless.exe",
./platform_references_code.txt:./test.py:  "Windows\\x64\\Release\\PPSSPPHeadless.exe",
./platform_references_code.txt:./test.py:  # Mac
./platform_references_code.txt:./test.py:  # Linux
./platform_references_code.txt:./test.py:  "dmac/dmactest",
./platform_references_code.txt:./unittest/JitHarness.cpp:#if !PPSSPP_PLATFORM(MAC)
./platform_references_code.txt:./unittest/TestShaderGenerators.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./unittest/TestShaderGenerators.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./unittest/TestShaderGenerators.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./unittest/TestShaderGenerators.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./unittest/TestShaderGenerators.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./unittest/TestShaderGenerators.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./unittest/TestShaderGenerators.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./unittest/UnitTest.cpp:	const char *macstr = "01:02:03:ff:fe:fd";
./platform_references_code.txt:./unittest/UnitTest.cpp:	uint8_t mac[6];
./platform_references_code.txt:./unittest/UnitTest.cpp:	ParseMacAddress(macstr, mac);
./platform_references_code.txt:./unittest/UnitTest.cpp:	EXPECT_TRUE(mac[0] == 1);
./platform_references_code.txt:./unittest/UnitTest.cpp:	EXPECT_TRUE(mac[1] == 2);
./platform_references_code.txt:./unittest/UnitTest.cpp:	EXPECT_TRUE(mac[2] == 3);
./platform_references_code.txt:./unittest/UnitTest.cpp:	EXPECT_TRUE(mac[3] == 255);
./platform_references_code.txt:./unittest/UnitTest.cpp:	EXPECT_TRUE(mac[4] == 254);
./platform_references_code.txt:./unittest/UnitTest.cpp:	EXPECT_TRUE(mac[5] == 253);
./platform_references_code.txt:./unittest/UnitTest.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:  <PropertyGroup Label="UserMacros" />
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSdk_LibraryPath_x86);</LibraryPath>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSdk_LibraryPath_x64);</LibraryPath>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <LibraryPath>$(VC_LibraryPath_ARM64);$(WindowsSdk_LibraryPath_ARM64);</LibraryPath>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSdk_LibraryPath_x86);</LibraryPath>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSdk_LibraryPath_x64);</LibraryPath>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <LibraryPath>$(VC_LibraryPath_ARM64);$(WindowsSdk_LibraryPath_ARM64);</LibraryPath>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <PreprocessorDefinitions>_CRTDBG_MAP_ALLOC;USING_WIN_UI;USING_WIN_UI;GLEW_STATIC;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_ARCH_32=1;_WINDOWS;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86/include;../ext;../common;..;../ext/glew;../ext/zlib</AdditionalIncludeDirectories>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86/lib</AdditionalLibraryDirectories>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <PreprocessorDefinitions>_CRTDBG_MAP_ALLOC;USING_WIN_UI;GLEW_STATIC;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_ARCH_64=1;_WINDOWS;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86_64/include;../ext;../common;..;../ext/glew;../ext/zlib</AdditionalIncludeDirectories>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86_64/lib</AdditionalLibraryDirectories>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <PreprocessorDefinitions>_CRTDBG_MAP_ALLOC;USING_WIN_UI;GLEW_STATIC;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_ARCH_64=1;_WINDOWS;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/aarch64/include;../ext;../common;..;../ext/glew;../ext/zlib</AdditionalIncludeDirectories>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/aarch64/lib</AdditionalLibraryDirectories>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <PreprocessorDefinitions>USING_WIN_UI;GLEW_STATIC;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_ARCH_32=1;_WINDOWS;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86/include;../ext;../common;..;../ext/glew;../ext/zlib</AdditionalIncludeDirectories>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86/lib</AdditionalLibraryDirectories>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <PreprocessorDefinitions>USING_WIN_UI;GLEW_STATIC;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_ARCH_64=1;_WINDOWS;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86_64/include;../ext;../common;..;../ext/glew;../ext/zlib</AdditionalIncludeDirectories>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86_64/lib</AdditionalLibraryDirectories>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <PreprocessorDefinitions>USING_WIN_UI;GLEW_STATIC;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_ARCH_64=1;_WINDOWS;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/aarch64/include;../ext;../common;..;../ext/glew;../ext/zlib</AdditionalIncludeDirectories>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/aarch64/lib</AdditionalLibraryDirectories>
./platform_references_code.txt:./unittest/UnitTests.vcxproj:    <ClCompile Include="..\Windows\CaptureDevice.cpp" />
./platform_references_code.txt:./unittest/UnitTests.vcxproj.filters:    <ClCompile Include="..\Windows\CaptureDevice.cpp">
./platform_references_code.txt:./unittest/UnitTests.vcxproj.filters:      <Filter>Windows</Filter>
./platform_references_code.txt:./unittest/UnitTests.vcxproj.filters:    <Filter Include="Windows">
./b.sh:		--no-sdl2) CMAKE_ARGS="-DUSE_SYSTEM_LIBSDL2=OFF ${CMAKE_ARGS}"
./build_fontatlas.sh:# TOOL=Windows/ARM64/Debug/AtlasTool.exe
./cmake/Modules/FindLIBZIP.cmake:    [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session\ Manager\\Environment;OSG_ROOT]/include
./cmake/Modules/FindLIBZIP.cmake:    [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session\ Manager\\Environment;OSG_ROOT]/lib
./cmake/Toolchains/ios.cmake:# IOS_PLATFORM = OS (default)
./cmake/Toolchains/ios.cmake:# CMAKE_IOS_SDK_ROOT = automatic(default) or /path/to/platform/Developer/SDKs/SDK folder
./cmake/Toolchains/ios.cmake:#   By default this location is automatcially chosen based on the CMAKE_IOS_DEVELOPER_ROOT value.
./cmake/Toolchains/ios.cmake:#   In this case it will always be the most up-to-date SDK found in the CMAKE_IOS_DEVELOPER_ROOT path.
./cmake/Toolchains/ios.cmake:if(IOS_PLATFORM STREQUAL "TVOS")
./cmake/Toolchains/ios.cmake:  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -mios-version-min=${IPHONEOS_DEPLOYMENT_TARGET}")
./cmake/Toolchains/ios.cmake:  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mios-version-min=${IPHONEOS_DEPLOYMENT_TARGET}")
./cmake/Toolchains/ios.cmake:set(IOS ON)
./cmake/Toolchains/ios.cmake:set(CMAKE_MACOSX_BUNDLE YES)
./cmake/Toolchains/ios.cmake:if(IOS_PLATFORM STREQUAL "TVOS")
./cmake/Toolchains/ios.cmake:# Setup iOS platform unless specified manually with IOS_PLATFORM
./cmake/Toolchains/ios.cmake:if(NOT DEFINED IOS_PLATFORM)
./cmake/Toolchains/ios.cmake:  set(IOS_PLATFORM "OS")
./cmake/Toolchains/ios.cmake:set(IOS_PLATFORM ${IOS_PLATFORM} CACHE STRING "Type of iOS Platform")
./cmake/Toolchains/ios.cmake:if(IOS_PLATFORM STREQUAL "OS")
./cmake/Toolchains/ios.cmake:  set(IOS_SDK_NAME "iphoneos")
./cmake/Toolchains/ios.cmake:elseif(IOS_PLATFORM STREQUAL "SIMULATOR")
./cmake/Toolchains/ios.cmake:  set(IOS_SDK_NAME "iphonesimulator")
./cmake/Toolchains/ios.cmake:elseif(IOS_PLATFORM STREQUAL "TVOS")
./cmake/Toolchains/ios.cmake:  set(IOS_SDK_NAME "appletvos")
./cmake/Toolchains/ios.cmake:  message (FATAL_ERROR "Unsupported IOS_PLATFORM value selected '${IOS_PLATFORM}'. Please choose OS or leave default")
./cmake/Toolchains/ios.cmake:# Setup iOS developer location unless specified manually with CMAKE_IOS_DEVELOPER_ROOT
./cmake/Toolchains/ios.cmake:if(NOT CMAKE_IOS_SDK_ROOT)
./cmake/Toolchains/ios.cmake:  execute_process(COMMAND xcrun --sdk ${IOS_SDK_NAME} --show-sdk-path
./cmake/Toolchains/ios.cmake:    OUTPUT_VARIABLE CMAKE_IOS_SDK_ROOT
./cmake/Toolchains/ios.cmake:  message (STATUS "Toolchain using default iOS SDK: ${CMAKE_IOS_SDK_ROOT}")
./cmake/Toolchains/ios.cmake:set(CMAKE_IOS_SDK_ROOT ${CMAKE_IOS_SDK_ROOT} CACHE PATH "Location of the selected iOS SDK")
./cmake/Toolchains/ios.cmake:set(CMAKE_OSX_SYSROOT ${CMAKE_IOS_SDK_ROOT} CACHE PATH "Sysroot used for iOS support")
./cmake/Toolchains/ios.cmake:# set the architecture for iOS 
./cmake/Toolchains/ios.cmake:if(IOS_PLATFORM STREQUAL "OS" OR IOS_PLATFORM STREQUAL "TVOS")
./cmake/Toolchains/ios.cmake:  set(IOS_ARCH "arm64")
./cmake/Toolchains/ios.cmake:  set(IOS_ARCH "i386;x86_64")
./cmake/Toolchains/ios.cmake:set(CMAKE_OSX_ARCHITECTURES "${IOS_ARCH}" CACHE STRING "Build architecture for iOS")
./cmake/Toolchains/ios.cmake:foreach(arch ${IOS_ARCH})
./cmake/Toolchains/ios.cmake:# Set the find root to the iOS developer roots and to user defined paths
./cmake/Toolchains/ios.cmake:set(CMAKE_FIND_ROOT_PATH ${CMAKE_IOS_SDK_ROOT} ${CMAKE_PREFIX_PATH} CACHE STRING "iOS find search path root")
./cmake/Toolchains/ios.cmake:  ${CMAKE_IOS_SDK_ROOT}/System/Library/Frameworks
./cmake/Toolchains/ios.cmake:  ${CMAKE_IOS_SDK_ROOT}/System/Library/PrivateFrameworks
./cmake/Toolchains/ios.cmake:  ${CMAKE_IOS_SDK_ROOT}/Developer/Library/Frameworks
./cmake/Toolchains/ios.cmake:# only search the iOS sdks, not the remainder of the host filesystem
./cmake/Toolchains/nvidiajetsonsdl.armv8.cmake:if(NOT EXISTS "/usr/lib/aarch64-linux-gnu/tegra")
./cmake/Toolchains/nvidiajetsonsdl.armv8.cmake:set (CMAKE_EXE_LINKER_FLAGS "-Wl,-rpath,/usr/lib/aarch64-linux-gnu/tegra" CACHE STRING "" FORCE)
./cmake/Toolchains/nvidiajetsonsdl.armv8.cmake:set(OPENGL_LIBRARIES  /usr/lib/aarch64-linux-gnu/tegra/libGLX_nvidia.so.0)
./cmake/Toolchains/raspberry.armv6.cmake:  /opt/vc/include/interface/vmcx_host/linux
./cmake/Toolchains/raspberry.armv7.cmake:  /opt/vc/include/interface/vmcx_host/linux
./cmake/Toolchains/raspberry.armv8.cmake:  /opt/vc/include/interface/vmcx_host/linux
./copyrelease.sh:cp PPSSPPWindows.exe $TARGETPATH/
./copyrelease.sh:cp PPSSPPWindows64.exe $TARGETPATH/
./copysym.sh:DSYM_PATH="build-ios/Release-iphoneos/${APP_NAME}.app.dSYM"
./gradlew:# For Cygwin, switch paths to Windows format before running java
./headless/Compare.cpp:#include <iostream>
./headless/Headless.cpp:// To build on non-windows systems, just run CMake in the SDL directory, it will build both a normal ppsspp and the headless version.
./headless/Headless.cpp:#include "Common/CommonWindows.h"
./headless/Headless.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./headless/Headless.cpp:#include "WindowsHeadlessHost.h"
./headless/Headless.cpp:#elif defined(SDL)
./headless/Headless.cpp:#include "SDLHeadlessHost.h"
./headless/Headless.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./headless/Headless.cpp:	g_Config.bIgnoreBadMemAccess = true;  // NOTE: A few tests rely on this, which is BAD: threads/mbx/refer/refer , threads/mbx/send/send, threads/vtimers/interrupt
./headless/Headless.cpp:	g_Config.sMACAddress = "12:34:56:78:9A:BC";
./headless/Headless.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./headless/Headless.cpp:#elif PPSSPP_PLATFORM(LINUX)
./headless/Headless.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./headless/Headless.vcxproj:    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
./headless/Headless.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./headless/Headless.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./headless/Headless.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./headless/Headless.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./headless/Headless.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./headless/Headless.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./headless/Headless.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./headless/Headless.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./headless/Headless.vcxproj:  <PropertyGroup Label="UserMacros" />
./headless/Headless.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./headless/Headless.vcxproj:    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSdk_LibraryPath_x86);</LibraryPath>
./headless/Headless.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./headless/Headless.vcxproj:    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSdk_LibraryPath_x64);</LibraryPath>
./headless/Headless.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./headless/Headless.vcxproj:    <LibraryPath>$(VC_LibraryPath_ARM64);$(WindowsSdk_LibraryPath_ARM64);</LibraryPath>
./headless/Headless.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./headless/Headless.vcxproj:    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSdk_LibraryPath_x86);</LibraryPath>
./headless/Headless.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./headless/Headless.vcxproj:    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSdk_LibraryPath_x64);</LibraryPath>
./headless/Headless.vcxproj:    <IncludePath>$(VC_IncludePath);$(WindowsSdk_IncludePath);</IncludePath>
./headless/Headless.vcxproj:    <LibraryPath>$(VC_LibraryPath_ARM64);$(WindowsSdk_LibraryPath_ARM64);</LibraryPath>
./headless/Headless.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86/include;../Common;..;../Core;../ext/glew;../ext/libpng17</AdditionalIncludeDirectories>
./headless/Headless.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86/lib</AdditionalLibraryDirectories>
./headless/Headless.vcxproj:      <Command>../Windows/git-version-gen.cmd Headless</Command>
./headless/Headless.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86_64/include;../Common;..;../Core;../ext/glew;../ext/libpng17</AdditionalIncludeDirectories>
./headless/Headless.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86_64/lib</AdditionalLibraryDirectories>
./headless/Headless.vcxproj:      <Command>../Windows/git-version-gen.cmd Headless</Command>
./headless/Headless.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/aarch64/include;../Common;..;../Core;../ext/glew;../ext/libpng17</AdditionalIncludeDirectories>
./headless/Headless.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/aarch64/lib</AdditionalLibraryDirectories>
./headless/Headless.vcxproj:      <Command>../Windows/git-version-gen.cmd Headless</Command>
./headless/Headless.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86/include;../Common;..;../Core;../ext/glew;../ext/libpng17</AdditionalIncludeDirectories>
./headless/Headless.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86/lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
./headless/Headless.vcxproj:      <Command>../Windows/git-version-gen.cmd Headless</Command>
./headless/Headless.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86_64/include;../Common;..;../Core;../ext/glew;../ext/libpng17</AdditionalIncludeDirectories>
./headless/Headless.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86_64/lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
./headless/Headless.vcxproj:      <Command>../Windows/git-version-gen.cmd Headless</Command>
./headless/Headless.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/aarch64/include;../Common;..;../Core;../ext/glew;../ext/libpng17</AdditionalIncludeDirectories>
./headless/Headless.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/aarch64/lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
./headless/Headless.vcxproj:      <Command>../Windows/git-version-gen.cmd Headless</Command>
./headless/Headless.vcxproj:    <ClCompile Include="..\Windows\CaptureDevice.cpp" />
./headless/Headless.vcxproj:    <ClCompile Include="..\Windows\GPU\D3D11Context.cpp" />
./headless/Headless.vcxproj:    <ClCompile Include="..\Windows\GPU\WindowsGLContext.cpp">
./headless/Headless.vcxproj:    <ClCompile Include="..\Windows\GPU\WindowsVulkanContext.cpp" />
./headless/Headless.vcxproj:    <ClCompile Include="..\Windows\W32Util\Misc.cpp" />
./headless/Headless.vcxproj:    <ClCompile Include="SDLHeadlessHost.cpp">
./headless/Headless.vcxproj:    <ClCompile Include="WindowsHeadlessHost.cpp" />
./headless/Headless.vcxproj:    <ClInclude Include="SDLHeadlessHost.h" />
./headless/Headless.vcxproj:    <ClInclude Include="WindowsHeadlessHost.h" />
./headless/Headless.vcxproj.filters:    <ClCompile Include="..\Windows\GPU\WindowsGLContext.cpp">
./headless/Headless.vcxproj.filters:      <Filter>Windows</Filter>
./headless/Headless.vcxproj.filters:    <ClCompile Include="WindowsHeadlessHost.cpp">
./headless/Headless.vcxproj.filters:      <Filter>Windows</Filter>
./headless/Headless.vcxproj.filters:    <ClCompile Include="..\Windows\GPU\WindowsVulkanContext.cpp">
./headless/Headless.vcxproj.filters:      <Filter>Windows</Filter>
./headless/Headless.vcxproj.filters:    <ClCompile Include="..\Windows\W32Util\Misc.cpp">
./headless/Headless.vcxproj.filters:      <Filter>Windows</Filter>
./headless/Headless.vcxproj.filters:    <ClCompile Include="..\Windows\GPU\D3D11Context.cpp">
./headless/Headless.vcxproj.filters:      <Filter>Windows</Filter>
./headless/Headless.vcxproj.filters:    <ClCompile Include="SDLHeadlessHost.cpp">
./headless/Headless.vcxproj.filters:    <ClCompile Include="..\Windows\CaptureDevice.cpp">
./headless/Headless.vcxproj.filters:      <Filter>Windows</Filter>
./headless/Headless.vcxproj.filters:    <ClInclude Include="WindowsHeadlessHost.h">
./headless/Headless.vcxproj.filters:      <Filter>Windows</Filter>
./headless/Headless.vcxproj.filters:    <ClInclude Include="SDLHeadlessHost.h">
./headless/Headless.vcxproj.filters:    <Filter Include="Windows">
./headless/WindowsHeadlessHost.cpp:#include "headless/WindowsHeadlessHost.h"
./headless/WindowsHeadlessHost.cpp:#include "Common/CommonWindows.h"
./headless/WindowsHeadlessHost.cpp:#include "Windows/GPU/WindowsGLContext.h"
./headless/WindowsHeadlessHost.cpp:#include "Windows/GPU/D3D11Context.h"
./headless/WindowsHeadlessHost.cpp:#include "Windows/GPU/WindowsVulkanContext.h"
./headless/WindowsHeadlessHost.cpp:void WindowsHeadlessHost::SendDebugOutput(const std::string &output) {
./headless/WindowsHeadlessHost.cpp:bool WindowsHeadlessHost::InitGraphics(std::string *error_message, GraphicsContext **ctx, GPUCore core) {
./headless/WindowsHeadlessHost.cpp:	WindowsGraphicsContext *graphicsContext = nullptr;
./headless/WindowsHeadlessHost.cpp:		graphicsContext = new WindowsGLContext();
./headless/WindowsHeadlessHost.cpp:		graphicsContext = new WindowsVulkanContext();
./headless/WindowsHeadlessHost.cpp:void WindowsHeadlessHost::ShutdownGraphics() {
./headless/WindowsHeadlessHost.cpp:void WindowsHeadlessHost::SwapBuffers() {}
./headless/WindowsHeadlessHost.h:#define HEADLESSHOST_CLASS WindowsHeadlessHost
./headless/WindowsHeadlessHost.h:#include "Common/CommonWindows.h"
./headless/WindowsHeadlessHost.h:class WindowsHeadlessHost : public HeadlessHost
./history.md:	- SDL: Improve input latency in Vulkan mode by running rendering on a separate thread ([#18268])
./history.md:- Fix the store on iOS ([#18323])
./history.md:- Fix problem when changing backend from the Windows menu ([#18182])
./history.md:- Fix for HTTP support on Linux on networks with shaky or incomplete IPv6 support
./history.md:  - Fix flicker in WWE Smackdown vs Raw 2006 ([#18009]), video flicker in Naruto 2 ([#18008])
./history.md:  - Allow disabling V-sync on Android with Vulkan, more SDL platforms ([#17903], [#18087])
./history.md:  - HTTPS support now enabled in store and for RA on Windows, Android, Mac, iOS ([#17744], ...)
./history.md:  - Use TTF fonts on SDL where available (macOS, Linux/Steam Deck) ([#17844]), support HiDPI ([#17651])
./history.md:  - Allow setting the PSP's MAC address directly ([#17755])
./history.md:  - UWP keyboard support, many other updates ([#17952], [#17974])
./history.md:  - Windows Dark Mode support ([#16704])
./history.md:  - GTA math issue on macOS/iOS fixed, playable again ([#16928])
./history.md:  - IR Jit fixes - helps iOS when native jit is unavailable ([#17129])
./history.md:  - macOS native menu bar ([#16922])
./history.md:  - UI fixes: Vertical use of space ([#16795]), scrollbars ([#16785]), touchpad scroll on Windows ([#16699])
./history.md:  - Misshitsu no Sacrifice intro animation and Macross water rendering fixed (3D texture) ([#15727])
./history.md:* IR interpreter (iOS, etc.) bug fixes
./history.md:* Confirmation dialog added before change of MAC address ([#15738])
./history.md:* Windows/Xbox UWP directory navigation improvements ([#15652])
./history.md:* Bug fixes (control mapping fix, popup menus in the Windows debugger, a few crashfixes)
./history.md:* iOS: Fix multitouch tracking ([#5099])
./history.md:* Linux: Improve support for system FFmpeg 3.1+ ([#14176], [#14188], [#14199])
./history.md:* libretro: Always enable function hooks ([#14145])
./history.md:* Add iOS version detection, turn off JIT on bootup if >= 14.3. ([#14201])
./history.md:* iOS: Try a different JIT detection method, thanks Halo-Michael ([#14241])
./history.md:* Windows: Restore window size correctly ([#14317])
./history.md:* Option to switch to new devices or not, on Windows.
./history.md:* Fix socket error 10014 on Windows when hosting a game of Vulcanus Seek and Destroy ([#14849])
./history.md:* Workaround for rendering bugs with flat shading in iOS 14
./history.md:* Audio and multiple hangs fixes in UWP version ([#13792], ...)
./history.md:* Added "Lower resolution for effects" on libretro ([#13654])
./history.md:* Fixed audio glitches in SDL builds ([#12916], [#12920])
./history.md:* Mac build now supports Vulkan on top of MoltenVK ([#12583])
./history.md:* Camera supported on Windows, Linux and Mac (still no microphone though) ([#12572], [#12580], [#12607])
./history.md:* SDL mouse support, Qt menu upgrades ([#12612], [#12817])
./history.md:* Fixed fullscreen toggling with Vulkan in SDL builds ([#11974])
./history.md:* Multiple fixes for the UWP build ([#12036], others)
./history.md:* Added Visual Studio 2019 support. Windows XP is no longer supported ([#11995], others)
./history.md:* Improved mouse control (Windows only) ([#12173], [#12176])
./history.md:* Support for resizing Vulkan on Linux ([#11451])
./history.md:* Improved support for GLES on Linux/IoT ([#11507], [#11537], [#11541], [#11632], [#11746], [#11806], [#11845])
./history.md:* Fix Motorstorm freeze on non-Windows ([#11618])
./history.md:* Fix some Qt port issues with recent performance improvements ([#11720], [#11807], [#11808])
./history.md:* UWP Xbox One: fix X/Back button confusion ([#11740])
./history.md:* Bundle SDL in binary for macOS builds ([#11831])
./history.md:* Prevent keeping games open on Windows ([#11842])
./history.md:* Fixes to sound output switching on Windows (WASAPI) ([#11438])
./history.md:* Multiple iOS fixes, including JIT ([#10465]) and file browser ([#10921]).
./history.md:* Improved compatibility on Mac ([#10113])
./history.md:* Vulkan support on Linux/SDL ([#10413])
./history.md:* Linux controller mapping fixes ([#9997])
./history.md:* Basic mouse input support on Windows
./history.md:* Windows desktop touch fixes ([#9560])
./history.md:* Fix JIT problems on Galaxy S7 and iOS 9+ devices. ([#8965], [#8937])
./history.md:* Direct3D 9 supported as a rendering backend on Windows, helps on old GPUs and can be faster than OpenGL in many cases
./history.md:* Improved audio output code on both Windows and Android, reducing audio latency on Windows and on some Android systems
./history.md:* Updated to SDL2 where applicable (Linux, Mac)
./history.md:* Initial multitouch support on Windows 8 for on-screen controls.
./history.md:* Qt audio has been fixed.
./history.md:yet. Also, it uses a port < 1000 and thats reserved for admin apps on linux, running the emu
./history.md:* Now compiles on both Mac OSX and Windows. For more details on how to play and build
./history.md:* Got it tested windows <-> mac osx <-> psp, it works
./history.md:[#10921]: https://github.com/hrydgard/ppsspp/issues/10921 "Add support for File app (file browser) on iOS 11"
./history.md:[#10413]: https://github.com/hrydgard/ppsspp/issues/10413 "SDL/X11 Vulkan init"
./history.md:[#9997]: https://github.com/hrydgard/ppsspp/issues/9997 "Create default mapping for unknown control pads in SDL's controller database"
./history.md:[#8937]: https://github.com/hrydgard/ppsspp/issues/8937 "Implement W^X-compatible JIT. Hopefully makes JIT work on iOS again"
./history.md:[#8801]: https://github.com/hrydgard/ppsspp/issues/8801 "Improve performance on Raspberry Pi (and maybe other Linux)"
./history.md:[#8949]: https://github.com/hrydgard/ppsspp/issues/8949 "Adds --PS3 comand line option for PS3 controller support on SDL."
./history.md:[#12036]: https://github.com/hrydgard/ppsspp/issues/12036 "Several UWP fixes"
./history.md:[#11802]: https://github.com/hrydgard/ppsspp/issues/11802 "Windows: Detect Vulkan in separate process"
./history.md:[#11451]: https://github.com/hrydgard/ppsspp/issues/11451 "SDL/Vulkan window resize improvements"
./history.md:[#11507]: https://github.com/hrydgard/ppsspp/issues/11507 "Improve support of Qt + USING_GLES2"
./history.md:[#11632]: https://github.com/hrydgard/ppsspp/issues/11632 "SDL: Allow toggling fullscreen for GLES2 on desktops."
./history.md:[#11806]: https://github.com/hrydgard/ppsspp/issues/11806 "SDL: Force fullscreen desktop for USING_FBDEV"
./history.md:[#11658]: https://github.com/hrydgard/ppsspp/issues/11658 "Windows: Hide Vulkan/D3D11 if not available"
./history.md:[#11720]: https://github.com/hrydgard/ppsspp/issues/11720 "Try to support Qt keyboard input directly. Fixes #11653"
./history.md:[#11807]: https://github.com/hrydgard/ppsspp/issues/11807 "Qt: Re-enable Load button to browse for file"
./history.md:[#11808]: https://github.com/hrydgard/ppsspp/issues/11808 "Qt: Correct text bind on first draw of string"
./history.md:[#11831]: https://github.com/hrydgard/ppsspp/issues/11831 "Bundle libSDL inside app on macOS, fixes #11830"
./history.md:[#11461]: https://github.com/hrydgard/ppsspp/issues/11461 "Windows: Detect DirectInput devices after launch"
./history.md:[#11307]: https://github.com/hrydgard/ppsspp/issues/11307 "Enable Discord integration for Mac and Linux."
./history.md:[#12817]: https://github.com/hrydgard/ppsspp/issues/12817 "Unification of the menu of Linux and Windows versions"
./history.md:[#12612]: https://github.com/hrydgard/ppsspp/issues/12612 "SDL analog mouse input"
./history.md:[#12552]: https://github.com/hrydgard/ppsspp/issues/12552 "Qt/macOS: enable HiDPI ( retina display ) support"
./history.md:[#12607]: https://github.com/hrydgard/ppsspp/issues/12607 "QT API for camera (Linux/macOS)"
./history.md:[#12580]: https://github.com/hrydgard/ppsspp/issues/12580 "Add camera support for linux (V4L2)"
./history.md:[#12572]: https://github.com/hrydgard/ppsspp/issues/12572 "Add camera support for windows."
./history.md:[#12583]: https://github.com/hrydgard/ppsspp/issues/12583 "macOS: Initial support for vulkan on macOS ( MoltenVK )"
./history.md:[#12876]: https://github.com/hrydgard/ppsspp/issues/12876 "Windows: Add safety checks to WASAPI code"
./history.md:[#12916]: https://github.com/hrydgard/ppsspp/issues/12916 "More audio buffering fixes (primarily affects SDL)"
./history.md:[#13654]: https://github.com/hrydgard/ppsspp/issues/13654 "Expose the \"Lower resolution for effects\" setting in libretro."
./history.md:[#13792]: https://github.com/hrydgard/ppsspp/issues/13792 "Fix UWP audio and a hang bug"
./history.md:[#13897]: https://github.com/hrydgard/ppsspp/issues/13897 "LittleBigPlanet - Game Not Loading, Blue Screen (iOS, Unplayable)"
./history.md:[#5099]: https://github.com/hrydgard/ppsspp/issues/5099 "IOS touch controls problems."
./history.md:[#14145]: https://github.com/hrydgard/ppsspp/issues/14145 "libretro: Remove \"Unsafe FuncReplacements\" option."
./history.md:[#14201]: https://github.com/hrydgard/ppsspp/issues/14201 "Add iOS version detection, turn off JIT on bootup if >= 14.3."
./history.md:[#14241]: https://github.com/hrydgard/ppsspp/issues/14241 "iOS: Try a different JIT detection method, thanks Halo-Michael."
./history.md:[#14768]: https://github.com/hrydgard/ppsspp/issues/14768 "Fix the math in cardboard VR mode for wide aspect ratios"
./history.md:[#14849]: https://github.com/hrydgard/ppsspp/issues/14849 "[Adhoc] Fix Socket error 10014 on Windows when hosting a game of Vulcanus Seek and Destroy"
./history.md:[#11974]: https://github.com/hrydgard/ppsspp/issues/11974 "[Linux] [Vulkan] Toggle fullscreen doesn't update display properly"
./history.md:[#15748]: https://github.com/hrydgard/ppsspp/issues/15748 "Windows: Add a simple window message to get the base pointer."
./history.md:[#15738]: https://github.com/hrydgard/ppsspp/issues/15738 "Add confirmation dialog when generating a new Mac address"
./history.md:[#12949]: https://github.com/hrydgard/ppsspp/issues/12949 "Star Wars: The Clone Wars - Graphic glitch [Android/Windows]"
./history.md:[#15652]: https://github.com/hrydgard/ppsspp/issues/15652 "Replace Win32 file IO with UWP safe variants and add support for getting drives to UWP build"
./history.md:[#15424]: https://github.com/hrydgard/ppsspp/issues/15424 "Windows: Create SYSTEM directory early"
./history.md:[#17422]: https://github.com/hrydgard/ppsspp/issues/17422 "Windows: Fix initial window show for all displays"
./history.md:[#16704]: https://github.com/hrydgard/ppsspp/issues/16704 "Windows Dark Mode: initial support"
./history.md:[#16928]: https://github.com/hrydgard/ppsspp/issues/16928 "Workaround for sin/cos issue in GTA on Mac (and maybe others)"
./history.md:[#17203]: https://github.com/hrydgard/ppsspp/issues/17203 "Added new option \"Copy Float (32 bit)\" to Windows Debugger UI"
./history.md:[#16922]: https://github.com/hrydgard/ppsspp/issues/16922 "macOS native bar button items"
./history.md:[#16699]: https://github.com/hrydgard/ppsspp/issues/16699 "Fix smooth touchpad scrolling on Windows"
./history.md:[#18323]: https://github.com/hrydgard/ppsspp/issues/18323 "Turn off HTTPS support for iOS."
./history.md:[#18126]: https://github.com/hrydgard/ppsspp/issues/18126 "PPGe: Use texture windows for atlas text"
./history.md:[#18087]: https://github.com/hrydgard/ppsspp/issues/18087 "Vulkan: Fix disabling VSync on SDL platforms that support IMMEDIATE but not MAILBOX"
./history.md:[#17856]: https://github.com/hrydgard/ppsspp/issues/17856 "Windows UWP: Enable color emoji rendering through DirectWrite"
./history.md:[#17844]: https://github.com/hrydgard/ppsspp/issues/17844 "SDL: text renderer fixes, and CI"
./history.md:[#17651]: https://github.com/hrydgard/ppsspp/issues/17651 "SDL: support HiDPI on wayland"
./history.md:[#17755]: https://github.com/hrydgard/ppsspp/issues/17755 "Allow entering an exact Mac address, while keeping the randomization ability"
./history.md:[#17952]: https://github.com/hrydgard/ppsspp/issues/17952 "[UWP] Improvements 2 (Configs, Render, Input)"
./history.md:[#17974]: https://github.com/hrydgard/ppsspp/issues/17974 "(UWP) Another Round of Code Cleanups"
./history.md:[#18732]: https://github.com/hrydgard/ppsspp/issues/18732 "SDL fonts: Add \"Droid Sans Fallback\" to the list of fallback fonts."
./history.md:[#18734]: https://github.com/hrydgard/ppsspp/issues/18734 "SDL fallback fonts: Add more font names"
./history.md:[#18268]: https://github.com/hrydgard/ppsspp/issues/18268 "SDL: Use an \"EmuThread\" in Vulkan mode"
./ppge_atlasscript.txt:font UBUNTU24 C:/Windows/Fonts/KozGoPro-Medium.otf UWkhcJGRS 24
./ppge_atlasscript.txt:font UBUNTU24 C:/Windows/Fonts/ARIALUNI.ttf UWEhkcRGHKVTeS 24 0
./ppsspp_config.h:    // Covers both 32 and 64bit Windows
./ppsspp_config.h:    #define PPSSPP_PLATFORM_WINDOWS 1
./ppsspp_config.h:	// UWP trickery
./ppsspp_config.h:            #define PPSSPP_PLATFORM_UWP 1
./ppsspp_config.h:        #define PPSSPP_PLATFORM_IOS 1
./ppsspp_config.h:        #define PPSSPP_PLATFORM_IOS_SIMULATOR 1
./ppsspp_config.h:        #define PPSSPP_PLATFORM_IOS 1
./ppsspp_config.h:    #elif TARGET_OS_MAC
./ppsspp_config.h:        #define PPSSPP_PLATFORM_MAC 1
./ppsspp_config.h:    #define PPSSPP_PLATFORM_LINUX 1
./ppsspp_config.h:#elif defined(__linux__)
./ppsspp_config.h:    #define PPSSPP_PLATFORM_LINUX 1
./ppsspp_config.h:// Windows ARM/ARM64, and Windows UWP (all), are the only platform that don't do GL at all (until Apple finally removes it)
./ppsspp_config.h:#if !PPSSPP_PLATFORM(WINDOWS) || ((!PPSSPP_ARCH(ARM) && !PPSSPP_ARCH(ARM64)) && !PPSSPP_PLATFORM(UWP))
./ppsspp_config.h:#if PPSSPP_PLATFORM(WINDOWS)
./scripts/makeappimage_64-bit.sh:if [ -d /usr/lib/"$ARCH"-linux-gnu ]; then
./scripts/makeappimage_64-bit.sh:	SYS_LIB_DIR=/usr/lib/"$ARCH"-linux-gnu
./scripts/makeappimage_64-bit.sh:cp -v  ../SDL/PPSSPPSDL.desktop ./
./scripts/makeappimage_64-bit.sh:	../build/PPSSPPSDL \
./scripts/makeappimage_64-bit.sh:	"$SYS_LIB_DIR"/libSDL* \
./scripts/makeappimage_64-bit.sh:ln -s ./bin/PPSSPPSDL ./AppRun
./scripts/makeappimage_64-bit.sh:	-i ./AppDir -o PPSSPP-"$VERSION"-anylinux-"$ARCH".AppImage
./test.py:  # Windows
./test.py:  "Windows\\Debug\\PPSSPPHeadless.exe",
./test.py:  "Windows\\Release\\PPSSPPHeadless.exe",
./test.py:  "Windows\\x64\\Debug\\PPSSPPHeadless.exe",
./test.py:  "Windows\\x64\\Release\\PPSSPPHeadless.exe",
./test.py:  # Mac
./test.py:  # Linux
./test.py:  "dmac/dmactest",
./unittest/JitHarness.cpp:#if !PPSSPP_PLATFORM(MAC)
./unittest/TestShaderGenerators.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./unittest/TestShaderGenerators.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./unittest/TestShaderGenerators.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./unittest/TestShaderGenerators.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./unittest/TestShaderGenerators.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./unittest/TestShaderGenerators.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./unittest/TestShaderGenerators.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./unittest/UnitTest.cpp:	const char *macstr = "01:02:03:ff:fe:fd";
./unittest/UnitTest.cpp:	uint8_t mac[6];
./unittest/UnitTest.cpp:	ParseMacAddress(macstr, mac);
./unittest/UnitTest.cpp:	EXPECT_TRUE(mac[0] == 1);
./unittest/UnitTest.cpp:	EXPECT_TRUE(mac[1] == 2);
./unittest/UnitTest.cpp:	EXPECT_TRUE(mac[2] == 3);
./unittest/UnitTest.cpp:	EXPECT_TRUE(mac[3] == 255);
./unittest/UnitTest.cpp:	EXPECT_TRUE(mac[4] == 254);
./unittest/UnitTest.cpp:	EXPECT_TRUE(mac[5] == 253);
./unittest/UnitTest.cpp:#if PPSSPP_PLATFORM(WINDOWS)
./unittest/UnitTests.vcxproj:    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
./unittest/UnitTests.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./unittest/UnitTests.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./unittest/UnitTests.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./unittest/UnitTests.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./unittest/UnitTests.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./unittest/UnitTests.vcxproj:    <Import Project="..\Windows\fix_2017.props" />
./unittest/UnitTests.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./unittest/UnitTests.vcxproj:    <WindowsSDKDesktopARM64Support>true</WindowsSDKDesktopARM64Support>
./unittest/UnitTests.vcxproj:  <PropertyGroup Label="UserMacros" />
./unittest/UnitTests.vcxproj:    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSdk_LibraryPath_x86);</LibraryPath>
./unittest/UnitTests.vcxproj:    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSdk_LibraryPath_x64);</LibraryPath>
./unittest/UnitTests.vcxproj:    <LibraryPath>$(VC_LibraryPath_ARM64);$(WindowsSdk_LibraryPath_ARM64);</LibraryPath>
./unittest/UnitTests.vcxproj:    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSdk_LibraryPath_x86);</LibraryPath>
./unittest/UnitTests.vcxproj:    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSdk_LibraryPath_x64);</LibraryPath>
./unittest/UnitTests.vcxproj:    <LibraryPath>$(VC_LibraryPath_ARM64);$(WindowsSdk_LibraryPath_ARM64);</LibraryPath>
./unittest/UnitTests.vcxproj:      <PreprocessorDefinitions>_CRTDBG_MAP_ALLOC;USING_WIN_UI;USING_WIN_UI;GLEW_STATIC;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_ARCH_32=1;_WINDOWS;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
./unittest/UnitTests.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86/include;../ext;../common;..;../ext/glew;../ext/zlib</AdditionalIncludeDirectories>
./unittest/UnitTests.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86/lib</AdditionalLibraryDirectories>
./unittest/UnitTests.vcxproj:      <PreprocessorDefinitions>_CRTDBG_MAP_ALLOC;USING_WIN_UI;GLEW_STATIC;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_ARCH_64=1;_WINDOWS;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
./unittest/UnitTests.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86_64/include;../ext;../common;..;../ext/glew;../ext/zlib</AdditionalIncludeDirectories>
./unittest/UnitTests.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86_64/lib</AdditionalLibraryDirectories>
./unittest/UnitTests.vcxproj:      <PreprocessorDefinitions>_CRTDBG_MAP_ALLOC;USING_WIN_UI;GLEW_STATIC;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_ARCH_64=1;_WINDOWS;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
./unittest/UnitTests.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/aarch64/include;../ext;../common;..;../ext/glew;../ext/zlib</AdditionalIncludeDirectories>
./unittest/UnitTests.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/aarch64/lib</AdditionalLibraryDirectories>
./unittest/UnitTests.vcxproj:      <PreprocessorDefinitions>USING_WIN_UI;GLEW_STATIC;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_ARCH_32=1;_WINDOWS;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
./unittest/UnitTests.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86/include;../ext;../common;..;../ext/glew;../ext/zlib</AdditionalIncludeDirectories>
./unittest/UnitTests.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86/lib</AdditionalLibraryDirectories>
./unittest/UnitTests.vcxproj:      <PreprocessorDefinitions>USING_WIN_UI;GLEW_STATIC;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_ARCH_64=1;_WINDOWS;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
./unittest/UnitTests.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/x86_64/include;../ext;../common;..;../ext/glew;../ext/zlib</AdditionalIncludeDirectories>
./unittest/UnitTests.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/x86_64/lib</AdditionalLibraryDirectories>
./unittest/UnitTests.vcxproj:      <PreprocessorDefinitions>USING_WIN_UI;GLEW_STATIC;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_ARCH_64=1;_WINDOWS;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
./unittest/UnitTests.vcxproj:      <AdditionalIncludeDirectories>../ffmpeg/Windows/aarch64/include;../ext;../common;..;../ext/glew;../ext/zlib</AdditionalIncludeDirectories>
./unittest/UnitTests.vcxproj:      <AdditionalLibraryDirectories>../ffmpeg/Windows/aarch64/lib</AdditionalLibraryDirectories>
./unittest/UnitTests.vcxproj:    <ClCompile Include="..\Windows\CaptureDevice.cpp" />
./unittest/UnitTests.vcxproj.filters:    <ClCompile Include="..\Windows\CaptureDevice.cpp">
./unittest/UnitTests.vcxproj.filters:      <Filter>Windows</Filter>
./unittest/UnitTests.vcxproj.filters:    <Filter Include="Windows">
